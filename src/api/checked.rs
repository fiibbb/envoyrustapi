// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/api/expr/v1alpha1/checked.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct CheckedExpr {
    // message fields
    pub reference_map: ::std::collections::HashMap<i64, Reference>,
    pub type_map: ::std::collections::HashMap<i64, Type>,
    pub source_info: ::protobuf::SingularPtrField<super::syntax::SourceInfo>,
    pub expr: ::protobuf::SingularPtrField<super::syntax::Expr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckedExpr {
    fn default() -> &'a CheckedExpr {
        <CheckedExpr as ::protobuf::Message>::default_instance()
    }
}

impl CheckedExpr {
    pub fn new() -> CheckedExpr {
        ::std::default::Default::default()
    }

    // repeated .google.api.expr.v1alpha1.CheckedExpr.ReferenceMapEntry reference_map = 2;


    pub fn get_reference_map(&self) -> &::std::collections::HashMap<i64, Reference> {
        &self.reference_map
    }
    pub fn clear_reference_map(&mut self) {
        self.reference_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_reference_map(&mut self, v: ::std::collections::HashMap<i64, Reference>) {
        self.reference_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reference_map(&mut self) -> &mut ::std::collections::HashMap<i64, Reference> {
        &mut self.reference_map
    }

    // Take field
    pub fn take_reference_map(&mut self) -> ::std::collections::HashMap<i64, Reference> {
        ::std::mem::replace(&mut self.reference_map, ::std::collections::HashMap::new())
    }

    // repeated .google.api.expr.v1alpha1.CheckedExpr.TypeMapEntry type_map = 3;


    pub fn get_type_map(&self) -> &::std::collections::HashMap<i64, Type> {
        &self.type_map
    }
    pub fn clear_type_map(&mut self) {
        self.type_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_map(&mut self, v: ::std::collections::HashMap<i64, Type>) {
        self.type_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_type_map(&mut self) -> &mut ::std::collections::HashMap<i64, Type> {
        &mut self.type_map
    }

    // Take field
    pub fn take_type_map(&mut self) -> ::std::collections::HashMap<i64, Type> {
        ::std::mem::replace(&mut self.type_map, ::std::collections::HashMap::new())
    }

    // .google.api.expr.v1alpha1.SourceInfo source_info = 5;


    pub fn get_source_info(&self) -> &super::syntax::SourceInfo {
        self.source_info.as_ref().unwrap_or_else(|| <super::syntax::SourceInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source_info(&mut self) {
        self.source_info.clear();
    }

    pub fn has_source_info(&self) -> bool {
        self.source_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_info(&mut self, v: super::syntax::SourceInfo) {
        self.source_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_info(&mut self) -> &mut super::syntax::SourceInfo {
        if self.source_info.is_none() {
            self.source_info.set_default();
        }
        self.source_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_info(&mut self) -> super::syntax::SourceInfo {
        self.source_info.take().unwrap_or_else(|| super::syntax::SourceInfo::new())
    }

    // .google.api.expr.v1alpha1.Expr expr = 4;


    pub fn get_expr(&self) -> &super::syntax::Expr {
        self.expr.as_ref().unwrap_or_else(|| <super::syntax::Expr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expr(&mut self) {
        self.expr.clear();
    }

    pub fn has_expr(&self) -> bool {
        self.expr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expr(&mut self, v: super::syntax::Expr) {
        self.expr = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expr(&mut self) -> &mut super::syntax::Expr {
        if self.expr.is_none() {
            self.expr.set_default();
        }
        self.expr.as_mut().unwrap()
    }

    // Take field
    pub fn take_expr(&mut self) -> super::syntax::Expr {
        self.expr.take().unwrap_or_else(|| super::syntax::Expr::new())
    }
}

impl ::protobuf::Message for CheckedExpr {
    fn is_initialized(&self) -> bool {
        for v in &self.source_info {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expr {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Reference>>(wire_type, is, &mut self.reference_map)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Type>>(wire_type, is, &mut self.type_map)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_info)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Reference>>(2, &self.reference_map);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Type>>(3, &self.type_map);
        if let Some(ref v) = self.source_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.expr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Reference>>(2, &self.reference_map, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Type>>(3, &self.type_map, os)?;
        if let Some(ref v) = self.source_info.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.expr.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckedExpr {
        CheckedExpr::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Reference>>(
                "reference_map",
                |m: &CheckedExpr| { &m.reference_map },
                |m: &mut CheckedExpr| { &mut m.reference_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "type_map",
                |m: &CheckedExpr| { &m.type_map },
                |m: &mut CheckedExpr| { &mut m.type_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::syntax::SourceInfo>>(
                "source_info",
                |m: &CheckedExpr| { &m.source_info },
                |m: &mut CheckedExpr| { &mut m.source_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::syntax::Expr>>(
                "expr",
                |m: &CheckedExpr| { &m.expr },
                |m: &mut CheckedExpr| { &mut m.expr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckedExpr>(
                "CheckedExpr",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckedExpr {
        static instance: ::protobuf::rt::LazyV2<CheckedExpr> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckedExpr::new)
    }
}

impl ::protobuf::Clear for CheckedExpr {
    fn clear(&mut self) {
        self.reference_map.clear();
        self.type_map.clear();
        self.source_info.clear();
        self.expr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckedExpr {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckedExpr {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type {
    // message oneof groups
    pub type_kind: ::std::option::Option<Type_oneof_type_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Type_oneof_type_kind {
    field_dyn(::protobuf::well_known_types::Empty),
    null(::protobuf::well_known_types::NullValue),
    primitive(Type_PrimitiveType),
    wrapper(Type_PrimitiveType),
    well_known(Type_WellKnownType),
    list_type(Type_ListType),
    map_type(Type_MapType),
    function(Type_FunctionType),
    message_type(::std::string::String),
    type_param(::std::string::String),
    field_type(::std::boxed::Box<Type>),
    error(::protobuf::well_known_types::Empty),
    abstract_type(Type_AbstractType),
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }

    // .google.protobuf.Empty dyn = 1;


    pub fn get_field_dyn(&self) -> &::protobuf::well_known_types::Empty {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_field_dyn(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_field_dyn(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_dyn(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(v))
    }

    // Mutable pointer to the field.
    pub fn mut_field_dyn(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(::protobuf::well_known_types::Empty::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_dyn(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_field_dyn() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.NullValue null = 2;


    pub fn get_null(&self) -> ::protobuf::well_known_types::NullValue {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::null(v)) => v,
            _ => ::protobuf::well_known_types::NullValue::NULL_VALUE,
        }
    }
    pub fn clear_null(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_null(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::null(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_null(&mut self, v: ::protobuf::well_known_types::NullValue) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::null(v))
    }

    // .google.api.expr.v1alpha1.Type.PrimitiveType primitive = 3;


    pub fn get_primitive(&self) -> Type_PrimitiveType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::primitive(v)) => v,
            _ => Type_PrimitiveType::PRIMITIVE_TYPE_UNSPECIFIED,
        }
    }
    pub fn clear_primitive(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_primitive(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::primitive(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_primitive(&mut self, v: Type_PrimitiveType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::primitive(v))
    }

    // .google.api.expr.v1alpha1.Type.PrimitiveType wrapper = 4;


    pub fn get_wrapper(&self) -> Type_PrimitiveType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::wrapper(v)) => v,
            _ => Type_PrimitiveType::PRIMITIVE_TYPE_UNSPECIFIED,
        }
    }
    pub fn clear_wrapper(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_wrapper(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::wrapper(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_wrapper(&mut self, v: Type_PrimitiveType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::wrapper(v))
    }

    // .google.api.expr.v1alpha1.Type.WellKnownType well_known = 5;


    pub fn get_well_known(&self) -> Type_WellKnownType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::well_known(v)) => v,
            _ => Type_WellKnownType::WELL_KNOWN_TYPE_UNSPECIFIED,
        }
    }
    pub fn clear_well_known(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_well_known(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::well_known(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_well_known(&mut self, v: Type_WellKnownType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::well_known(v))
    }

    // .google.api.expr.v1alpha1.Type.ListType list_type = 6;


    pub fn get_list_type(&self) -> &Type_ListType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::list_type(ref v)) => v,
            _ => <Type_ListType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_list_type(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_list_type(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::list_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_list_type(&mut self, v: Type_ListType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::list_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_list_type(&mut self) -> &mut Type_ListType {
        if let ::std::option::Option::Some(Type_oneof_type_kind::list_type(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::list_type(Type_ListType::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::list_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_list_type(&mut self) -> Type_ListType {
        if self.has_list_type() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::list_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_ListType::new()
        }
    }

    // .google.api.expr.v1alpha1.Type.MapType map_type = 7;


    pub fn get_map_type(&self) -> &Type_MapType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::map_type(ref v)) => v,
            _ => <Type_MapType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_map_type(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_map_type(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::map_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_map_type(&mut self, v: Type_MapType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::map_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_map_type(&mut self) -> &mut Type_MapType {
        if let ::std::option::Option::Some(Type_oneof_type_kind::map_type(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::map_type(Type_MapType::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::map_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_map_type(&mut self) -> Type_MapType {
        if self.has_map_type() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::map_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_MapType::new()
        }
    }

    // .google.api.expr.v1alpha1.Type.FunctionType function = 8;


    pub fn get_function(&self) -> &Type_FunctionType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::function(ref v)) => v,
            _ => <Type_FunctionType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_function(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_function(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: Type_FunctionType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function(&mut self) -> &mut Type_FunctionType {
        if let ::std::option::Option::Some(Type_oneof_type_kind::function(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::function(Type_FunctionType::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function(&mut self) -> Type_FunctionType {
        if self.has_function() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::function(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_FunctionType::new()
        }
    }

    // string message_type = 9;


    pub fn get_message_type(&self) -> &str {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::message_type(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_message_type(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_message_type(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::message_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_type(&mut self, v: ::std::string::String) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::message_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_type(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Type_oneof_type_kind::message_type(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::message_type(::std::string::String::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::message_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_type(&mut self) -> ::std::string::String {
        if self.has_message_type() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::message_type(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string type_param = 10;


    pub fn get_type_param(&self) -> &str {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::type_param(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_type_param(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_type_param(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::type_param(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_type_param(&mut self, v: ::std::string::String) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::type_param(v))
    }

    // Mutable pointer to the field.
    pub fn mut_type_param(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(Type_oneof_type_kind::type_param(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::type_param(::std::string::String::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::type_param(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_type_param(&mut self) -> ::std::string::String {
        if self.has_type_param() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::type_param(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.api.expr.v1alpha1.Type type = 11;


    pub fn get_field_type(&self) -> &Type {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::field_type(ref v)) => v,
            _ => <Type as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_field_type(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::field_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::field_type(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if let ::std::option::Option::Some(Type_oneof_type_kind::field_type(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::field_type(::std::boxed::Box::new(Type::new())));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::field_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        if self.has_field_type() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::field_type(v)) => *v,
                _ => panic!(),
            }
        } else {
            Type::new()
        }
    }

    // .google.protobuf.Empty error = 12;


    pub fn get_error(&self) -> &::protobuf::well_known_types::Empty {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::error(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_error(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::error(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::error(v))
    }

    // Mutable pointer to the field.
    pub fn mut_error(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(Type_oneof_type_kind::error(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::error(::protobuf::well_known_types::Empty::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::error(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_error(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_error() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::error(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.api.expr.v1alpha1.Type.AbstractType abstract_type = 14;


    pub fn get_abstract_type(&self) -> &Type_AbstractType {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(ref v)) => v,
            _ => <Type_AbstractType as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_abstract_type(&mut self) {
        self.type_kind = ::std::option::Option::None;
    }

    pub fn has_abstract_type(&self) -> bool {
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_abstract_type(&mut self, v: Type_AbstractType) {
        self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(v))
    }

    // Mutable pointer to the field.
    pub fn mut_abstract_type(&mut self) -> &mut Type_AbstractType {
        if let ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(_)) = self.type_kind {
        } else {
            self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(Type_AbstractType::new()));
        }
        match self.type_kind {
            ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_abstract_type(&mut self) -> Type_AbstractType {
        if self.has_abstract_type() {
            match self.type_kind.take() {
                ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(v)) => v,
                _ => panic!(),
            }
        } else {
            Type_AbstractType::new()
        }
    }
}

impl ::protobuf::Message for Type {
    fn is_initialized(&self) -> bool {
        if let Some(Type_oneof_type_kind::field_dyn(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_type_kind::list_type(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_type_kind::map_type(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_type_kind::function(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_type_kind::field_type(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_type_kind::error(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Type_oneof_type_kind::abstract_type(ref v)) = self.type_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::field_dyn(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::null(is.read_enum()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::primitive(is.read_enum()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::wrapper(is.read_enum()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::well_known(is.read_enum()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::list_type(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::map_type(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::function(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::message_type(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::type_param(is.read_string()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::field_type(::std::boxed::Box::new(is.read_message()?)));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::error(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.type_kind = ::std::option::Option::Some(Type_oneof_type_kind::abstract_type(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.type_kind {
            match v {
                &Type_oneof_type_kind::field_dyn(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_type_kind::null(v) => {
                    my_size += ::protobuf::rt::enum_size(2, v);
                },
                &Type_oneof_type_kind::primitive(v) => {
                    my_size += ::protobuf::rt::enum_size(3, v);
                },
                &Type_oneof_type_kind::wrapper(v) => {
                    my_size += ::protobuf::rt::enum_size(4, v);
                },
                &Type_oneof_type_kind::well_known(v) => {
                    my_size += ::protobuf::rt::enum_size(5, v);
                },
                &Type_oneof_type_kind::list_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_type_kind::map_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_type_kind::function(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_type_kind::message_type(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &Type_oneof_type_kind::type_param(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
                &Type_oneof_type_kind::field_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_type_kind::error(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Type_oneof_type_kind::abstract_type(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.type_kind {
            match v {
                &Type_oneof_type_kind::field_dyn(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_type_kind::null(v) => {
                    os.write_enum(2, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Type_oneof_type_kind::primitive(v) => {
                    os.write_enum(3, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Type_oneof_type_kind::wrapper(v) => {
                    os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Type_oneof_type_kind::well_known(v) => {
                    os.write_enum(5, ::protobuf::ProtobufEnum::value(&v))?;
                },
                &Type_oneof_type_kind::list_type(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_type_kind::map_type(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_type_kind::function(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_type_kind::message_type(ref v) => {
                    os.write_string(9, v)?;
                },
                &Type_oneof_type_kind::type_param(ref v) => {
                    os.write_string(10, v)?;
                },
                &Type_oneof_type_kind::field_type(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_type_kind::error(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Type_oneof_type_kind::abstract_type(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "dyn",
                Type::has_field_dyn,
                Type::get_field_dyn,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, ::protobuf::well_known_types::NullValue>(
                "null",
                Type::has_null,
                Type::get_null,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, Type_PrimitiveType>(
                "primitive",
                Type::has_primitive,
                Type::get_primitive,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, Type_PrimitiveType>(
                "wrapper",
                Type::has_wrapper,
                Type::get_wrapper,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_enum_accessor::<_, Type_WellKnownType>(
                "well_known",
                Type::has_well_known,
                Type::get_well_known,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_ListType>(
                "list_type",
                Type::has_list_type,
                Type::get_list_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_MapType>(
                "map_type",
                Type::has_map_type,
                Type::get_map_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_FunctionType>(
                "function",
                Type::has_function,
                Type::get_function,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "message_type",
                Type::has_message_type,
                Type::get_message_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "type_param",
                Type::has_type_param,
                Type::get_type_param,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type>(
                "type",
                Type::has_field_type,
                Type::get_field_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "error",
                Type::has_error,
                Type::get_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Type_AbstractType>(
                "abstract_type",
                Type::has_abstract_type,
                Type::get_abstract_type,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type>(
                "Type",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type {
        static instance: ::protobuf::rt::LazyV2<Type> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type::new)
    }
}

impl ::protobuf::Clear for Type {
    fn clear(&mut self) {
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.type_kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_ListType {
    // message fields
    pub elem_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_ListType {
    fn default() -> &'a Type_ListType {
        <Type_ListType as ::protobuf::Message>::default_instance()
    }
}

impl Type_ListType {
    pub fn new() -> Type_ListType {
        ::std::default::Default::default()
    }

    // .google.api.expr.v1alpha1.Type elem_type = 1;


    pub fn get_elem_type(&self) -> &Type {
        self.elem_type.as_ref().unwrap_or_else(|| <Type as ::protobuf::Message>::default_instance())
    }
    pub fn clear_elem_type(&mut self) {
        self.elem_type.clear();
    }

    pub fn has_elem_type(&self) -> bool {
        self.elem_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elem_type(&mut self, v: Type) {
        self.elem_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_elem_type(&mut self) -> &mut Type {
        if self.elem_type.is_none() {
            self.elem_type.set_default();
        }
        self.elem_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_elem_type(&mut self) -> Type {
        self.elem_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for Type_ListType {
    fn is_initialized(&self) -> bool {
        for v in &self.elem_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.elem_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.elem_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.elem_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_ListType {
        Type_ListType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "elem_type",
                |m: &Type_ListType| { &m.elem_type },
                |m: &mut Type_ListType| { &mut m.elem_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type_ListType>(
                "Type.ListType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type_ListType {
        static instance: ::protobuf::rt::LazyV2<Type_ListType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type_ListType::new)
    }
}

impl ::protobuf::Clear for Type_ListType {
    fn clear(&mut self) {
        self.elem_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_ListType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_ListType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_MapType {
    // message fields
    pub key_type: ::protobuf::SingularPtrField<Type>,
    pub value_type: ::protobuf::SingularPtrField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_MapType {
    fn default() -> &'a Type_MapType {
        <Type_MapType as ::protobuf::Message>::default_instance()
    }
}

impl Type_MapType {
    pub fn new() -> Type_MapType {
        ::std::default::Default::default()
    }

    // .google.api.expr.v1alpha1.Type key_type = 1;


    pub fn get_key_type(&self) -> &Type {
        self.key_type.as_ref().unwrap_or_else(|| <Type as ::protobuf::Message>::default_instance())
    }
    pub fn clear_key_type(&mut self) {
        self.key_type.clear();
    }

    pub fn has_key_type(&self) -> bool {
        self.key_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_type(&mut self, v: Type) {
        self.key_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_type(&mut self) -> &mut Type {
        if self.key_type.is_none() {
            self.key_type.set_default();
        }
        self.key_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_type(&mut self) -> Type {
        self.key_type.take().unwrap_or_else(|| Type::new())
    }

    // .google.api.expr.v1alpha1.Type value_type = 2;


    pub fn get_value_type(&self) -> &Type {
        self.value_type.as_ref().unwrap_or_else(|| <Type as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value_type(&mut self) {
        self.value_type.clear();
    }

    pub fn has_value_type(&self) -> bool {
        self.value_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_type(&mut self, v: Type) {
        self.value_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_type(&mut self) -> &mut Type {
        if self.value_type.is_none() {
            self.value_type.set_default();
        }
        self.value_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_type(&mut self) -> Type {
        self.value_type.take().unwrap_or_else(|| Type::new())
    }
}

impl ::protobuf::Message for Type_MapType {
    fn is_initialized(&self) -> bool {
        for v in &self.key_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.key_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value_type.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_MapType {
        Type_MapType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "key_type",
                |m: &Type_MapType| { &m.key_type },
                |m: &mut Type_MapType| { &mut m.key_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "value_type",
                |m: &Type_MapType| { &m.value_type },
                |m: &mut Type_MapType| { &mut m.value_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type_MapType>(
                "Type.MapType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type_MapType {
        static instance: ::protobuf::rt::LazyV2<Type_MapType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type_MapType::new)
    }
}

impl ::protobuf::Clear for Type_MapType {
    fn clear(&mut self) {
        self.key_type.clear();
        self.value_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_MapType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_MapType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_FunctionType {
    // message fields
    pub result_type: ::protobuf::SingularPtrField<Type>,
    pub arg_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_FunctionType {
    fn default() -> &'a Type_FunctionType {
        <Type_FunctionType as ::protobuf::Message>::default_instance()
    }
}

impl Type_FunctionType {
    pub fn new() -> Type_FunctionType {
        ::std::default::Default::default()
    }

    // .google.api.expr.v1alpha1.Type result_type = 1;


    pub fn get_result_type(&self) -> &Type {
        self.result_type.as_ref().unwrap_or_else(|| <Type as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result_type(&mut self) {
        self.result_type.clear();
    }

    pub fn has_result_type(&self) -> bool {
        self.result_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_type(&mut self, v: Type) {
        self.result_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_type(&mut self) -> &mut Type {
        if self.result_type.is_none() {
            self.result_type.set_default();
        }
        self.result_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_type(&mut self) -> Type {
        self.result_type.take().unwrap_or_else(|| Type::new())
    }

    // repeated .google.api.expr.v1alpha1.Type arg_types = 2;


    pub fn get_arg_types(&self) -> &[Type] {
        &self.arg_types
    }
    pub fn clear_arg_types(&mut self) {
        self.arg_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_arg_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.arg_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arg_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.arg_types
    }

    // Take field
    pub fn take_arg_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.arg_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Type_FunctionType {
    fn is_initialized(&self) -> bool {
        for v in &self.result_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arg_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result_type)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arg_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.result_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arg_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.result_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arg_types {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_FunctionType {
        Type_FunctionType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "result_type",
                |m: &Type_FunctionType| { &m.result_type },
                |m: &mut Type_FunctionType| { &mut m.result_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "arg_types",
                |m: &Type_FunctionType| { &m.arg_types },
                |m: &mut Type_FunctionType| { &mut m.arg_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type_FunctionType>(
                "Type.FunctionType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type_FunctionType {
        static instance: ::protobuf::rt::LazyV2<Type_FunctionType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type_FunctionType::new)
    }
}

impl ::protobuf::Clear for Type_FunctionType {
    fn clear(&mut self) {
        self.result_type.clear();
        self.arg_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_FunctionType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_FunctionType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Type_AbstractType {
    // message fields
    pub name: ::std::string::String,
    pub parameter_types: ::protobuf::RepeatedField<Type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type_AbstractType {
    fn default() -> &'a Type_AbstractType {
        <Type_AbstractType as ::protobuf::Message>::default_instance()
    }
}

impl Type_AbstractType {
    pub fn new() -> Type_AbstractType {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.api.expr.v1alpha1.Type parameter_types = 2;


    pub fn get_parameter_types(&self) -> &[Type] {
        &self.parameter_types
    }
    pub fn clear_parameter_types(&mut self) {
        self.parameter_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter_types(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.parameter_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter_types(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.parameter_types
    }

    // Take field
    pub fn take_parameter_types(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.parameter_types, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Type_AbstractType {
    fn is_initialized(&self) -> bool {
        for v in &self.parameter_types {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameter_types)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.parameter_types {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.parameter_types {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type_AbstractType {
        Type_AbstractType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Type_AbstractType| { &m.name },
                |m: &mut Type_AbstractType| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "parameter_types",
                |m: &Type_AbstractType| { &m.parameter_types },
                |m: &mut Type_AbstractType| { &mut m.parameter_types },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Type_AbstractType>(
                "Type.AbstractType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type_AbstractType {
        static instance: ::protobuf::rt::LazyV2<Type_AbstractType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Type_AbstractType::new)
    }
}

impl ::protobuf::Clear for Type_AbstractType {
    fn clear(&mut self) {
        self.name.clear();
        self.parameter_types.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type_AbstractType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_AbstractType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type_PrimitiveType {
    PRIMITIVE_TYPE_UNSPECIFIED = 0,
    BOOL = 1,
    INT64 = 2,
    UINT64 = 3,
    DOUBLE = 4,
    STRING = 5,
    BYTES = 6,
}

impl ::protobuf::ProtobufEnum for Type_PrimitiveType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type_PrimitiveType> {
        match value {
            0 => ::std::option::Option::Some(Type_PrimitiveType::PRIMITIVE_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Type_PrimitiveType::BOOL),
            2 => ::std::option::Option::Some(Type_PrimitiveType::INT64),
            3 => ::std::option::Option::Some(Type_PrimitiveType::UINT64),
            4 => ::std::option::Option::Some(Type_PrimitiveType::DOUBLE),
            5 => ::std::option::Option::Some(Type_PrimitiveType::STRING),
            6 => ::std::option::Option::Some(Type_PrimitiveType::BYTES),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type_PrimitiveType] = &[
            Type_PrimitiveType::PRIMITIVE_TYPE_UNSPECIFIED,
            Type_PrimitiveType::BOOL,
            Type_PrimitiveType::INT64,
            Type_PrimitiveType::UINT64,
            Type_PrimitiveType::DOUBLE,
            Type_PrimitiveType::STRING,
            Type_PrimitiveType::BYTES,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Type_PrimitiveType>("Type.PrimitiveType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Type_PrimitiveType {
}

impl ::std::default::Default for Type_PrimitiveType {
    fn default() -> Self {
        Type_PrimitiveType::PRIMITIVE_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_PrimitiveType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Type_WellKnownType {
    WELL_KNOWN_TYPE_UNSPECIFIED = 0,
    ANY = 1,
    TIMESTAMP = 2,
    DURATION = 3,
}

impl ::protobuf::ProtobufEnum for Type_WellKnownType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Type_WellKnownType> {
        match value {
            0 => ::std::option::Option::Some(Type_WellKnownType::WELL_KNOWN_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Type_WellKnownType::ANY),
            2 => ::std::option::Option::Some(Type_WellKnownType::TIMESTAMP),
            3 => ::std::option::Option::Some(Type_WellKnownType::DURATION),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Type_WellKnownType] = &[
            Type_WellKnownType::WELL_KNOWN_TYPE_UNSPECIFIED,
            Type_WellKnownType::ANY,
            Type_WellKnownType::TIMESTAMP,
            Type_WellKnownType::DURATION,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Type_WellKnownType>("Type.WellKnownType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Type_WellKnownType {
}

impl ::std::default::Default for Type_WellKnownType {
    fn default() -> Self {
        Type_WellKnownType::WELL_KNOWN_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Type_WellKnownType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Decl {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub decl_kind: ::std::option::Option<Decl_oneof_decl_kind>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Decl {
    fn default() -> &'a Decl {
        <Decl as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Decl_oneof_decl_kind {
    ident(Decl_IdentDecl),
    function(Decl_FunctionDecl),
}

impl Decl {
    pub fn new() -> Decl {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.api.expr.v1alpha1.Decl.IdentDecl ident = 2;


    pub fn get_ident(&self) -> &Decl_IdentDecl {
        match self.decl_kind {
            ::std::option::Option::Some(Decl_oneof_decl_kind::ident(ref v)) => v,
            _ => <Decl_IdentDecl as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ident(&mut self) {
        self.decl_kind = ::std::option::Option::None;
    }

    pub fn has_ident(&self) -> bool {
        match self.decl_kind {
            ::std::option::Option::Some(Decl_oneof_decl_kind::ident(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ident(&mut self, v: Decl_IdentDecl) {
        self.decl_kind = ::std::option::Option::Some(Decl_oneof_decl_kind::ident(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ident(&mut self) -> &mut Decl_IdentDecl {
        if let ::std::option::Option::Some(Decl_oneof_decl_kind::ident(_)) = self.decl_kind {
        } else {
            self.decl_kind = ::std::option::Option::Some(Decl_oneof_decl_kind::ident(Decl_IdentDecl::new()));
        }
        match self.decl_kind {
            ::std::option::Option::Some(Decl_oneof_decl_kind::ident(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ident(&mut self) -> Decl_IdentDecl {
        if self.has_ident() {
            match self.decl_kind.take() {
                ::std::option::Option::Some(Decl_oneof_decl_kind::ident(v)) => v,
                _ => panic!(),
            }
        } else {
            Decl_IdentDecl::new()
        }
    }

    // .google.api.expr.v1alpha1.Decl.FunctionDecl function = 3;


    pub fn get_function(&self) -> &Decl_FunctionDecl {
        match self.decl_kind {
            ::std::option::Option::Some(Decl_oneof_decl_kind::function(ref v)) => v,
            _ => <Decl_FunctionDecl as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_function(&mut self) {
        self.decl_kind = ::std::option::Option::None;
    }

    pub fn has_function(&self) -> bool {
        match self.decl_kind {
            ::std::option::Option::Some(Decl_oneof_decl_kind::function(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: Decl_FunctionDecl) {
        self.decl_kind = ::std::option::Option::Some(Decl_oneof_decl_kind::function(v))
    }

    // Mutable pointer to the field.
    pub fn mut_function(&mut self) -> &mut Decl_FunctionDecl {
        if let ::std::option::Option::Some(Decl_oneof_decl_kind::function(_)) = self.decl_kind {
        } else {
            self.decl_kind = ::std::option::Option::Some(Decl_oneof_decl_kind::function(Decl_FunctionDecl::new()));
        }
        match self.decl_kind {
            ::std::option::Option::Some(Decl_oneof_decl_kind::function(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_function(&mut self) -> Decl_FunctionDecl {
        if self.has_function() {
            match self.decl_kind.take() {
                ::std::option::Option::Some(Decl_oneof_decl_kind::function(v)) => v,
                _ => panic!(),
            }
        } else {
            Decl_FunctionDecl::new()
        }
    }
}

impl ::protobuf::Message for Decl {
    fn is_initialized(&self) -> bool {
        if let Some(Decl_oneof_decl_kind::ident(ref v)) = self.decl_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Decl_oneof_decl_kind::function(ref v)) = self.decl_kind {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.decl_kind = ::std::option::Option::Some(Decl_oneof_decl_kind::ident(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.decl_kind = ::std::option::Option::Some(Decl_oneof_decl_kind::function(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.decl_kind {
            match v {
                &Decl_oneof_decl_kind::ident(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Decl_oneof_decl_kind::function(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.decl_kind {
            match v {
                &Decl_oneof_decl_kind::ident(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Decl_oneof_decl_kind::function(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decl {
        Decl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Decl| { &m.name },
                |m: &mut Decl| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Decl_IdentDecl>(
                "ident",
                Decl::has_ident,
                Decl::get_ident,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Decl_FunctionDecl>(
                "function",
                Decl::has_function,
                Decl::get_function,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Decl>(
                "Decl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Decl {
        static instance: ::protobuf::rt::LazyV2<Decl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Decl::new)
    }
}

impl ::protobuf::Clear for Decl {
    fn clear(&mut self) {
        self.name.clear();
        self.decl_kind = ::std::option::Option::None;
        self.decl_kind = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Decl_IdentDecl {
    // message fields
    pub field_type: ::protobuf::SingularPtrField<Type>,
    pub value: ::protobuf::SingularPtrField<super::syntax::Constant>,
    pub doc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Decl_IdentDecl {
    fn default() -> &'a Decl_IdentDecl {
        <Decl_IdentDecl as ::protobuf::Message>::default_instance()
    }
}

impl Decl_IdentDecl {
    pub fn new() -> Decl_IdentDecl {
        ::std::default::Default::default()
    }

    // .google.api.expr.v1alpha1.Type type = 1;


    pub fn get_field_type(&self) -> &Type {
        self.field_type.as_ref().unwrap_or_else(|| <Type as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Type) {
        self.field_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut Type {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> Type {
        self.field_type.take().unwrap_or_else(|| Type::new())
    }

    // .google.api.expr.v1alpha1.Constant value = 2;


    pub fn get_value(&self) -> &super::syntax::Constant {
        self.value.as_ref().unwrap_or_else(|| <super::syntax::Constant as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::syntax::Constant) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut super::syntax::Constant {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> super::syntax::Constant {
        self.value.take().unwrap_or_else(|| super::syntax::Constant::new())
    }

    // string doc = 3;


    pub fn get_doc(&self) -> &str {
        &self.doc
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: ::std::string::String) {
        self.doc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut ::std::string::String {
        &mut self.doc
    }

    // Take field
    pub fn take_doc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Decl_IdentDecl {
    fn is_initialized(&self) -> bool {
        for v in &self.field_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.doc.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.doc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.doc.is_empty() {
            os.write_string(3, &self.doc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decl_IdentDecl {
        Decl_IdentDecl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "type",
                |m: &Decl_IdentDecl| { &m.field_type },
                |m: &mut Decl_IdentDecl| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::syntax::Constant>>(
                "value",
                |m: &Decl_IdentDecl| { &m.value },
                |m: &mut Decl_IdentDecl| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "doc",
                |m: &Decl_IdentDecl| { &m.doc },
                |m: &mut Decl_IdentDecl| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Decl_IdentDecl>(
                "Decl.IdentDecl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Decl_IdentDecl {
        static instance: ::protobuf::rt::LazyV2<Decl_IdentDecl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Decl_IdentDecl::new)
    }
}

impl ::protobuf::Clear for Decl_IdentDecl {
    fn clear(&mut self) {
        self.field_type.clear();
        self.value.clear();
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decl_IdentDecl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decl_IdentDecl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Decl_FunctionDecl {
    // message fields
    pub overloads: ::protobuf::RepeatedField<Decl_FunctionDecl_Overload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Decl_FunctionDecl {
    fn default() -> &'a Decl_FunctionDecl {
        <Decl_FunctionDecl as ::protobuf::Message>::default_instance()
    }
}

impl Decl_FunctionDecl {
    pub fn new() -> Decl_FunctionDecl {
        ::std::default::Default::default()
    }

    // repeated .google.api.expr.v1alpha1.Decl.FunctionDecl.Overload overloads = 1;


    pub fn get_overloads(&self) -> &[Decl_FunctionDecl_Overload] {
        &self.overloads
    }
    pub fn clear_overloads(&mut self) {
        self.overloads.clear();
    }

    // Param is passed by value, moved
    pub fn set_overloads(&mut self, v: ::protobuf::RepeatedField<Decl_FunctionDecl_Overload>) {
        self.overloads = v;
    }

    // Mutable pointer to the field.
    pub fn mut_overloads(&mut self) -> &mut ::protobuf::RepeatedField<Decl_FunctionDecl_Overload> {
        &mut self.overloads
    }

    // Take field
    pub fn take_overloads(&mut self) -> ::protobuf::RepeatedField<Decl_FunctionDecl_Overload> {
        ::std::mem::replace(&mut self.overloads, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Decl_FunctionDecl {
    fn is_initialized(&self) -> bool {
        for v in &self.overloads {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.overloads)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.overloads {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.overloads {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decl_FunctionDecl {
        Decl_FunctionDecl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decl_FunctionDecl_Overload>>(
                "overloads",
                |m: &Decl_FunctionDecl| { &m.overloads },
                |m: &mut Decl_FunctionDecl| { &mut m.overloads },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Decl_FunctionDecl>(
                "Decl.FunctionDecl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Decl_FunctionDecl {
        static instance: ::protobuf::rt::LazyV2<Decl_FunctionDecl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Decl_FunctionDecl::new)
    }
}

impl ::protobuf::Clear for Decl_FunctionDecl {
    fn clear(&mut self) {
        self.overloads.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decl_FunctionDecl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decl_FunctionDecl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Decl_FunctionDecl_Overload {
    // message fields
    pub overload_id: ::std::string::String,
    pub params: ::protobuf::RepeatedField<Type>,
    pub type_params: ::protobuf::RepeatedField<::std::string::String>,
    pub result_type: ::protobuf::SingularPtrField<Type>,
    pub is_instance_function: bool,
    pub doc: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Decl_FunctionDecl_Overload {
    fn default() -> &'a Decl_FunctionDecl_Overload {
        <Decl_FunctionDecl_Overload as ::protobuf::Message>::default_instance()
    }
}

impl Decl_FunctionDecl_Overload {
    pub fn new() -> Decl_FunctionDecl_Overload {
        ::std::default::Default::default()
    }

    // string overload_id = 1;


    pub fn get_overload_id(&self) -> &str {
        &self.overload_id
    }
    pub fn clear_overload_id(&mut self) {
        self.overload_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_overload_id(&mut self, v: ::std::string::String) {
        self.overload_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overload_id(&mut self) -> &mut ::std::string::String {
        &mut self.overload_id
    }

    // Take field
    pub fn take_overload_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.overload_id, ::std::string::String::new())
    }

    // repeated .google.api.expr.v1alpha1.Type params = 2;


    pub fn get_params(&self) -> &[Type] {
        &self.params
    }
    pub fn clear_params(&mut self) {
        self.params.clear();
    }

    // Param is passed by value, moved
    pub fn set_params(&mut self, v: ::protobuf::RepeatedField<Type>) {
        self.params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_params(&mut self) -> &mut ::protobuf::RepeatedField<Type> {
        &mut self.params
    }

    // Take field
    pub fn take_params(&mut self) -> ::protobuf::RepeatedField<Type> {
        ::std::mem::replace(&mut self.params, ::protobuf::RepeatedField::new())
    }

    // repeated string type_params = 3;


    pub fn get_type_params(&self) -> &[::std::string::String] {
        &self.type_params
    }
    pub fn clear_type_params(&mut self) {
        self.type_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.type_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_type_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.type_params
    }

    // Take field
    pub fn take_type_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.type_params, ::protobuf::RepeatedField::new())
    }

    // .google.api.expr.v1alpha1.Type result_type = 4;


    pub fn get_result_type(&self) -> &Type {
        self.result_type.as_ref().unwrap_or_else(|| <Type as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result_type(&mut self) {
        self.result_type.clear();
    }

    pub fn has_result_type(&self) -> bool {
        self.result_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_type(&mut self, v: Type) {
        self.result_type = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_type(&mut self) -> &mut Type {
        if self.result_type.is_none() {
            self.result_type.set_default();
        }
        self.result_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_type(&mut self) -> Type {
        self.result_type.take().unwrap_or_else(|| Type::new())
    }

    // bool is_instance_function = 5;


    pub fn get_is_instance_function(&self) -> bool {
        self.is_instance_function
    }
    pub fn clear_is_instance_function(&mut self) {
        self.is_instance_function = false;
    }

    // Param is passed by value, moved
    pub fn set_is_instance_function(&mut self, v: bool) {
        self.is_instance_function = v;
    }

    // string doc = 6;


    pub fn get_doc(&self) -> &str {
        &self.doc
    }
    pub fn clear_doc(&mut self) {
        self.doc.clear();
    }

    // Param is passed by value, moved
    pub fn set_doc(&mut self, v: ::std::string::String) {
        self.doc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_doc(&mut self) -> &mut ::std::string::String {
        &mut self.doc
    }

    // Take field
    pub fn take_doc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.doc, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Decl_FunctionDecl_Overload {
    fn is_initialized(&self) -> bool {
        for v in &self.params {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result_type {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.overload_id)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.params)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.type_params)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result_type)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_instance_function = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.doc)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.overload_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.overload_id);
        }
        for value in &self.params {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.type_params {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.result_type.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_instance_function != false {
            my_size += 2;
        }
        if !self.doc.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.doc);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.overload_id.is_empty() {
            os.write_string(1, &self.overload_id)?;
        }
        for v in &self.params {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.type_params {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.result_type.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_instance_function != false {
            os.write_bool(5, self.is_instance_function)?;
        }
        if !self.doc.is_empty() {
            os.write_string(6, &self.doc)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decl_FunctionDecl_Overload {
        Decl_FunctionDecl_Overload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "overload_id",
                |m: &Decl_FunctionDecl_Overload| { &m.overload_id },
                |m: &mut Decl_FunctionDecl_Overload| { &mut m.overload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "params",
                |m: &Decl_FunctionDecl_Overload| { &m.params },
                |m: &mut Decl_FunctionDecl_Overload| { &mut m.params },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type_params",
                |m: &Decl_FunctionDecl_Overload| { &m.type_params },
                |m: &mut Decl_FunctionDecl_Overload| { &mut m.type_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Type>>(
                "result_type",
                |m: &Decl_FunctionDecl_Overload| { &m.result_type },
                |m: &mut Decl_FunctionDecl_Overload| { &mut m.result_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_instance_function",
                |m: &Decl_FunctionDecl_Overload| { &m.is_instance_function },
                |m: &mut Decl_FunctionDecl_Overload| { &mut m.is_instance_function },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "doc",
                |m: &Decl_FunctionDecl_Overload| { &m.doc },
                |m: &mut Decl_FunctionDecl_Overload| { &mut m.doc },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Decl_FunctionDecl_Overload>(
                "Decl.FunctionDecl.Overload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Decl_FunctionDecl_Overload {
        static instance: ::protobuf::rt::LazyV2<Decl_FunctionDecl_Overload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Decl_FunctionDecl_Overload::new)
    }
}

impl ::protobuf::Clear for Decl_FunctionDecl_Overload {
    fn clear(&mut self) {
        self.overload_id.clear();
        self.params.clear();
        self.type_params.clear();
        self.result_type.clear();
        self.is_instance_function = false;
        self.doc.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decl_FunctionDecl_Overload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decl_FunctionDecl_Overload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Reference {
    // message fields
    pub name: ::std::string::String,
    pub overload_id: ::protobuf::RepeatedField<::std::string::String>,
    pub value: ::protobuf::SingularPtrField<super::syntax::Constant>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Reference {
    fn default() -> &'a Reference {
        <Reference as ::protobuf::Message>::default_instance()
    }
}

impl Reference {
    pub fn new() -> Reference {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string overload_id = 3;


    pub fn get_overload_id(&self) -> &[::std::string::String] {
        &self.overload_id
    }
    pub fn clear_overload_id(&mut self) {
        self.overload_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_overload_id(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.overload_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_overload_id(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.overload_id
    }

    // Take field
    pub fn take_overload_id(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.overload_id, ::protobuf::RepeatedField::new())
    }

    // .google.api.expr.v1alpha1.Constant value = 4;


    pub fn get_value(&self) -> &super::syntax::Constant {
        self.value.as_ref().unwrap_or_else(|| <super::syntax::Constant as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::syntax::Constant) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut super::syntax::Constant {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> super::syntax::Constant {
        self.value.take().unwrap_or_else(|| super::syntax::Constant::new())
    }
}

impl ::protobuf::Message for Reference {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.overload_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.overload_id {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.overload_id {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Reference {
        Reference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Reference| { &m.name },
                |m: &mut Reference| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "overload_id",
                |m: &Reference| { &m.overload_id },
                |m: &mut Reference| { &mut m.overload_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::syntax::Constant>>(
                "value",
                |m: &Reference| { &m.value },
                |m: &mut Reference| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Reference>(
                "Reference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Reference {
        static instance: ::protobuf::rt::LazyV2<Reference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Reference::new)
    }
}

impl ::protobuf::Clear for Reference {
    fn clear(&mut self) {
        self.name.clear();
        self.overload_id.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Reference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Reference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&google/api/expr/v1alpha1/checked.proto\x12\x18google.api.expr.v1alpha\
    1\x1a%google/api/expr/v1alpha1/syntax.proto\x1a\x1bgoogle/protobuf/empty\
    .proto\x1a\x1cgoogle/protobuf/struct.proto\"\xf7\x03\n\x0bCheckedExpr\
    \x12\\\n\rreference_map\x18\x02\x20\x03(\x0b27.google.api.expr.v1alpha1.\
    CheckedExpr.ReferenceMapEntryR\x0creferenceMap\x12M\n\x08type_map\x18\
    \x03\x20\x03(\x0b22.google.api.expr.v1alpha1.CheckedExpr.TypeMapEntryR\
    \x07typeMap\x12E\n\x0bsource_info\x18\x05\x20\x01(\x0b2$.google.api.expr\
    .v1alpha1.SourceInfoR\nsourceInfo\x122\n\x04expr\x18\x04\x20\x01(\x0b2\
    \x1e.google.api.expr.v1alpha1.ExprR\x04expr\x1ad\n\x11ReferenceMapEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x129\n\x05value\x18\x02\
    \x20\x01(\x0b2#.google.api.expr.v1alpha1.ReferenceR\x05value:\x028\x01\
    \x1aZ\n\x0cTypeMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\
    \x124\n\x05value\x18\x02\x20\x01(\x0b2\x1e.google.api.expr.v1alpha1.Type\
    R\x05value:\x028\x01\"\xc8\x0b\n\x04Type\x12*\n\x03dyn\x18\x01\x20\x01(\
    \x0b2\x16.google.protobuf.EmptyH\0R\x03dyn\x120\n\x04null\x18\x02\x20\
    \x01(\x0e2\x1a.google.protobuf.NullValueH\0R\x04null\x12L\n\tprimitive\
    \x18\x03\x20\x01(\x0e2,.google.api.expr.v1alpha1.Type.PrimitiveTypeH\0R\
    \tprimitive\x12H\n\x07wrapper\x18\x04\x20\x01(\x0e2,.google.api.expr.v1a\
    lpha1.Type.PrimitiveTypeH\0R\x07wrapper\x12M\n\nwell_known\x18\x05\x20\
    \x01(\x0e2,.google.api.expr.v1alpha1.Type.WellKnownTypeH\0R\twellKnown\
    \x12F\n\tlist_type\x18\x06\x20\x01(\x0b2'.google.api.expr.v1alpha1.Type.\
    ListTypeH\0R\x08listType\x12C\n\x08map_type\x18\x07\x20\x01(\x0b2&.googl\
    e.api.expr.v1alpha1.Type.MapTypeH\0R\x07mapType\x12I\n\x08function\x18\
    \x08\x20\x01(\x0b2+.google.api.expr.v1alpha1.Type.FunctionTypeH\0R\x08fu\
    nction\x12#\n\x0cmessage_type\x18\t\x20\x01(\tH\0R\x0bmessageType\x12\
    \x1f\n\ntype_param\x18\n\x20\x01(\tH\0R\ttypeParam\x124\n\x04type\x18\
    \x0b\x20\x01(\x0b2\x1e.google.api.expr.v1alpha1.TypeH\0R\x04type\x12.\n\
    \x05error\x18\x0c\x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x05error\
    \x12R\n\rabstract_type\x18\x0e\x20\x01(\x0b2+.google.api.expr.v1alpha1.T\
    ype.AbstractTypeH\0R\x0cabstractType\x1aG\n\x08ListType\x12;\n\telem_typ\
    e\x18\x01\x20\x01(\x0b2\x1e.google.api.expr.v1alpha1.TypeR\x08elemType\
    \x1a\x83\x01\n\x07MapType\x129\n\x08key_type\x18\x01\x20\x01(\x0b2\x1e.g\
    oogle.api.expr.v1alpha1.TypeR\x07keyType\x12=\n\nvalue_type\x18\x02\x20\
    \x01(\x0b2\x1e.google.api.expr.v1alpha1.TypeR\tvalueType\x1a\x8c\x01\n\
    \x0cFunctionType\x12?\n\x0bresult_type\x18\x01\x20\x01(\x0b2\x1e.google.\
    api.expr.v1alpha1.TypeR\nresultType\x12;\n\targ_types\x18\x02\x20\x03(\
    \x0b2\x1e.google.api.expr.v1alpha1.TypeR\x08argTypes\x1ak\n\x0cAbstractT\
    ype\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12G\n\x0fparameter_ty\
    pes\x18\x02\x20\x03(\x0b2\x1e.google.api.expr.v1alpha1.TypeR\x0eparamete\
    rTypes\"s\n\rPrimitiveType\x12\x1e\n\x1aPRIMITIVE_TYPE_UNSPECIFIED\x10\0\
    \x12\x08\n\x04BOOL\x10\x01\x12\t\n\x05INT64\x10\x02\x12\n\n\x06UINT64\
    \x10\x03\x12\n\n\x06DOUBLE\x10\x04\x12\n\n\x06STRING\x10\x05\x12\t\n\x05\
    BYTES\x10\x06\"V\n\rWellKnownType\x12\x1f\n\x1bWELL_KNOWN_TYPE_UNSPECIFI\
    ED\x10\0\x12\x07\n\x03ANY\x10\x01\x12\r\n\tTIMESTAMP\x10\x02\x12\x0c\n\
    \x08DURATION\x10\x03B\x0b\n\ttype_kind\"\xb3\x05\n\x04Decl\x12\x12\n\x04\
    name\x18\x01\x20\x01(\tR\x04name\x12@\n\x05ident\x18\x02\x20\x01(\x0b2(.\
    google.api.expr.v1alpha1.Decl.IdentDeclH\0R\x05ident\x12I\n\x08function\
    \x18\x03\x20\x01(\x0b2+.google.api.expr.v1alpha1.Decl.FunctionDeclH\0R\
    \x08function\x1a\x8b\x01\n\tIdentDecl\x122\n\x04type\x18\x01\x20\x01(\
    \x0b2\x1e.google.api.expr.v1alpha1.TypeR\x04type\x128\n\x05value\x18\x02\
    \x20\x01(\x0b2\".google.api.expr.v1alpha1.ConstantR\x05value\x12\x10\n\
    \x03doc\x18\x03\x20\x01(\tR\x03doc\x1a\xee\x02\n\x0cFunctionDecl\x12R\n\
    \toverloads\x18\x01\x20\x03(\x0b24.google.api.expr.v1alpha1.Decl.Functio\
    nDecl.OverloadR\toverloads\x1a\x89\x02\n\x08Overload\x12\x1f\n\x0boverlo\
    ad_id\x18\x01\x20\x01(\tR\noverloadId\x126\n\x06params\x18\x02\x20\x03(\
    \x0b2\x1e.google.api.expr.v1alpha1.TypeR\x06params\x12\x1f\n\x0btype_par\
    ams\x18\x03\x20\x03(\tR\ntypeParams\x12?\n\x0bresult_type\x18\x04\x20\
    \x01(\x0b2\x1e.google.api.expr.v1alpha1.TypeR\nresultType\x120\n\x14is_i\
    nstance_function\x18\x05\x20\x01(\x08R\x12isInstanceFunction\x12\x10\n\
    \x03doc\x18\x06\x20\x01(\tR\x03docB\x0b\n\tdecl_kind\"z\n\tReference\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1f\n\x0boverload_id\x18\
    \x03\x20\x03(\tR\noverloadId\x128\n\x05value\x18\x04\x20\x01(\x0b2\".goo\
    gle.api.expr.v1alpha1.ConstantR\x05valueBl\n\x1ccom.google.api.expr.v1al\
    pha1B\tDeclProtoP\x01Z<google.golang.org/genproto/googleapis/api/expr/v1\
    alpha1;expr\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
