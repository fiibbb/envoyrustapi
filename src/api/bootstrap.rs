// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/bootstrap/v4alpha/bootstrap.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct Bootstrap {
    // message fields
    pub node: ::protobuf::SingularPtrField<super::base::Node>,
    pub node_context_params: ::protobuf::RepeatedField<::std::string::String>,
    pub static_resources: ::protobuf::SingularPtrField<Bootstrap_StaticResources>,
    pub dynamic_resources: ::protobuf::SingularPtrField<Bootstrap_DynamicResources>,
    pub cluster_manager: ::protobuf::SingularPtrField<ClusterManager>,
    pub hds_config: ::protobuf::SingularPtrField<super::config_source::ApiConfigSource>,
    pub flags_path: ::std::string::String,
    pub stats_sinks: ::protobuf::RepeatedField<super::stats::StatsSink>,
    pub stats_config: ::protobuf::SingularPtrField<super::stats::StatsConfig>,
    pub stats_flush_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub watchdogs: ::protobuf::SingularPtrField<Watchdogs>,
    pub layered_runtime: ::protobuf::SingularPtrField<LayeredRuntime>,
    pub admin: ::protobuf::SingularPtrField<Admin>,
    pub overload_manager: ::protobuf::SingularPtrField<super::overload::OverloadManager>,
    pub enable_dispatcher_stats: bool,
    pub header_prefix: ::std::string::String,
    pub stats_server_version_override: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt64Value>,
    pub use_tcp_for_dns_lookups: bool,
    pub bootstrap_extensions: ::protobuf::RepeatedField<super::extension::TypedExtensionConfig>,
    pub fatal_actions: ::protobuf::RepeatedField<FatalAction>,
    pub config_sources: ::protobuf::RepeatedField<super::config_source::ConfigSource>,
    pub default_config_source: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    pub default_socket_interface: ::std::string::String,
    pub certificate_provider_instances: ::std::collections::HashMap<::std::string::String, super::extension::TypedExtensionConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bootstrap {
    fn default() -> &'a Bootstrap {
        <Bootstrap as ::protobuf::Message>::default_instance()
    }
}

impl Bootstrap {
    pub fn new() -> Bootstrap {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v4alpha.Node node = 1;


    pub fn get_node(&self) -> &super::base::Node {
        self.node.as_ref().unwrap_or_else(|| <super::base::Node as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: super::base::Node) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut super::base::Node {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> super::base::Node {
        self.node.take().unwrap_or_else(|| super::base::Node::new())
    }

    // repeated string node_context_params = 26;


    pub fn get_node_context_params(&self) -> &[::std::string::String] {
        &self.node_context_params
    }
    pub fn clear_node_context_params(&mut self) {
        self.node_context_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_context_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.node_context_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_context_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.node_context_params
    }

    // Take field
    pub fn take_node_context_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.node_context_params, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.bootstrap.v4alpha.Bootstrap.StaticResources static_resources = 2;


    pub fn get_static_resources(&self) -> &Bootstrap_StaticResources {
        self.static_resources.as_ref().unwrap_or_else(|| <Bootstrap_StaticResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_static_resources(&mut self) {
        self.static_resources.clear();
    }

    pub fn has_static_resources(&self) -> bool {
        self.static_resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static_resources(&mut self, v: Bootstrap_StaticResources) {
        self.static_resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static_resources(&mut self) -> &mut Bootstrap_StaticResources {
        if self.static_resources.is_none() {
            self.static_resources.set_default();
        }
        self.static_resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_resources(&mut self) -> Bootstrap_StaticResources {
        self.static_resources.take().unwrap_or_else(|| Bootstrap_StaticResources::new())
    }

    // .envoy.config.bootstrap.v4alpha.Bootstrap.DynamicResources dynamic_resources = 3;


    pub fn get_dynamic_resources(&self) -> &Bootstrap_DynamicResources {
        self.dynamic_resources.as_ref().unwrap_or_else(|| <Bootstrap_DynamicResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dynamic_resources(&mut self) {
        self.dynamic_resources.clear();
    }

    pub fn has_dynamic_resources(&self) -> bool {
        self.dynamic_resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_resources(&mut self, v: Bootstrap_DynamicResources) {
        self.dynamic_resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_resources(&mut self) -> &mut Bootstrap_DynamicResources {
        if self.dynamic_resources.is_none() {
            self.dynamic_resources.set_default();
        }
        self.dynamic_resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_resources(&mut self) -> Bootstrap_DynamicResources {
        self.dynamic_resources.take().unwrap_or_else(|| Bootstrap_DynamicResources::new())
    }

    // .envoy.config.bootstrap.v4alpha.ClusterManager cluster_manager = 4;


    pub fn get_cluster_manager(&self) -> &ClusterManager {
        self.cluster_manager.as_ref().unwrap_or_else(|| <ClusterManager as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster_manager(&mut self) {
        self.cluster_manager.clear();
    }

    pub fn has_cluster_manager(&self) -> bool {
        self.cluster_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_manager(&mut self, v: ClusterManager) {
        self.cluster_manager = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_manager(&mut self) -> &mut ClusterManager {
        if self.cluster_manager.is_none() {
            self.cluster_manager.set_default();
        }
        self.cluster_manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster_manager(&mut self) -> ClusterManager {
        self.cluster_manager.take().unwrap_or_else(|| ClusterManager::new())
    }

    // .envoy.config.core.v4alpha.ApiConfigSource hds_config = 14;


    pub fn get_hds_config(&self) -> &super::config_source::ApiConfigSource {
        self.hds_config.as_ref().unwrap_or_else(|| <super::config_source::ApiConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hds_config(&mut self) {
        self.hds_config.clear();
    }

    pub fn has_hds_config(&self) -> bool {
        self.hds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hds_config(&mut self, v: super::config_source::ApiConfigSource) {
        self.hds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hds_config(&mut self) -> &mut super::config_source::ApiConfigSource {
        if self.hds_config.is_none() {
            self.hds_config.set_default();
        }
        self.hds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_hds_config(&mut self) -> super::config_source::ApiConfigSource {
        self.hds_config.take().unwrap_or_else(|| super::config_source::ApiConfigSource::new())
    }

    // string flags_path = 5;


    pub fn get_flags_path(&self) -> &str {
        &self.flags_path
    }
    pub fn clear_flags_path(&mut self) {
        self.flags_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags_path(&mut self, v: ::std::string::String) {
        self.flags_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags_path(&mut self) -> &mut ::std::string::String {
        &mut self.flags_path
    }

    // Take field
    pub fn take_flags_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.flags_path, ::std::string::String::new())
    }

    // repeated .envoy.config.metrics.v4alpha.StatsSink stats_sinks = 6;


    pub fn get_stats_sinks(&self) -> &[super::stats::StatsSink] {
        &self.stats_sinks
    }
    pub fn clear_stats_sinks(&mut self) {
        self.stats_sinks.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_sinks(&mut self, v: ::protobuf::RepeatedField<super::stats::StatsSink>) {
        self.stats_sinks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_sinks(&mut self) -> &mut ::protobuf::RepeatedField<super::stats::StatsSink> {
        &mut self.stats_sinks
    }

    // Take field
    pub fn take_stats_sinks(&mut self) -> ::protobuf::RepeatedField<super::stats::StatsSink> {
        ::std::mem::replace(&mut self.stats_sinks, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.metrics.v4alpha.StatsConfig stats_config = 13;


    pub fn get_stats_config(&self) -> &super::stats::StatsConfig {
        self.stats_config.as_ref().unwrap_or_else(|| <super::stats::StatsConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_config(&mut self) {
        self.stats_config.clear();
    }

    pub fn has_stats_config(&self) -> bool {
        self.stats_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_config(&mut self, v: super::stats::StatsConfig) {
        self.stats_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_config(&mut self) -> &mut super::stats::StatsConfig {
        if self.stats_config.is_none() {
            self.stats_config.set_default();
        }
        self.stats_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_config(&mut self) -> super::stats::StatsConfig {
        self.stats_config.take().unwrap_or_else(|| super::stats::StatsConfig::new())
    }

    // .google.protobuf.Duration stats_flush_interval = 7;


    pub fn get_stats_flush_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.stats_flush_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_flush_interval(&mut self) {
        self.stats_flush_interval.clear();
    }

    pub fn has_stats_flush_interval(&self) -> bool {
        self.stats_flush_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_flush_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.stats_flush_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_flush_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.stats_flush_interval.is_none() {
            self.stats_flush_interval.set_default();
        }
        self.stats_flush_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_flush_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.stats_flush_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.config.bootstrap.v4alpha.Watchdogs watchdogs = 27;


    pub fn get_watchdogs(&self) -> &Watchdogs {
        self.watchdogs.as_ref().unwrap_or_else(|| <Watchdogs as ::protobuf::Message>::default_instance())
    }
    pub fn clear_watchdogs(&mut self) {
        self.watchdogs.clear();
    }

    pub fn has_watchdogs(&self) -> bool {
        self.watchdogs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watchdogs(&mut self, v: Watchdogs) {
        self.watchdogs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watchdogs(&mut self) -> &mut Watchdogs {
        if self.watchdogs.is_none() {
            self.watchdogs.set_default();
        }
        self.watchdogs.as_mut().unwrap()
    }

    // Take field
    pub fn take_watchdogs(&mut self) -> Watchdogs {
        self.watchdogs.take().unwrap_or_else(|| Watchdogs::new())
    }

    // .envoy.config.bootstrap.v4alpha.LayeredRuntime layered_runtime = 17;


    pub fn get_layered_runtime(&self) -> &LayeredRuntime {
        self.layered_runtime.as_ref().unwrap_or_else(|| <LayeredRuntime as ::protobuf::Message>::default_instance())
    }
    pub fn clear_layered_runtime(&mut self) {
        self.layered_runtime.clear();
    }

    pub fn has_layered_runtime(&self) -> bool {
        self.layered_runtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layered_runtime(&mut self, v: LayeredRuntime) {
        self.layered_runtime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layered_runtime(&mut self) -> &mut LayeredRuntime {
        if self.layered_runtime.is_none() {
            self.layered_runtime.set_default();
        }
        self.layered_runtime.as_mut().unwrap()
    }

    // Take field
    pub fn take_layered_runtime(&mut self) -> LayeredRuntime {
        self.layered_runtime.take().unwrap_or_else(|| LayeredRuntime::new())
    }

    // .envoy.config.bootstrap.v4alpha.Admin admin = 12;


    pub fn get_admin(&self) -> &Admin {
        self.admin.as_ref().unwrap_or_else(|| <Admin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    pub fn has_admin(&self) -> bool {
        self.admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: Admin) {
        self.admin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut Admin {
        if self.admin.is_none() {
            self.admin.set_default();
        }
        self.admin.as_mut().unwrap()
    }

    // Take field
    pub fn take_admin(&mut self) -> Admin {
        self.admin.take().unwrap_or_else(|| Admin::new())
    }

    // .envoy.config.overload.v3.OverloadManager overload_manager = 15;


    pub fn get_overload_manager(&self) -> &super::overload::OverloadManager {
        self.overload_manager.as_ref().unwrap_or_else(|| <super::overload::OverloadManager as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overload_manager(&mut self) {
        self.overload_manager.clear();
    }

    pub fn has_overload_manager(&self) -> bool {
        self.overload_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overload_manager(&mut self, v: super::overload::OverloadManager) {
        self.overload_manager = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overload_manager(&mut self) -> &mut super::overload::OverloadManager {
        if self.overload_manager.is_none() {
            self.overload_manager.set_default();
        }
        self.overload_manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_overload_manager(&mut self) -> super::overload::OverloadManager {
        self.overload_manager.take().unwrap_or_else(|| super::overload::OverloadManager::new())
    }

    // bool enable_dispatcher_stats = 16;


    pub fn get_enable_dispatcher_stats(&self) -> bool {
        self.enable_dispatcher_stats
    }
    pub fn clear_enable_dispatcher_stats(&mut self) {
        self.enable_dispatcher_stats = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_dispatcher_stats(&mut self, v: bool) {
        self.enable_dispatcher_stats = v;
    }

    // string header_prefix = 18;


    pub fn get_header_prefix(&self) -> &str {
        &self.header_prefix
    }
    pub fn clear_header_prefix(&mut self) {
        self.header_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_prefix(&mut self, v: ::std::string::String) {
        self.header_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.header_prefix
    }

    // Take field
    pub fn take_header_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.header_prefix, ::std::string::String::new())
    }

    // .google.protobuf.UInt64Value stats_server_version_override = 19;


    pub fn get_stats_server_version_override(&self) -> &::protobuf::well_known_types::UInt64Value {
        self.stats_server_version_override.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_server_version_override(&mut self) {
        self.stats_server_version_override.clear();
    }

    pub fn has_stats_server_version_override(&self) -> bool {
        self.stats_server_version_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_server_version_override(&mut self, v: ::protobuf::well_known_types::UInt64Value) {
        self.stats_server_version_override = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_server_version_override(&mut self) -> &mut ::protobuf::well_known_types::UInt64Value {
        if self.stats_server_version_override.is_none() {
            self.stats_server_version_override.set_default();
        }
        self.stats_server_version_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_server_version_override(&mut self) -> ::protobuf::well_known_types::UInt64Value {
        self.stats_server_version_override.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt64Value::new())
    }

    // bool use_tcp_for_dns_lookups = 20;


    pub fn get_use_tcp_for_dns_lookups(&self) -> bool {
        self.use_tcp_for_dns_lookups
    }
    pub fn clear_use_tcp_for_dns_lookups(&mut self) {
        self.use_tcp_for_dns_lookups = false;
    }

    // Param is passed by value, moved
    pub fn set_use_tcp_for_dns_lookups(&mut self, v: bool) {
        self.use_tcp_for_dns_lookups = v;
    }

    // repeated .envoy.config.core.v4alpha.TypedExtensionConfig bootstrap_extensions = 21;


    pub fn get_bootstrap_extensions(&self) -> &[super::extension::TypedExtensionConfig] {
        &self.bootstrap_extensions
    }
    pub fn clear_bootstrap_extensions(&mut self) {
        self.bootstrap_extensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_bootstrap_extensions(&mut self, v: ::protobuf::RepeatedField<super::extension::TypedExtensionConfig>) {
        self.bootstrap_extensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bootstrap_extensions(&mut self) -> &mut ::protobuf::RepeatedField<super::extension::TypedExtensionConfig> {
        &mut self.bootstrap_extensions
    }

    // Take field
    pub fn take_bootstrap_extensions(&mut self) -> ::protobuf::RepeatedField<super::extension::TypedExtensionConfig> {
        ::std::mem::replace(&mut self.bootstrap_extensions, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.bootstrap.v4alpha.FatalAction fatal_actions = 28;


    pub fn get_fatal_actions(&self) -> &[FatalAction] {
        &self.fatal_actions
    }
    pub fn clear_fatal_actions(&mut self) {
        self.fatal_actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_fatal_actions(&mut self, v: ::protobuf::RepeatedField<FatalAction>) {
        self.fatal_actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fatal_actions(&mut self) -> &mut ::protobuf::RepeatedField<FatalAction> {
        &mut self.fatal_actions
    }

    // Take field
    pub fn take_fatal_actions(&mut self) -> ::protobuf::RepeatedField<FatalAction> {
        ::std::mem::replace(&mut self.fatal_actions, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.core.v4alpha.ConfigSource config_sources = 22;


    pub fn get_config_sources(&self) -> &[super::config_source::ConfigSource] {
        &self.config_sources
    }
    pub fn clear_config_sources(&mut self) {
        self.config_sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_config_sources(&mut self, v: ::protobuf::RepeatedField<super::config_source::ConfigSource>) {
        self.config_sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_config_sources(&mut self) -> &mut ::protobuf::RepeatedField<super::config_source::ConfigSource> {
        &mut self.config_sources
    }

    // Take field
    pub fn take_config_sources(&mut self) -> ::protobuf::RepeatedField<super::config_source::ConfigSource> {
        ::std::mem::replace(&mut self.config_sources, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.core.v4alpha.ConfigSource default_config_source = 23;


    pub fn get_default_config_source(&self) -> &super::config_source::ConfigSource {
        self.default_config_source.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_config_source(&mut self) {
        self.default_config_source.clear();
    }

    pub fn has_default_config_source(&self) -> bool {
        self.default_config_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_config_source(&mut self, v: super::config_source::ConfigSource) {
        self.default_config_source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_config_source(&mut self) -> &mut super::config_source::ConfigSource {
        if self.default_config_source.is_none() {
            self.default_config_source.set_default();
        }
        self.default_config_source.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_config_source(&mut self) -> super::config_source::ConfigSource {
        self.default_config_source.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }

    // string default_socket_interface = 24;


    pub fn get_default_socket_interface(&self) -> &str {
        &self.default_socket_interface
    }
    pub fn clear_default_socket_interface(&mut self) {
        self.default_socket_interface.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_socket_interface(&mut self, v: ::std::string::String) {
        self.default_socket_interface = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_socket_interface(&mut self) -> &mut ::std::string::String {
        &mut self.default_socket_interface
    }

    // Take field
    pub fn take_default_socket_interface(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_socket_interface, ::std::string::String::new())
    }

    // repeated .envoy.config.bootstrap.v4alpha.Bootstrap.CertificateProviderInstancesEntry certificate_provider_instances = 25;


    pub fn get_certificate_provider_instances(&self) -> &::std::collections::HashMap<::std::string::String, super::extension::TypedExtensionConfig> {
        &self.certificate_provider_instances
    }
    pub fn clear_certificate_provider_instances(&mut self) {
        self.certificate_provider_instances.clear();
    }

    // Param is passed by value, moved
    pub fn set_certificate_provider_instances(&mut self, v: ::std::collections::HashMap<::std::string::String, super::extension::TypedExtensionConfig>) {
        self.certificate_provider_instances = v;
    }

    // Mutable pointer to the field.
    pub fn mut_certificate_provider_instances(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::extension::TypedExtensionConfig> {
        &mut self.certificate_provider_instances
    }

    // Take field
    pub fn take_certificate_provider_instances(&mut self) -> ::std::collections::HashMap<::std::string::String, super::extension::TypedExtensionConfig> {
        ::std::mem::replace(&mut self.certificate_provider_instances, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Bootstrap {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.static_resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cluster_manager {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_sinks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_flush_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.watchdogs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.layered_runtime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.admin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overload_manager {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_server_version_override {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bootstrap_extensions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fatal_actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config_sources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_config_source {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                26 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.node_context_params)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.static_resources)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_resources)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster_manager)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hds_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.flags_path)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_sinks)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_config)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_flush_interval)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.watchdogs)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.layered_runtime)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.admin)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overload_manager)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_dispatcher_stats = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.header_prefix)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_server_version_override)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_tcp_for_dns_lookups = tmp;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bootstrap_extensions)?;
                },
                28 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.fatal_actions)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.config_sources)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_config_source)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_socket_interface)?;
                },
                25 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(wire_type, is, &mut self.certificate_provider_instances)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.node_context_params {
            my_size += ::protobuf::rt::string_size(26, &value);
        };
        if let Some(ref v) = self.static_resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dynamic_resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cluster_manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.flags_path.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.flags_path);
        }
        for value in &self.stats_sinks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.stats_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats_flush_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.watchdogs.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.layered_runtime.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.admin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.overload_manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enable_dispatcher_stats != false {
            my_size += 3;
        }
        if !self.header_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.header_prefix);
        }
        if let Some(ref v) = self.stats_server_version_override.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.use_tcp_for_dns_lookups != false {
            my_size += 3;
        }
        for value in &self.bootstrap_extensions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.fatal_actions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.config_sources {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.default_config_source.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.default_socket_interface.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.default_socket_interface);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(25, &self.certificate_provider_instances);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.node_context_params {
            os.write_string(26, &v)?;
        };
        if let Some(ref v) = self.static_resources.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dynamic_resources.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cluster_manager.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hds_config.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.flags_path.is_empty() {
            os.write_string(5, &self.flags_path)?;
        }
        for v in &self.stats_sinks {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.stats_config.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats_flush_interval.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.watchdogs.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.layered_runtime.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.admin.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.overload_manager.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enable_dispatcher_stats != false {
            os.write_bool(16, self.enable_dispatcher_stats)?;
        }
        if !self.header_prefix.is_empty() {
            os.write_string(18, &self.header_prefix)?;
        }
        if let Some(ref v) = self.stats_server_version_override.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.use_tcp_for_dns_lookups != false {
            os.write_bool(20, self.use_tcp_for_dns_lookups)?;
        }
        for v in &self.bootstrap_extensions {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.fatal_actions {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.config_sources {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.default_config_source.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.default_socket_interface.is_empty() {
            os.write_string(24, &self.default_socket_interface)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(25, &self.certificate_provider_instances, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bootstrap {
        Bootstrap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Node>>(
                "node",
                |m: &Bootstrap| { &m.node },
                |m: &mut Bootstrap| { &mut m.node },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_context_params",
                |m: &Bootstrap| { &m.node_context_params },
                |m: &mut Bootstrap| { &mut m.node_context_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bootstrap_StaticResources>>(
                "static_resources",
                |m: &Bootstrap| { &m.static_resources },
                |m: &mut Bootstrap| { &mut m.static_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bootstrap_DynamicResources>>(
                "dynamic_resources",
                |m: &Bootstrap| { &m.dynamic_resources },
                |m: &mut Bootstrap| { &mut m.dynamic_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterManager>>(
                "cluster_manager",
                |m: &Bootstrap| { &m.cluster_manager },
                |m: &mut Bootstrap| { &mut m.cluster_manager },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ApiConfigSource>>(
                "hds_config",
                |m: &Bootstrap| { &m.hds_config },
                |m: &mut Bootstrap| { &mut m.hds_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "flags_path",
                |m: &Bootstrap| { &m.flags_path },
                |m: &mut Bootstrap| { &mut m.flags_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::StatsSink>>(
                "stats_sinks",
                |m: &Bootstrap| { &m.stats_sinks },
                |m: &mut Bootstrap| { &mut m.stats_sinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::StatsConfig>>(
                "stats_config",
                |m: &Bootstrap| { &m.stats_config },
                |m: &mut Bootstrap| { &mut m.stats_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "stats_flush_interval",
                |m: &Bootstrap| { &m.stats_flush_interval },
                |m: &mut Bootstrap| { &mut m.stats_flush_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Watchdogs>>(
                "watchdogs",
                |m: &Bootstrap| { &m.watchdogs },
                |m: &mut Bootstrap| { &mut m.watchdogs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LayeredRuntime>>(
                "layered_runtime",
                |m: &Bootstrap| { &m.layered_runtime },
                |m: &mut Bootstrap| { &mut m.layered_runtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Admin>>(
                "admin",
                |m: &Bootstrap| { &m.admin },
                |m: &mut Bootstrap| { &mut m.admin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::overload::OverloadManager>>(
                "overload_manager",
                |m: &Bootstrap| { &m.overload_manager },
                |m: &mut Bootstrap| { &mut m.overload_manager },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_dispatcher_stats",
                |m: &Bootstrap| { &m.enable_dispatcher_stats },
                |m: &mut Bootstrap| { &mut m.enable_dispatcher_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header_prefix",
                |m: &Bootstrap| { &m.header_prefix },
                |m: &mut Bootstrap| { &mut m.header_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt64Value>>(
                "stats_server_version_override",
                |m: &Bootstrap| { &m.stats_server_version_override },
                |m: &mut Bootstrap| { &mut m.stats_server_version_override },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_tcp_for_dns_lookups",
                |m: &Bootstrap| { &m.use_tcp_for_dns_lookups },
                |m: &mut Bootstrap| { &mut m.use_tcp_for_dns_lookups },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(
                "bootstrap_extensions",
                |m: &Bootstrap| { &m.bootstrap_extensions },
                |m: &mut Bootstrap| { &mut m.bootstrap_extensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FatalAction>>(
                "fatal_actions",
                |m: &Bootstrap| { &m.fatal_actions },
                |m: &mut Bootstrap| { &mut m.fatal_actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "config_sources",
                |m: &Bootstrap| { &m.config_sources },
                |m: &mut Bootstrap| { &mut m.config_sources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "default_config_source",
                |m: &Bootstrap| { &m.default_config_source },
                |m: &mut Bootstrap| { &mut m.default_config_source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_socket_interface",
                |m: &Bootstrap| { &m.default_socket_interface },
                |m: &mut Bootstrap| { &mut m.default_socket_interface },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(
                "certificate_provider_instances",
                |m: &Bootstrap| { &m.certificate_provider_instances },
                |m: &mut Bootstrap| { &mut m.certificate_provider_instances },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bootstrap>(
                "Bootstrap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bootstrap {
        static instance: ::protobuf::rt::LazyV2<Bootstrap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bootstrap::new)
    }
}

impl ::protobuf::Clear for Bootstrap {
    fn clear(&mut self) {
        self.node.clear();
        self.node_context_params.clear();
        self.static_resources.clear();
        self.dynamic_resources.clear();
        self.cluster_manager.clear();
        self.hds_config.clear();
        self.flags_path.clear();
        self.stats_sinks.clear();
        self.stats_config.clear();
        self.stats_flush_interval.clear();
        self.watchdogs.clear();
        self.layered_runtime.clear();
        self.admin.clear();
        self.overload_manager.clear();
        self.enable_dispatcher_stats = false;
        self.header_prefix.clear();
        self.stats_server_version_override.clear();
        self.use_tcp_for_dns_lookups = false;
        self.bootstrap_extensions.clear();
        self.fatal_actions.clear();
        self.config_sources.clear();
        self.default_config_source.clear();
        self.default_socket_interface.clear();
        self.certificate_provider_instances.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bootstrap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bootstrap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bootstrap_StaticResources {
    // message fields
    pub listeners: ::protobuf::RepeatedField<super::listener::Listener>,
    pub clusters: ::protobuf::RepeatedField<super::cluster::Cluster>,
    pub secrets: ::protobuf::RepeatedField<super::secret::Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bootstrap_StaticResources {
    fn default() -> &'a Bootstrap_StaticResources {
        <Bootstrap_StaticResources as ::protobuf::Message>::default_instance()
    }
}

impl Bootstrap_StaticResources {
    pub fn new() -> Bootstrap_StaticResources {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.listener.v4alpha.Listener listeners = 1;


    pub fn get_listeners(&self) -> &[super::listener::Listener] {
        &self.listeners
    }
    pub fn clear_listeners(&mut self) {
        self.listeners.clear();
    }

    // Param is passed by value, moved
    pub fn set_listeners(&mut self, v: ::protobuf::RepeatedField<super::listener::Listener>) {
        self.listeners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listeners(&mut self) -> &mut ::protobuf::RepeatedField<super::listener::Listener> {
        &mut self.listeners
    }

    // Take field
    pub fn take_listeners(&mut self) -> ::protobuf::RepeatedField<super::listener::Listener> {
        ::std::mem::replace(&mut self.listeners, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.cluster.v4alpha.Cluster clusters = 2;


    pub fn get_clusters(&self) -> &[super::cluster::Cluster] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<super::cluster::Cluster>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<super::cluster::Cluster> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<super::cluster::Cluster> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.extensions.transport_sockets.tls.v4alpha.Secret secrets = 3;


    pub fn get_secrets(&self) -> &[super::secret::Secret] {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::protobuf::RepeatedField<super::secret::Secret>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::protobuf::RepeatedField<super::secret::Secret> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::protobuf::RepeatedField<super::secret::Secret> {
        ::std::mem::replace(&mut self.secrets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Bootstrap_StaticResources {
    fn is_initialized(&self) -> bool {
        for v in &self.listeners {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.listeners)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secrets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.listeners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.listeners {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.clusters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.secrets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bootstrap_StaticResources {
        Bootstrap_StaticResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::listener::Listener>>(
                "listeners",
                |m: &Bootstrap_StaticResources| { &m.listeners },
                |m: &mut Bootstrap_StaticResources| { &mut m.listeners },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cluster::Cluster>>(
                "clusters",
                |m: &Bootstrap_StaticResources| { &m.clusters },
                |m: &mut Bootstrap_StaticResources| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::secret::Secret>>(
                "secrets",
                |m: &Bootstrap_StaticResources| { &m.secrets },
                |m: &mut Bootstrap_StaticResources| { &mut m.secrets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bootstrap_StaticResources>(
                "Bootstrap.StaticResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bootstrap_StaticResources {
        static instance: ::protobuf::rt::LazyV2<Bootstrap_StaticResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bootstrap_StaticResources::new)
    }
}

impl ::protobuf::Clear for Bootstrap_StaticResources {
    fn clear(&mut self) {
        self.listeners.clear();
        self.clusters.clear();
        self.secrets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bootstrap_StaticResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bootstrap_StaticResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bootstrap_DynamicResources {
    // message fields
    pub lds_config: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    pub lds_resources_locator: ::std::string::String,
    pub cds_config: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    pub cds_resources_locator: ::std::string::String,
    pub ads_config: ::protobuf::SingularPtrField<super::config_source::ApiConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bootstrap_DynamicResources {
    fn default() -> &'a Bootstrap_DynamicResources {
        <Bootstrap_DynamicResources as ::protobuf::Message>::default_instance()
    }
}

impl Bootstrap_DynamicResources {
    pub fn new() -> Bootstrap_DynamicResources {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v4alpha.ConfigSource lds_config = 1;


    pub fn get_lds_config(&self) -> &super::config_source::ConfigSource {
        self.lds_config.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lds_config(&mut self) {
        self.lds_config.clear();
    }

    pub fn has_lds_config(&self) -> bool {
        self.lds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lds_config(&mut self, v: super::config_source::ConfigSource) {
        self.lds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lds_config(&mut self) -> &mut super::config_source::ConfigSource {
        if self.lds_config.is_none() {
            self.lds_config.set_default();
        }
        self.lds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_lds_config(&mut self) -> super::config_source::ConfigSource {
        self.lds_config.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }

    // string lds_resources_locator = 5;


    pub fn get_lds_resources_locator(&self) -> &str {
        &self.lds_resources_locator
    }
    pub fn clear_lds_resources_locator(&mut self) {
        self.lds_resources_locator.clear();
    }

    // Param is passed by value, moved
    pub fn set_lds_resources_locator(&mut self, v: ::std::string::String) {
        self.lds_resources_locator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lds_resources_locator(&mut self) -> &mut ::std::string::String {
        &mut self.lds_resources_locator
    }

    // Take field
    pub fn take_lds_resources_locator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.lds_resources_locator, ::std::string::String::new())
    }

    // .envoy.config.core.v4alpha.ConfigSource cds_config = 2;


    pub fn get_cds_config(&self) -> &super::config_source::ConfigSource {
        self.cds_config.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cds_config(&mut self) {
        self.cds_config.clear();
    }

    pub fn has_cds_config(&self) -> bool {
        self.cds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cds_config(&mut self, v: super::config_source::ConfigSource) {
        self.cds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cds_config(&mut self) -> &mut super::config_source::ConfigSource {
        if self.cds_config.is_none() {
            self.cds_config.set_default();
        }
        self.cds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_cds_config(&mut self) -> super::config_source::ConfigSource {
        self.cds_config.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }

    // string cds_resources_locator = 6;


    pub fn get_cds_resources_locator(&self) -> &str {
        &self.cds_resources_locator
    }
    pub fn clear_cds_resources_locator(&mut self) {
        self.cds_resources_locator.clear();
    }

    // Param is passed by value, moved
    pub fn set_cds_resources_locator(&mut self, v: ::std::string::String) {
        self.cds_resources_locator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cds_resources_locator(&mut self) -> &mut ::std::string::String {
        &mut self.cds_resources_locator
    }

    // Take field
    pub fn take_cds_resources_locator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cds_resources_locator, ::std::string::String::new())
    }

    // .envoy.config.core.v4alpha.ApiConfigSource ads_config = 3;


    pub fn get_ads_config(&self) -> &super::config_source::ApiConfigSource {
        self.ads_config.as_ref().unwrap_or_else(|| <super::config_source::ApiConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ads_config(&mut self) {
        self.ads_config.clear();
    }

    pub fn has_ads_config(&self) -> bool {
        self.ads_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ads_config(&mut self, v: super::config_source::ApiConfigSource) {
        self.ads_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ads_config(&mut self) -> &mut super::config_source::ApiConfigSource {
        if self.ads_config.is_none() {
            self.ads_config.set_default();
        }
        self.ads_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_ads_config(&mut self) -> super::config_source::ApiConfigSource {
        self.ads_config.take().unwrap_or_else(|| super::config_source::ApiConfigSource::new())
    }
}

impl ::protobuf::Message for Bootstrap_DynamicResources {
    fn is_initialized(&self) -> bool {
        for v in &self.lds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ads_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lds_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.lds_resources_locator)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cds_config)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cds_resources_locator)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ads_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.lds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.lds_resources_locator.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.lds_resources_locator);
        }
        if let Some(ref v) = self.cds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cds_resources_locator.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.cds_resources_locator);
        }
        if let Some(ref v) = self.ads_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.lds_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.lds_resources_locator.is_empty() {
            os.write_string(5, &self.lds_resources_locator)?;
        }
        if let Some(ref v) = self.cds_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cds_resources_locator.is_empty() {
            os.write_string(6, &self.cds_resources_locator)?;
        }
        if let Some(ref v) = self.ads_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bootstrap_DynamicResources {
        Bootstrap_DynamicResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "lds_config",
                |m: &Bootstrap_DynamicResources| { &m.lds_config },
                |m: &mut Bootstrap_DynamicResources| { &mut m.lds_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "lds_resources_locator",
                |m: &Bootstrap_DynamicResources| { &m.lds_resources_locator },
                |m: &mut Bootstrap_DynamicResources| { &mut m.lds_resources_locator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "cds_config",
                |m: &Bootstrap_DynamicResources| { &m.cds_config },
                |m: &mut Bootstrap_DynamicResources| { &mut m.cds_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cds_resources_locator",
                |m: &Bootstrap_DynamicResources| { &m.cds_resources_locator },
                |m: &mut Bootstrap_DynamicResources| { &mut m.cds_resources_locator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ApiConfigSource>>(
                "ads_config",
                |m: &Bootstrap_DynamicResources| { &m.ads_config },
                |m: &mut Bootstrap_DynamicResources| { &mut m.ads_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bootstrap_DynamicResources>(
                "Bootstrap.DynamicResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bootstrap_DynamicResources {
        static instance: ::protobuf::rt::LazyV2<Bootstrap_DynamicResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bootstrap_DynamicResources::new)
    }
}

impl ::protobuf::Clear for Bootstrap_DynamicResources {
    fn clear(&mut self) {
        self.lds_config.clear();
        self.lds_resources_locator.clear();
        self.cds_config.clear();
        self.cds_resources_locator.clear();
        self.ads_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bootstrap_DynamicResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bootstrap_DynamicResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Admin {
    // message fields
    pub access_log_path: ::std::string::String,
    pub profile_path: ::std::string::String,
    pub address: ::protobuf::SingularPtrField<super::address::Address>,
    pub socket_options: ::protobuf::RepeatedField<super::socket_option::SocketOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Admin {
    fn default() -> &'a Admin {
        <Admin as ::protobuf::Message>::default_instance()
    }
}

impl Admin {
    pub fn new() -> Admin {
        ::std::default::Default::default()
    }

    // string access_log_path = 1;


    pub fn get_access_log_path(&self) -> &str {
        &self.access_log_path
    }
    pub fn clear_access_log_path(&mut self) {
        self.access_log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_log_path(&mut self, v: ::std::string::String) {
        self.access_log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.access_log_path
    }

    // Take field
    pub fn take_access_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_log_path, ::std::string::String::new())
    }

    // string profile_path = 2;


    pub fn get_profile_path(&self) -> &str {
        &self.profile_path
    }
    pub fn clear_profile_path(&mut self) {
        self.profile_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_path(&mut self, v: ::std::string::String) {
        self.profile_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_path(&mut self) -> &mut ::std::string::String {
        &mut self.profile_path
    }

    // Take field
    pub fn take_profile_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.profile_path, ::std::string::String::new())
    }

    // .envoy.config.core.v4alpha.Address address = 3;


    pub fn get_address(&self) -> &super::address::Address {
        self.address.as_ref().unwrap_or_else(|| <super::address::Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: super::address::Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut super::address::Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> super::address::Address {
        self.address.take().unwrap_or_else(|| super::address::Address::new())
    }

    // repeated .envoy.config.core.v4alpha.SocketOption socket_options = 4;


    pub fn get_socket_options(&self) -> &[super::socket_option::SocketOption] {
        &self.socket_options
    }
    pub fn clear_socket_options(&mut self) {
        self.socket_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_socket_options(&mut self, v: ::protobuf::RepeatedField<super::socket_option::SocketOption>) {
        self.socket_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_socket_options(&mut self) -> &mut ::protobuf::RepeatedField<super::socket_option::SocketOption> {
        &mut self.socket_options
    }

    // Take field
    pub fn take_socket_options(&mut self) -> ::protobuf::RepeatedField<super::socket_option::SocketOption> {
        ::std::mem::replace(&mut self.socket_options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Admin {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socket_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_log_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.profile_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.socket_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.access_log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.access_log_path);
        }
        if !self.profile_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.profile_path);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.socket_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.access_log_path.is_empty() {
            os.write_string(1, &self.access_log_path)?;
        }
        if !self.profile_path.is_empty() {
            os.write_string(2, &self.profile_path)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.socket_options {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Admin {
        Admin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_log_path",
                |m: &Admin| { &m.access_log_path },
                |m: &mut Admin| { &mut m.access_log_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "profile_path",
                |m: &Admin| { &m.profile_path },
                |m: &mut Admin| { &mut m.profile_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::address::Address>>(
                "address",
                |m: &Admin| { &m.address },
                |m: &mut Admin| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::socket_option::SocketOption>>(
                "socket_options",
                |m: &Admin| { &m.socket_options },
                |m: &mut Admin| { &mut m.socket_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Admin>(
                "Admin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Admin {
        static instance: ::protobuf::rt::LazyV2<Admin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Admin::new)
    }
}

impl ::protobuf::Clear for Admin {
    fn clear(&mut self) {
        self.access_log_path.clear();
        self.profile_path.clear();
        self.address.clear();
        self.socket_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Admin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Admin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterManager {
    // message fields
    pub local_cluster_name: ::std::string::String,
    pub outlier_detection: ::protobuf::SingularPtrField<ClusterManager_OutlierDetection>,
    pub upstream_bind_config: ::protobuf::SingularPtrField<super::address::BindConfig>,
    pub load_stats_config: ::protobuf::SingularPtrField<super::config_source::ApiConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterManager {
    fn default() -> &'a ClusterManager {
        <ClusterManager as ::protobuf::Message>::default_instance()
    }
}

impl ClusterManager {
    pub fn new() -> ClusterManager {
        ::std::default::Default::default()
    }

    // string local_cluster_name = 1;


    pub fn get_local_cluster_name(&self) -> &str {
        &self.local_cluster_name
    }
    pub fn clear_local_cluster_name(&mut self) {
        self.local_cluster_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_cluster_name(&mut self, v: ::std::string::String) {
        self.local_cluster_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_cluster_name(&mut self) -> &mut ::std::string::String {
        &mut self.local_cluster_name
    }

    // Take field
    pub fn take_local_cluster_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_cluster_name, ::std::string::String::new())
    }

    // .envoy.config.bootstrap.v4alpha.ClusterManager.OutlierDetection outlier_detection = 2;


    pub fn get_outlier_detection(&self) -> &ClusterManager_OutlierDetection {
        self.outlier_detection.as_ref().unwrap_or_else(|| <ClusterManager_OutlierDetection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outlier_detection(&mut self) {
        self.outlier_detection.clear();
    }

    pub fn has_outlier_detection(&self) -> bool {
        self.outlier_detection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outlier_detection(&mut self, v: ClusterManager_OutlierDetection) {
        self.outlier_detection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outlier_detection(&mut self) -> &mut ClusterManager_OutlierDetection {
        if self.outlier_detection.is_none() {
            self.outlier_detection.set_default();
        }
        self.outlier_detection.as_mut().unwrap()
    }

    // Take field
    pub fn take_outlier_detection(&mut self) -> ClusterManager_OutlierDetection {
        self.outlier_detection.take().unwrap_or_else(|| ClusterManager_OutlierDetection::new())
    }

    // .envoy.config.core.v4alpha.BindConfig upstream_bind_config = 3;


    pub fn get_upstream_bind_config(&self) -> &super::address::BindConfig {
        self.upstream_bind_config.as_ref().unwrap_or_else(|| <super::address::BindConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_upstream_bind_config(&mut self) {
        self.upstream_bind_config.clear();
    }

    pub fn has_upstream_bind_config(&self) -> bool {
        self.upstream_bind_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upstream_bind_config(&mut self, v: super::address::BindConfig) {
        self.upstream_bind_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upstream_bind_config(&mut self) -> &mut super::address::BindConfig {
        if self.upstream_bind_config.is_none() {
            self.upstream_bind_config.set_default();
        }
        self.upstream_bind_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_upstream_bind_config(&mut self) -> super::address::BindConfig {
        self.upstream_bind_config.take().unwrap_or_else(|| super::address::BindConfig::new())
    }

    // .envoy.config.core.v4alpha.ApiConfigSource load_stats_config = 4;


    pub fn get_load_stats_config(&self) -> &super::config_source::ApiConfigSource {
        self.load_stats_config.as_ref().unwrap_or_else(|| <super::config_source::ApiConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_load_stats_config(&mut self) {
        self.load_stats_config.clear();
    }

    pub fn has_load_stats_config(&self) -> bool {
        self.load_stats_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_stats_config(&mut self, v: super::config_source::ApiConfigSource) {
        self.load_stats_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_stats_config(&mut self) -> &mut super::config_source::ApiConfigSource {
        if self.load_stats_config.is_none() {
            self.load_stats_config.set_default();
        }
        self.load_stats_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_stats_config(&mut self) -> super::config_source::ApiConfigSource {
        self.load_stats_config.take().unwrap_or_else(|| super::config_source::ApiConfigSource::new())
    }
}

impl ::protobuf::Message for ClusterManager {
    fn is_initialized(&self) -> bool {
        for v in &self.outlier_detection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upstream_bind_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.load_stats_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_cluster_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outlier_detection)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.upstream_bind_config)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_stats_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.local_cluster_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.local_cluster_name);
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.upstream_bind_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.load_stats_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.local_cluster_name.is_empty() {
            os.write_string(1, &self.local_cluster_name)?;
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.upstream_bind_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.load_stats_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterManager {
        ClusterManager::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_cluster_name",
                |m: &ClusterManager| { &m.local_cluster_name },
                |m: &mut ClusterManager| { &mut m.local_cluster_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterManager_OutlierDetection>>(
                "outlier_detection",
                |m: &ClusterManager| { &m.outlier_detection },
                |m: &mut ClusterManager| { &mut m.outlier_detection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::address::BindConfig>>(
                "upstream_bind_config",
                |m: &ClusterManager| { &m.upstream_bind_config },
                |m: &mut ClusterManager| { &mut m.upstream_bind_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ApiConfigSource>>(
                "load_stats_config",
                |m: &ClusterManager| { &m.load_stats_config },
                |m: &mut ClusterManager| { &mut m.load_stats_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClusterManager>(
                "ClusterManager",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClusterManager {
        static instance: ::protobuf::rt::LazyV2<ClusterManager> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClusterManager::new)
    }
}

impl ::protobuf::Clear for ClusterManager {
    fn clear(&mut self) {
        self.local_cluster_name.clear();
        self.outlier_detection.clear();
        self.upstream_bind_config.clear();
        self.load_stats_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterManager {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterManager_OutlierDetection {
    // message fields
    pub event_log_path: ::std::string::String,
    pub event_service: ::protobuf::SingularPtrField<super::event_service_config::EventServiceConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterManager_OutlierDetection {
    fn default() -> &'a ClusterManager_OutlierDetection {
        <ClusterManager_OutlierDetection as ::protobuf::Message>::default_instance()
    }
}

impl ClusterManager_OutlierDetection {
    pub fn new() -> ClusterManager_OutlierDetection {
        ::std::default::Default::default()
    }

    // string event_log_path = 1;


    pub fn get_event_log_path(&self) -> &str {
        &self.event_log_path
    }
    pub fn clear_event_log_path(&mut self) {
        self.event_log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_log_path(&mut self, v: ::std::string::String) {
        self.event_log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.event_log_path
    }

    // Take field
    pub fn take_event_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_log_path, ::std::string::String::new())
    }

    // .envoy.config.core.v4alpha.EventServiceConfig event_service = 2;


    pub fn get_event_service(&self) -> &super::event_service_config::EventServiceConfig {
        self.event_service.as_ref().unwrap_or_else(|| <super::event_service_config::EventServiceConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event_service(&mut self) {
        self.event_service.clear();
    }

    pub fn has_event_service(&self) -> bool {
        self.event_service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_service(&mut self, v: super::event_service_config::EventServiceConfig) {
        self.event_service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_service(&mut self) -> &mut super::event_service_config::EventServiceConfig {
        if self.event_service.is_none() {
            self.event_service.set_default();
        }
        self.event_service.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_service(&mut self) -> super::event_service_config::EventServiceConfig {
        self.event_service.take().unwrap_or_else(|| super::event_service_config::EventServiceConfig::new())
    }
}

impl ::protobuf::Message for ClusterManager_OutlierDetection {
    fn is_initialized(&self) -> bool {
        for v in &self.event_service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_log_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.event_log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.event_log_path);
        }
        if let Some(ref v) = self.event_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.event_log_path.is_empty() {
            os.write_string(1, &self.event_log_path)?;
        }
        if let Some(ref v) = self.event_service.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterManager_OutlierDetection {
        ClusterManager_OutlierDetection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_log_path",
                |m: &ClusterManager_OutlierDetection| { &m.event_log_path },
                |m: &mut ClusterManager_OutlierDetection| { &mut m.event_log_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::event_service_config::EventServiceConfig>>(
                "event_service",
                |m: &ClusterManager_OutlierDetection| { &m.event_service },
                |m: &mut ClusterManager_OutlierDetection| { &mut m.event_service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClusterManager_OutlierDetection>(
                "ClusterManager.OutlierDetection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClusterManager_OutlierDetection {
        static instance: ::protobuf::rt::LazyV2<ClusterManager_OutlierDetection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClusterManager_OutlierDetection::new)
    }
}

impl ::protobuf::Clear for ClusterManager_OutlierDetection {
    fn clear(&mut self) {
        self.event_log_path.clear();
        self.event_service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterManager_OutlierDetection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterManager_OutlierDetection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Watchdogs {
    // message fields
    pub main_thread_watchdog: ::protobuf::SingularPtrField<Watchdog>,
    pub worker_watchdog: ::protobuf::SingularPtrField<Watchdog>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Watchdogs {
    fn default() -> &'a Watchdogs {
        <Watchdogs as ::protobuf::Message>::default_instance()
    }
}

impl Watchdogs {
    pub fn new() -> Watchdogs {
        ::std::default::Default::default()
    }

    // .envoy.config.bootstrap.v4alpha.Watchdog main_thread_watchdog = 1;


    pub fn get_main_thread_watchdog(&self) -> &Watchdog {
        self.main_thread_watchdog.as_ref().unwrap_or_else(|| <Watchdog as ::protobuf::Message>::default_instance())
    }
    pub fn clear_main_thread_watchdog(&mut self) {
        self.main_thread_watchdog.clear();
    }

    pub fn has_main_thread_watchdog(&self) -> bool {
        self.main_thread_watchdog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_main_thread_watchdog(&mut self, v: Watchdog) {
        self.main_thread_watchdog = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_main_thread_watchdog(&mut self) -> &mut Watchdog {
        if self.main_thread_watchdog.is_none() {
            self.main_thread_watchdog.set_default();
        }
        self.main_thread_watchdog.as_mut().unwrap()
    }

    // Take field
    pub fn take_main_thread_watchdog(&mut self) -> Watchdog {
        self.main_thread_watchdog.take().unwrap_or_else(|| Watchdog::new())
    }

    // .envoy.config.bootstrap.v4alpha.Watchdog worker_watchdog = 2;


    pub fn get_worker_watchdog(&self) -> &Watchdog {
        self.worker_watchdog.as_ref().unwrap_or_else(|| <Watchdog as ::protobuf::Message>::default_instance())
    }
    pub fn clear_worker_watchdog(&mut self) {
        self.worker_watchdog.clear();
    }

    pub fn has_worker_watchdog(&self) -> bool {
        self.worker_watchdog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_worker_watchdog(&mut self, v: Watchdog) {
        self.worker_watchdog = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_worker_watchdog(&mut self) -> &mut Watchdog {
        if self.worker_watchdog.is_none() {
            self.worker_watchdog.set_default();
        }
        self.worker_watchdog.as_mut().unwrap()
    }

    // Take field
    pub fn take_worker_watchdog(&mut self) -> Watchdog {
        self.worker_watchdog.take().unwrap_or_else(|| Watchdog::new())
    }
}

impl ::protobuf::Message for Watchdogs {
    fn is_initialized(&self) -> bool {
        for v in &self.main_thread_watchdog {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.worker_watchdog {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.main_thread_watchdog)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.worker_watchdog)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.main_thread_watchdog.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.worker_watchdog.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.main_thread_watchdog.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.worker_watchdog.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Watchdogs {
        Watchdogs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Watchdog>>(
                "main_thread_watchdog",
                |m: &Watchdogs| { &m.main_thread_watchdog },
                |m: &mut Watchdogs| { &mut m.main_thread_watchdog },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Watchdog>>(
                "worker_watchdog",
                |m: &Watchdogs| { &m.worker_watchdog },
                |m: &mut Watchdogs| { &mut m.worker_watchdog },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Watchdogs>(
                "Watchdogs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Watchdogs {
        static instance: ::protobuf::rt::LazyV2<Watchdogs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Watchdogs::new)
    }
}

impl ::protobuf::Clear for Watchdogs {
    fn clear(&mut self) {
        self.main_thread_watchdog.clear();
        self.worker_watchdog.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Watchdogs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Watchdogs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Watchdog {
    // message fields
    pub actions: ::protobuf::RepeatedField<Watchdog_WatchdogAction>,
    pub miss_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub megamiss_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub kill_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_kill_timeout_jitter: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub multikill_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub multikill_threshold: ::protobuf::SingularPtrField<super::percent::Percent>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Watchdog {
    fn default() -> &'a Watchdog {
        <Watchdog as ::protobuf::Message>::default_instance()
    }
}

impl Watchdog {
    pub fn new() -> Watchdog {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.bootstrap.v4alpha.Watchdog.WatchdogAction actions = 7;


    pub fn get_actions(&self) -> &[Watchdog_WatchdogAction] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<Watchdog_WatchdogAction>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<Watchdog_WatchdogAction> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<Watchdog_WatchdogAction> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Duration miss_timeout = 1;


    pub fn get_miss_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.miss_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_miss_timeout(&mut self) {
        self.miss_timeout.clear();
    }

    pub fn has_miss_timeout(&self) -> bool {
        self.miss_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_miss_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.miss_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_miss_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.miss_timeout.is_none() {
            self.miss_timeout.set_default();
        }
        self.miss_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_miss_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.miss_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration megamiss_timeout = 2;


    pub fn get_megamiss_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.megamiss_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_megamiss_timeout(&mut self) {
        self.megamiss_timeout.clear();
    }

    pub fn has_megamiss_timeout(&self) -> bool {
        self.megamiss_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_megamiss_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.megamiss_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_megamiss_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.megamiss_timeout.is_none() {
            self.megamiss_timeout.set_default();
        }
        self.megamiss_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_megamiss_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.megamiss_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration kill_timeout = 3;


    pub fn get_kill_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.kill_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kill_timeout(&mut self) {
        self.kill_timeout.clear();
    }

    pub fn has_kill_timeout(&self) -> bool {
        self.kill_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.kill_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kill_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.kill_timeout.is_none() {
            self.kill_timeout.set_default();
        }
        self.kill_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_kill_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.kill_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration max_kill_timeout_jitter = 6;


    pub fn get_max_kill_timeout_jitter(&self) -> &::protobuf::well_known_types::Duration {
        self.max_kill_timeout_jitter.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_kill_timeout_jitter(&mut self) {
        self.max_kill_timeout_jitter.clear();
    }

    pub fn has_max_kill_timeout_jitter(&self) -> bool {
        self.max_kill_timeout_jitter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_kill_timeout_jitter(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_kill_timeout_jitter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_kill_timeout_jitter(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_kill_timeout_jitter.is_none() {
            self.max_kill_timeout_jitter.set_default();
        }
        self.max_kill_timeout_jitter.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_kill_timeout_jitter(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_kill_timeout_jitter.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration multikill_timeout = 4;


    pub fn get_multikill_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.multikill_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multikill_timeout(&mut self) {
        self.multikill_timeout.clear();
    }

    pub fn has_multikill_timeout(&self) -> bool {
        self.multikill_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multikill_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.multikill_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multikill_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.multikill_timeout.is_none() {
            self.multikill_timeout.set_default();
        }
        self.multikill_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_multikill_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.multikill_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.type.v3.Percent multikill_threshold = 5;


    pub fn get_multikill_threshold(&self) -> &super::percent::Percent {
        self.multikill_threshold.as_ref().unwrap_or_else(|| <super::percent::Percent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multikill_threshold(&mut self) {
        self.multikill_threshold.clear();
    }

    pub fn has_multikill_threshold(&self) -> bool {
        self.multikill_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multikill_threshold(&mut self, v: super::percent::Percent) {
        self.multikill_threshold = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multikill_threshold(&mut self) -> &mut super::percent::Percent {
        if self.multikill_threshold.is_none() {
            self.multikill_threshold.set_default();
        }
        self.multikill_threshold.as_mut().unwrap()
    }

    // Take field
    pub fn take_multikill_threshold(&mut self) -> super::percent::Percent {
        self.multikill_threshold.take().unwrap_or_else(|| super::percent::Percent::new())
    }
}

impl ::protobuf::Message for Watchdog {
    fn is_initialized(&self) -> bool {
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.miss_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.megamiss_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kill_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_kill_timeout_jitter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multikill_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multikill_threshold {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.miss_timeout)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.megamiss_timeout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kill_timeout)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_kill_timeout_jitter)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multikill_timeout)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multikill_threshold)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.miss_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.megamiss_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kill_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_kill_timeout_jitter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.multikill_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.multikill_threshold.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.actions {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.miss_timeout.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.megamiss_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kill_timeout.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_kill_timeout_jitter.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.multikill_timeout.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.multikill_threshold.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Watchdog {
        Watchdog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Watchdog_WatchdogAction>>(
                "actions",
                |m: &Watchdog| { &m.actions },
                |m: &mut Watchdog| { &mut m.actions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "miss_timeout",
                |m: &Watchdog| { &m.miss_timeout },
                |m: &mut Watchdog| { &mut m.miss_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "megamiss_timeout",
                |m: &Watchdog| { &m.megamiss_timeout },
                |m: &mut Watchdog| { &mut m.megamiss_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "kill_timeout",
                |m: &Watchdog| { &m.kill_timeout },
                |m: &mut Watchdog| { &mut m.kill_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_kill_timeout_jitter",
                |m: &Watchdog| { &m.max_kill_timeout_jitter },
                |m: &mut Watchdog| { &mut m.max_kill_timeout_jitter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "multikill_timeout",
                |m: &Watchdog| { &m.multikill_timeout },
                |m: &mut Watchdog| { &mut m.multikill_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::Percent>>(
                "multikill_threshold",
                |m: &Watchdog| { &m.multikill_threshold },
                |m: &mut Watchdog| { &mut m.multikill_threshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Watchdog>(
                "Watchdog",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Watchdog {
        static instance: ::protobuf::rt::LazyV2<Watchdog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Watchdog::new)
    }
}

impl ::protobuf::Clear for Watchdog {
    fn clear(&mut self) {
        self.actions.clear();
        self.miss_timeout.clear();
        self.megamiss_timeout.clear();
        self.kill_timeout.clear();
        self.max_kill_timeout_jitter.clear();
        self.multikill_timeout.clear();
        self.multikill_threshold.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Watchdog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Watchdog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Watchdog_WatchdogAction {
    // message fields
    pub config: ::protobuf::SingularPtrField<super::extension::TypedExtensionConfig>,
    pub event: Watchdog_WatchdogAction_WatchdogEvent,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Watchdog_WatchdogAction {
    fn default() -> &'a Watchdog_WatchdogAction {
        <Watchdog_WatchdogAction as ::protobuf::Message>::default_instance()
    }
}

impl Watchdog_WatchdogAction {
    pub fn new() -> Watchdog_WatchdogAction {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v4alpha.TypedExtensionConfig config = 1;


    pub fn get_config(&self) -> &super::extension::TypedExtensionConfig {
        self.config.as_ref().unwrap_or_else(|| <super::extension::TypedExtensionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: super::extension::TypedExtensionConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut super::extension::TypedExtensionConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> super::extension::TypedExtensionConfig {
        self.config.take().unwrap_or_else(|| super::extension::TypedExtensionConfig::new())
    }

    // .envoy.config.bootstrap.v4alpha.Watchdog.WatchdogAction.WatchdogEvent event = 2;


    pub fn get_event(&self) -> Watchdog_WatchdogAction_WatchdogEvent {
        self.event
    }
    pub fn clear_event(&mut self) {
        self.event = Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: Watchdog_WatchdogAction_WatchdogEvent) {
        self.event = v;
    }
}

impl ::protobuf::Message for Watchdog_WatchdogAction {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.event, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.event != Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.event);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.event != Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.event))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Watchdog_WatchdogAction {
        Watchdog_WatchdogAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(
                "config",
                |m: &Watchdog_WatchdogAction| { &m.config },
                |m: &mut Watchdog_WatchdogAction| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Watchdog_WatchdogAction_WatchdogEvent>>(
                "event",
                |m: &Watchdog_WatchdogAction| { &m.event },
                |m: &mut Watchdog_WatchdogAction| { &mut m.event },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Watchdog_WatchdogAction>(
                "Watchdog.WatchdogAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Watchdog_WatchdogAction {
        static instance: ::protobuf::rt::LazyV2<Watchdog_WatchdogAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Watchdog_WatchdogAction::new)
    }
}

impl ::protobuf::Clear for Watchdog_WatchdogAction {
    fn clear(&mut self) {
        self.config.clear();
        self.event = Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Watchdog_WatchdogAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Watchdog_WatchdogAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Watchdog_WatchdogAction_WatchdogEvent {
    UNKNOWN = 0,
    KILL = 1,
    MULTIKILL = 2,
    MEGAMISS = 3,
    MISS = 4,
}

impl ::protobuf::ProtobufEnum for Watchdog_WatchdogAction_WatchdogEvent {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Watchdog_WatchdogAction_WatchdogEvent> {
        match value {
            0 => ::std::option::Option::Some(Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN),
            1 => ::std::option::Option::Some(Watchdog_WatchdogAction_WatchdogEvent::KILL),
            2 => ::std::option::Option::Some(Watchdog_WatchdogAction_WatchdogEvent::MULTIKILL),
            3 => ::std::option::Option::Some(Watchdog_WatchdogAction_WatchdogEvent::MEGAMISS),
            4 => ::std::option::Option::Some(Watchdog_WatchdogAction_WatchdogEvent::MISS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Watchdog_WatchdogAction_WatchdogEvent] = &[
            Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN,
            Watchdog_WatchdogAction_WatchdogEvent::KILL,
            Watchdog_WatchdogAction_WatchdogEvent::MULTIKILL,
            Watchdog_WatchdogAction_WatchdogEvent::MEGAMISS,
            Watchdog_WatchdogAction_WatchdogEvent::MISS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Watchdog_WatchdogAction_WatchdogEvent>("Watchdog.WatchdogAction.WatchdogEvent", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Watchdog_WatchdogAction_WatchdogEvent {
}

impl ::std::default::Default for Watchdog_WatchdogAction_WatchdogEvent {
    fn default() -> Self {
        Watchdog_WatchdogAction_WatchdogEvent::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for Watchdog_WatchdogAction_WatchdogEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FatalAction {
    // message fields
    pub config: ::protobuf::SingularPtrField<super::extension::TypedExtensionConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FatalAction {
    fn default() -> &'a FatalAction {
        <FatalAction as ::protobuf::Message>::default_instance()
    }
}

impl FatalAction {
    pub fn new() -> FatalAction {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v4alpha.TypedExtensionConfig config = 1;


    pub fn get_config(&self) -> &super::extension::TypedExtensionConfig {
        self.config.as_ref().unwrap_or_else(|| <super::extension::TypedExtensionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: super::extension::TypedExtensionConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut super::extension::TypedExtensionConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> super::extension::TypedExtensionConfig {
        self.config.take().unwrap_or_else(|| super::extension::TypedExtensionConfig::new())
    }
}

impl ::protobuf::Message for FatalAction {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FatalAction {
        FatalAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::extension::TypedExtensionConfig>>(
                "config",
                |m: &FatalAction| { &m.config },
                |m: &mut FatalAction| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FatalAction>(
                "FatalAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FatalAction {
        static instance: ::protobuf::rt::LazyV2<FatalAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FatalAction::new)
    }
}

impl ::protobuf::Clear for FatalAction {
    fn clear(&mut self) {
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FatalAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FatalAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Runtime {
    // message fields
    pub symlink_root: ::std::string::String,
    pub subdirectory: ::std::string::String,
    pub override_subdirectory: ::std::string::String,
    pub base: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Runtime {
    fn default() -> &'a Runtime {
        <Runtime as ::protobuf::Message>::default_instance()
    }
}

impl Runtime {
    pub fn new() -> Runtime {
        ::std::default::Default::default()
    }

    // string symlink_root = 1;


    pub fn get_symlink_root(&self) -> &str {
        &self.symlink_root
    }
    pub fn clear_symlink_root(&mut self) {
        self.symlink_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_symlink_root(&mut self, v: ::std::string::String) {
        self.symlink_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink_root(&mut self) -> &mut ::std::string::String {
        &mut self.symlink_root
    }

    // Take field
    pub fn take_symlink_root(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symlink_root, ::std::string::String::new())
    }

    // string subdirectory = 2;


    pub fn get_subdirectory(&self) -> &str {
        &self.subdirectory
    }
    pub fn clear_subdirectory(&mut self) {
        self.subdirectory.clear();
    }

    // Param is passed by value, moved
    pub fn set_subdirectory(&mut self, v: ::std::string::String) {
        self.subdirectory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdirectory(&mut self) -> &mut ::std::string::String {
        &mut self.subdirectory
    }

    // Take field
    pub fn take_subdirectory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subdirectory, ::std::string::String::new())
    }

    // string override_subdirectory = 3;


    pub fn get_override_subdirectory(&self) -> &str {
        &self.override_subdirectory
    }
    pub fn clear_override_subdirectory(&mut self) {
        self.override_subdirectory.clear();
    }

    // Param is passed by value, moved
    pub fn set_override_subdirectory(&mut self, v: ::std::string::String) {
        self.override_subdirectory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_override_subdirectory(&mut self) -> &mut ::std::string::String {
        &mut self.override_subdirectory
    }

    // Take field
    pub fn take_override_subdirectory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.override_subdirectory, ::std::string::String::new())
    }

    // .google.protobuf.Struct base = 4;


    pub fn get_base(&self) -> &::protobuf::well_known_types::Struct {
        self.base.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> ::protobuf::well_known_types::Struct {
        self.base.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for Runtime {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symlink_root)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subdirectory)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.override_subdirectory)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.symlink_root.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.symlink_root);
        }
        if !self.subdirectory.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subdirectory);
        }
        if !self.override_subdirectory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.override_subdirectory);
        }
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.symlink_root.is_empty() {
            os.write_string(1, &self.symlink_root)?;
        }
        if !self.subdirectory.is_empty() {
            os.write_string(2, &self.subdirectory)?;
        }
        if !self.override_subdirectory.is_empty() {
            os.write_string(3, &self.override_subdirectory)?;
        }
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Runtime {
        Runtime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "symlink_root",
                |m: &Runtime| { &m.symlink_root },
                |m: &mut Runtime| { &mut m.symlink_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subdirectory",
                |m: &Runtime| { &m.subdirectory },
                |m: &mut Runtime| { &mut m.subdirectory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "override_subdirectory",
                |m: &Runtime| { &m.override_subdirectory },
                |m: &mut Runtime| { &mut m.override_subdirectory },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "base",
                |m: &Runtime| { &m.base },
                |m: &mut Runtime| { &mut m.base },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Runtime>(
                "Runtime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Runtime {
        static instance: ::protobuf::rt::LazyV2<Runtime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Runtime::new)
    }
}

impl ::protobuf::Clear for Runtime {
    fn clear(&mut self) {
        self.symlink_root.clear();
        self.subdirectory.clear();
        self.override_subdirectory.clear();
        self.base.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Runtime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Runtime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub layer_specifier: ::std::option::Option<RuntimeLayer_oneof_layer_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer {
    fn default() -> &'a RuntimeLayer {
        <RuntimeLayer as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RuntimeLayer_oneof_layer_specifier {
    static_layer(::protobuf::well_known_types::Struct),
    disk_layer(RuntimeLayer_DiskLayer),
    admin_layer(RuntimeLayer_AdminLayer),
    rtds_layer(RuntimeLayer_RtdsLayer),
}

impl RuntimeLayer {
    pub fn new() -> RuntimeLayer {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct static_layer = 2;


    pub fn get_static_layer(&self) -> &::protobuf::well_known_types::Struct {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(ref v)) => v,
            _ => <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_static_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_static_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_static_layer(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_static_layer(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(::protobuf::well_known_types::Struct::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_static_layer(&mut self) -> ::protobuf::well_known_types::Struct {
        if self.has_static_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Struct::new()
        }
    }

    // .envoy.config.bootstrap.v4alpha.RuntimeLayer.DiskLayer disk_layer = 3;


    pub fn get_disk_layer(&self) -> &RuntimeLayer_DiskLayer {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(ref v)) => v,
            _ => <RuntimeLayer_DiskLayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_disk_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_disk_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_disk_layer(&mut self, v: RuntimeLayer_DiskLayer) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_disk_layer(&mut self) -> &mut RuntimeLayer_DiskLayer {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(RuntimeLayer_DiskLayer::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_disk_layer(&mut self) -> RuntimeLayer_DiskLayer {
        if self.has_disk_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeLayer_DiskLayer::new()
        }
    }

    // .envoy.config.bootstrap.v4alpha.RuntimeLayer.AdminLayer admin_layer = 4;


    pub fn get_admin_layer(&self) -> &RuntimeLayer_AdminLayer {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(ref v)) => v,
            _ => <RuntimeLayer_AdminLayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_admin_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_admin_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_admin_layer(&mut self, v: RuntimeLayer_AdminLayer) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_admin_layer(&mut self) -> &mut RuntimeLayer_AdminLayer {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(RuntimeLayer_AdminLayer::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_admin_layer(&mut self) -> RuntimeLayer_AdminLayer {
        if self.has_admin_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeLayer_AdminLayer::new()
        }
    }

    // .envoy.config.bootstrap.v4alpha.RuntimeLayer.RtdsLayer rtds_layer = 5;


    pub fn get_rtds_layer(&self) -> &RuntimeLayer_RtdsLayer {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v)) => v,
            _ => <RuntimeLayer_RtdsLayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rtds_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_rtds_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rtds_layer(&mut self, v: RuntimeLayer_RtdsLayer) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rtds_layer(&mut self) -> &mut RuntimeLayer_RtdsLayer {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(RuntimeLayer_RtdsLayer::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rtds_layer(&mut self) -> RuntimeLayer_RtdsLayer {
        if self.has_rtds_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeLayer_RtdsLayer::new()
        }
    }
}

impl ::protobuf::Message for RuntimeLayer {
    fn is_initialized(&self) -> bool {
        if let Some(RuntimeLayer_oneof_layer_specifier::static_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RuntimeLayer_oneof_layer_specifier::disk_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RuntimeLayer_oneof_layer_specifier::admin_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.layer_specifier {
            match v {
                &RuntimeLayer_oneof_layer_specifier::static_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RuntimeLayer_oneof_layer_specifier::disk_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RuntimeLayer_oneof_layer_specifier::admin_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.layer_specifier {
            match v {
                &RuntimeLayer_oneof_layer_specifier::static_layer(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RuntimeLayer_oneof_layer_specifier::disk_layer(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RuntimeLayer_oneof_layer_specifier::admin_layer(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer {
        RuntimeLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RuntimeLayer| { &m.name },
                |m: &mut RuntimeLayer| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Struct>(
                "static_layer",
                RuntimeLayer::has_static_layer,
                RuntimeLayer::get_static_layer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeLayer_DiskLayer>(
                "disk_layer",
                RuntimeLayer::has_disk_layer,
                RuntimeLayer::get_disk_layer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeLayer_AdminLayer>(
                "admin_layer",
                RuntimeLayer::has_admin_layer,
                RuntimeLayer::get_admin_layer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeLayer_RtdsLayer>(
                "rtds_layer",
                RuntimeLayer::has_rtds_layer,
                RuntimeLayer::get_rtds_layer,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer>(
                "RuntimeLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer {
    fn clear(&mut self) {
        self.name.clear();
        self.layer_specifier = ::std::option::Option::None;
        self.layer_specifier = ::std::option::Option::None;
        self.layer_specifier = ::std::option::Option::None;
        self.layer_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer_DiskLayer {
    // message fields
    pub symlink_root: ::std::string::String,
    pub subdirectory: ::std::string::String,
    pub append_service_cluster: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer_DiskLayer {
    fn default() -> &'a RuntimeLayer_DiskLayer {
        <RuntimeLayer_DiskLayer as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeLayer_DiskLayer {
    pub fn new() -> RuntimeLayer_DiskLayer {
        ::std::default::Default::default()
    }

    // string symlink_root = 1;


    pub fn get_symlink_root(&self) -> &str {
        &self.symlink_root
    }
    pub fn clear_symlink_root(&mut self) {
        self.symlink_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_symlink_root(&mut self, v: ::std::string::String) {
        self.symlink_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink_root(&mut self) -> &mut ::std::string::String {
        &mut self.symlink_root
    }

    // Take field
    pub fn take_symlink_root(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symlink_root, ::std::string::String::new())
    }

    // string subdirectory = 3;


    pub fn get_subdirectory(&self) -> &str {
        &self.subdirectory
    }
    pub fn clear_subdirectory(&mut self) {
        self.subdirectory.clear();
    }

    // Param is passed by value, moved
    pub fn set_subdirectory(&mut self, v: ::std::string::String) {
        self.subdirectory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdirectory(&mut self) -> &mut ::std::string::String {
        &mut self.subdirectory
    }

    // Take field
    pub fn take_subdirectory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subdirectory, ::std::string::String::new())
    }

    // bool append_service_cluster = 2;


    pub fn get_append_service_cluster(&self) -> bool {
        self.append_service_cluster
    }
    pub fn clear_append_service_cluster(&mut self) {
        self.append_service_cluster = false;
    }

    // Param is passed by value, moved
    pub fn set_append_service_cluster(&mut self, v: bool) {
        self.append_service_cluster = v;
    }
}

impl ::protobuf::Message for RuntimeLayer_DiskLayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symlink_root)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subdirectory)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.append_service_cluster = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.symlink_root.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.symlink_root);
        }
        if !self.subdirectory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subdirectory);
        }
        if self.append_service_cluster != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.symlink_root.is_empty() {
            os.write_string(1, &self.symlink_root)?;
        }
        if !self.subdirectory.is_empty() {
            os.write_string(3, &self.subdirectory)?;
        }
        if self.append_service_cluster != false {
            os.write_bool(2, self.append_service_cluster)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer_DiskLayer {
        RuntimeLayer_DiskLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "symlink_root",
                |m: &RuntimeLayer_DiskLayer| { &m.symlink_root },
                |m: &mut RuntimeLayer_DiskLayer| { &mut m.symlink_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subdirectory",
                |m: &RuntimeLayer_DiskLayer| { &m.subdirectory },
                |m: &mut RuntimeLayer_DiskLayer| { &mut m.subdirectory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "append_service_cluster",
                |m: &RuntimeLayer_DiskLayer| { &m.append_service_cluster },
                |m: &mut RuntimeLayer_DiskLayer| { &mut m.append_service_cluster },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer_DiskLayer>(
                "RuntimeLayer.DiskLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer_DiskLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer_DiskLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer_DiskLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer_DiskLayer {
    fn clear(&mut self) {
        self.symlink_root.clear();
        self.subdirectory.clear();
        self.append_service_cluster = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer_DiskLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer_DiskLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer_AdminLayer {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer_AdminLayer {
    fn default() -> &'a RuntimeLayer_AdminLayer {
        <RuntimeLayer_AdminLayer as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeLayer_AdminLayer {
    pub fn new() -> RuntimeLayer_AdminLayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RuntimeLayer_AdminLayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer_AdminLayer {
        RuntimeLayer_AdminLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer_AdminLayer>(
                "RuntimeLayer.AdminLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer_AdminLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer_AdminLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer_AdminLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer_AdminLayer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer_AdminLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer_AdminLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer_RtdsLayer {
    // message fields
    pub name: ::std::string::String,
    pub rtds_config: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer_RtdsLayer {
    fn default() -> &'a RuntimeLayer_RtdsLayer {
        <RuntimeLayer_RtdsLayer as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeLayer_RtdsLayer {
    pub fn new() -> RuntimeLayer_RtdsLayer {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.config.core.v4alpha.ConfigSource rtds_config = 2;


    pub fn get_rtds_config(&self) -> &super::config_source::ConfigSource {
        self.rtds_config.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rtds_config(&mut self) {
        self.rtds_config.clear();
    }

    pub fn has_rtds_config(&self) -> bool {
        self.rtds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtds_config(&mut self, v: super::config_source::ConfigSource) {
        self.rtds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtds_config(&mut self) -> &mut super::config_source::ConfigSource {
        if self.rtds_config.is_none() {
            self.rtds_config.set_default();
        }
        self.rtds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_rtds_config(&mut self) -> super::config_source::ConfigSource {
        self.rtds_config.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }
}

impl ::protobuf::Message for RuntimeLayer_RtdsLayer {
    fn is_initialized(&self) -> bool {
        for v in &self.rtds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rtds_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.rtds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.rtds_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer_RtdsLayer {
        RuntimeLayer_RtdsLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RuntimeLayer_RtdsLayer| { &m.name },
                |m: &mut RuntimeLayer_RtdsLayer| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "rtds_config",
                |m: &RuntimeLayer_RtdsLayer| { &m.rtds_config },
                |m: &mut RuntimeLayer_RtdsLayer| { &mut m.rtds_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer_RtdsLayer>(
                "RuntimeLayer.RtdsLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer_RtdsLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer_RtdsLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer_RtdsLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer_RtdsLayer {
    fn clear(&mut self) {
        self.name.clear();
        self.rtds_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer_RtdsLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer_RtdsLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LayeredRuntime {
    // message fields
    pub layers: ::protobuf::RepeatedField<RuntimeLayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LayeredRuntime {
    fn default() -> &'a LayeredRuntime {
        <LayeredRuntime as ::protobuf::Message>::default_instance()
    }
}

impl LayeredRuntime {
    pub fn new() -> LayeredRuntime {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.bootstrap.v4alpha.RuntimeLayer layers = 1;


    pub fn get_layers(&self) -> &[RuntimeLayer] {
        &self.layers
    }
    pub fn clear_layers(&mut self) {
        self.layers.clear();
    }

    // Param is passed by value, moved
    pub fn set_layers(&mut self, v: ::protobuf::RepeatedField<RuntimeLayer>) {
        self.layers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_layers(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeLayer> {
        &mut self.layers
    }

    // Take field
    pub fn take_layers(&mut self) -> ::protobuf::RepeatedField<RuntimeLayer> {
        ::std::mem::replace(&mut self.layers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LayeredRuntime {
    fn is_initialized(&self) -> bool {
        for v in &self.layers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.layers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.layers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.layers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LayeredRuntime {
        LayeredRuntime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeLayer>>(
                "layers",
                |m: &LayeredRuntime| { &m.layers },
                |m: &mut LayeredRuntime| { &mut m.layers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LayeredRuntime>(
                "LayeredRuntime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LayeredRuntime {
        static instance: ::protobuf::rt::LazyV2<LayeredRuntime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LayeredRuntime::new)
    }
}

impl ::protobuf::Clear for LayeredRuntime {
    fn clear(&mut self) {
        self.layers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LayeredRuntime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LayeredRuntime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n.envoy/config/bootstrap/v4alpha/bootstrap.proto\x12\x1eenvoy.config.bo\
    otstrap.v4alpha\x1a*envoy/config/cluster/v4alpha/cluster.proto\x1a'envoy\
    /config/core/v4alpha/address.proto\x1a$envoy/config/core/v4alpha/base.pr\
    oto\x1a-envoy/config/core/v4alpha/config_source.proto\x1a4envoy/config/c\
    ore/v4alpha/event_service_config.proto\x1a)envoy/config/core/v4alpha/ext\
    ension.proto\x1a-envoy/config/core/v4alpha/socket_option.proto\x1a,envoy\
    /config/listener/v4alpha/listener.proto\x1a(envoy/config/metrics/v4alpha\
    /stats.proto\x1a'envoy/config/overload/v3/overload.proto\x1a;envoy/exten\
    sions/transport_sockets/tls/v4alpha/secret.proto\x1a\x1benvoy/type/v3/pe\
    rcent.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/protobuf\
    /struct.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a#envoy/annotation\
    s/deprecation.proto\x1a\x1fudpa/annotations/security.proto\x1a\x1dudpa/a\
    nnotations/status.proto\x1a!udpa/annotations/versioning.proto\x1a\x17val\
    idate/validate.proto\"\x8e\x16\n\tBootstrap\x123\n\x04node\x18\x01\x20\
    \x01(\x0b2\x1f.envoy.config.core.v4alpha.NodeR\x04node\x12.\n\x13node_co\
    ntext_params\x18\x1a\x20\x03(\tR\x11nodeContextParams\x12d\n\x10static_r\
    esources\x18\x02\x20\x01(\x0b29.envoy.config.bootstrap.v4alpha.Bootstrap\
    .StaticResourcesR\x0fstaticResources\x12g\n\x11dynamic_resources\x18\x03\
    \x20\x01(\x0b2:.envoy.config.bootstrap.v4alpha.Bootstrap.DynamicResource\
    sR\x10dynamicResources\x12W\n\x0fcluster_manager\x18\x04\x20\x01(\x0b2..\
    envoy.config.bootstrap.v4alpha.ClusterManagerR\x0eclusterManager\x12I\n\
    \nhds_config\x18\x0e\x20\x01(\x0b2*.envoy.config.core.v4alpha.ApiConfigS\
    ourceR\thdsConfig\x12\x1d\n\nflags_path\x18\x05\x20\x01(\tR\tflagsPath\
    \x12H\n\x0bstats_sinks\x18\x06\x20\x03(\x0b2'.envoy.config.metrics.v4alp\
    ha.StatsSinkR\nstatsSinks\x12L\n\x0cstats_config\x18\r\x20\x01(\x0b2).en\
    voy.config.metrics.v4alpha.StatsConfigR\x0bstatsConfig\x12^\n\x14stats_f\
    lush_interval\x18\x07\x20\x01(\x0b2\x19.google.protobuf.DurationR\x12sta\
    tsFlushIntervalB\x11\xfaB\x0e\xaa\x01\x0b\x1a\x03\x08\xac\x022\x04\x10\
    \xc0\x84=\x12G\n\twatchdogs\x18\x1b\x20\x01(\x0b2).envoy.config.bootstra\
    p.v4alpha.WatchdogsR\twatchdogs\x12W\n\x0flayered_runtime\x18\x11\x20\
    \x01(\x0b2..envoy.config.bootstrap.v4alpha.LayeredRuntimeR\x0elayeredRun\
    time\x12;\n\x05admin\x18\x0c\x20\x01(\x0b2%.envoy.config.bootstrap.v4alp\
    ha.AdminR\x05admin\x12d\n\x10overload_manager\x18\x0f\x20\x01(\x0b2).env\
    oy.config.overload.v3.OverloadManagerR\x0foverloadManagerB\x0e\x8a\x93\
    \xb7*\x02\x08\x01\x8a\x93\xb7*\x02\x10\x01\x126\n\x17enable_dispatcher_s\
    tats\x18\x10\x20\x01(\x08R\x15enableDispatcherStats\x12#\n\rheader_prefi\
    x\x18\x12\x20\x01(\tR\x0cheaderPrefix\x12_\n\x1dstats_server_version_ove\
    rride\x18\x13\x20\x01(\x0b2\x1c.google.protobuf.UInt64ValueR\x1astatsSer\
    verVersionOverride\x124\n\x17use_tcp_for_dns_lookups\x18\x14\x20\x01(\
    \x08R\x13useTcpForDnsLookups\x12b\n\x14bootstrap_extensions\x18\x15\x20\
    \x03(\x0b2/.envoy.config.core.v4alpha.TypedExtensionConfigR\x13bootstrap\
    Extensions\x12P\n\rfatal_actions\x18\x1c\x20\x03(\x0b2+.envoy.config.boo\
    tstrap.v4alpha.FatalActionR\x0cfatalActions\x12N\n\x0econfig_sources\x18\
    \x16\x20\x03(\x0b2'.envoy.config.core.v4alpha.ConfigSourceR\rconfigSourc\
    es\x12[\n\x15default_config_source\x18\x17\x20\x01(\x0b2'.envoy.config.c\
    ore.v4alpha.ConfigSourceR\x13defaultConfigSource\x128\n\x18default_socke\
    t_interface\x18\x18\x20\x01(\tR\x16defaultSocketInterface\x12\x91\x01\n\
    \x1ecertificate_provider_instances\x18\x19\x20\x03(\x0b2K.envoy.config.b\
    ootstrap.v4alpha.Bootstrap.CertificateProviderInstancesEntryR\x1ccertifi\
    cateProviderInstances\x1a\xa9\x02\n\x0fStaticResources\x12E\n\tlisteners\
    \x18\x01\x20\x03(\x0b2'.envoy.config.listener.v4alpha.ListenerR\tlistene\
    rs\x12A\n\x08clusters\x18\x02\x20\x03(\x0b2%.envoy.config.cluster.v4alph\
    a.ClusterR\x08clusters\x12P\n\x07secrets\x18\x03\x20\x03(\x0b26.envoy.ex\
    tensions.transport_sockets.tls.v4alpha.SecretR\x07secrets::\x9a\xc5\x88\
    \x1e5\n3envoy.config.bootstrap.v3.Bootstrap.StaticResources\x1a\x98\x03\
    \n\x10DynamicResources\x12F\n\nlds_config\x18\x01\x20\x01(\x0b2'.envoy.c\
    onfig.core.v4alpha.ConfigSourceR\tldsConfig\x122\n\x15lds_resources_loca\
    tor\x18\x05\x20\x01(\tR\x13ldsResourcesLocator\x12F\n\ncds_config\x18\
    \x02\x20\x01(\x0b2'.envoy.config.core.v4alpha.ConfigSourceR\tcdsConfig\
    \x122\n\x15cds_resources_locator\x18\x06\x20\x01(\tR\x13cdsResourcesLoca\
    tor\x12I\n\nads_config\x18\x03\x20\x01(\x0b2*.envoy.config.core.v4alpha.\
    ApiConfigSourceR\tadsConfig:;\x9a\xc5\x88\x1e6\n4envoy.config.bootstrap.\
    v3.Bootstrap.DynamicResourcesJ\x04\x08\x04\x10\x05\x1a\x80\x01\n!Certifi\
    cateProviderInstancesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12E\n\x05value\x18\x02\x20\x01(\x0b2/.envoy.config.core.v4alpha.TypedE\
    xtensionConfigR\x05value:\x028\x01:*\x9a\xc5\x88\x1e%\n#envoy.config.boo\
    tstrap.v3.BootstrapJ\x04\x08\n\x10\x0bJ\x04\x08\x0b\x10\x0cJ\x04\x08\x08\
    \x10\tJ\x04\x08\t\x10\nR\x07runtimeR\x08watchdogR\x07tracing\"\x88\x02\n\
    \x05Admin\x12&\n\x0faccess_log_path\x18\x01\x20\x01(\tR\raccessLogPath\
    \x12!\n\x0cprofile_path\x18\x02\x20\x01(\tR\x0bprofilePath\x12<\n\x07add\
    ress\x18\x03\x20\x01(\x0b2\".envoy.config.core.v4alpha.AddressR\x07addre\
    ss\x12N\n\x0esocket_options\x18\x04\x20\x03(\x0b2'.envoy.config.core.v4a\
    lpha.SocketOptionR\rsocketOptions:&\x9a\xc5\x88\x1e!\n\x1fenvoy.config.b\
    ootstrap.v3.Admin\"\xdf\x04\n\x0eClusterManager\x12,\n\x12local_cluster_\
    name\x18\x01\x20\x01(\tR\x10localClusterName\x12l\n\x11outlier_detection\
    \x18\x02\x20\x01(\x0b2?.envoy.config.bootstrap.v4alpha.ClusterManager.Ou\
    tlierDetectionR\x10outlierDetection\x12W\n\x14upstream_bind_config\x18\
    \x03\x20\x01(\x0b2%.envoy.config.core.v4alpha.BindConfigR\x12upstreamBin\
    dConfig\x12V\n\x11load_stats_config\x18\x04\x20\x01(\x0b2*.envoy.config.\
    core.v4alpha.ApiConfigSourceR\x0floadStatsConfig\x1a\xce\x01\n\x10Outlie\
    rDetection\x12$\n\x0eevent_log_path\x18\x01\x20\x01(\tR\x0ceventLogPath\
    \x12R\n\revent_service\x18\x02\x20\x01(\x0b2-.envoy.config.core.v4alpha.\
    EventServiceConfigR\x0ceventService:@\x9a\xc5\x88\x1e;\n9envoy.config.bo\
    otstrap.v3.ClusterManager.OutlierDetection:/\x9a\xc5\x88\x1e*\n(envoy.co\
    nfig.bootstrap.v3.ClusterManager\"\xe6\x01\n\tWatchdogs\x12Z\n\x14main_t\
    hread_watchdog\x18\x01\x20\x01(\x0b2(.envoy.config.bootstrap.v4alpha.Wat\
    chdogR\x12mainThreadWatchdog\x12Q\n\x0fworker_watchdog\x18\x02\x20\x01(\
    \x0b2(.envoy.config.bootstrap.v4alpha.WatchdogR\x0eworkerWatchdog:*\x9a\
    \xc5\x88\x1e%\n#envoy.config.bootstrap.v3.Watchdogs\"\x83\x07\n\x08Watch\
    dog\x12Q\n\x07actions\x18\x07\x20\x03(\x0b27.envoy.config.bootstrap.v4al\
    pha.Watchdog.WatchdogActionR\x07actions\x12<\n\x0cmiss_timeout\x18\x01\
    \x20\x01(\x0b2\x19.google.protobuf.DurationR\x0bmissTimeout\x12D\n\x10me\
    gamiss_timeout\x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0fme\
    gamissTimeout\x12<\n\x0ckill_timeout\x18\x03\x20\x01(\x0b2\x19.google.pr\
    otobuf.DurationR\x0bkillTimeout\x12Z\n\x17max_kill_timeout_jitter\x18\
    \x06\x20\x01(\x0b2\x19.google.protobuf.DurationR\x14maxKillTimeoutJitter\
    B\x08\xfaB\x05\xaa\x01\x022\0\x12F\n\x11multikill_timeout\x18\x04\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x10multikillTimeout\x12G\n\x13m\
    ultikill_threshold\x18\x05\x20\x01(\x0b2\x16.envoy.type.v3.PercentR\x12m\
    ultikillThreshold\x1a\xc9\x02\n\x0eWatchdogAction\x12G\n\x06config\x18\
    \x01\x20\x01(\x0b2/.envoy.config.core.v4alpha.TypedExtensionConfigR\x06c\
    onfig\x12e\n\x05event\x18\x02\x20\x01(\x0e2E.envoy.config.bootstrap.v4al\
    pha.Watchdog.WatchdogAction.WatchdogEventR\x05eventB\x08\xfaB\x05\x82\
    \x01\x02\x10\x01\"M\n\rWatchdogEvent\x12\x0b\n\x07UNKNOWN\x10\0\x12\x08\
    \n\x04KILL\x10\x01\x12\r\n\tMULTIKILL\x10\x02\x12\x0c\n\x08MEGAMISS\x10\
    \x03\x12\x08\n\x04MISS\x10\x04:8\x9a\xc5\x88\x1e3\n1envoy.config.bootstr\
    ap.v3.Watchdog.WatchdogAction:)\x9a\xc5\x88\x1e$\n\"envoy.config.bootstr\
    ap.v3.Watchdog\"\x84\x01\n\x0bFatalAction\x12G\n\x06config\x18\x01\x20\
    \x01(\x0b2/.envoy.config.core.v4alpha.TypedExtensionConfigR\x06config:,\
    \x9a\xc5\x88\x1e'\n%envoy.config.bootstrap.v3.FatalAction\"\xdc\x01\n\
    \x07Runtime\x12!\n\x0csymlink_root\x18\x01\x20\x01(\tR\x0bsymlinkRoot\
    \x12\"\n\x0csubdirectory\x18\x02\x20\x01(\tR\x0csubdirectory\x123\n\x15o\
    verride_subdirectory\x18\x03\x20\x01(\tR\x14overrideSubdirectory\x12+\n\
    \x04base\x18\x04\x20\x01(\x0b2\x17.google.protobuf.StructR\x04base:(\x9a\
    \xc5\x88\x1e#\n!envoy.config.bootstrap.v3.Runtime\"\xef\x06\n\x0cRuntime\
    Layer\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\
    \x10\x01\x12<\n\x0cstatic_layer\x18\x02\x20\x01(\x0b2\x17.google.protobu\
    f.StructH\0R\x0bstaticLayer\x12W\n\ndisk_layer\x18\x03\x20\x01(\x0b26.en\
    voy.config.bootstrap.v4alpha.RuntimeLayer.DiskLayerH\0R\tdiskLayer\x12Z\
    \n\x0badmin_layer\x18\x04\x20\x01(\x0b27.envoy.config.bootstrap.v4alpha.\
    RuntimeLayer.AdminLayerH\0R\nadminLayer\x12W\n\nrtds_layer\x18\x05\x20\
    \x01(\x0b26.envoy.config.bootstrap.v4alpha.RuntimeLayer.RtdsLayerH\0R\tr\
    tdsLayer\x1a\xc1\x01\n\tDiskLayer\x12!\n\x0csymlink_root\x18\x01\x20\x01\
    (\tR\x0bsymlinkRoot\x12\"\n\x0csubdirectory\x18\x03\x20\x01(\tR\x0csubdi\
    rectory\x124\n\x16append_service_cluster\x18\x02\x20\x01(\x08R\x14append\
    ServiceCluster:7\x9a\xc5\x88\x1e2\n0envoy.config.bootstrap.v3.RuntimeLay\
    er.DiskLayer\x1aF\n\nAdminLayer:8\x9a\xc5\x88\x1e3\n1envoy.config.bootst\
    rap.v3.RuntimeLayer.AdminLayer\x1a\xa2\x01\n\tRtdsLayer\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x12H\n\x0brtds_config\x18\x02\x20\x01(\x0b\
    2'.envoy.config.core.v4alpha.ConfigSourceR\nrtdsConfig:7\x9a\xc5\x88\x1e\
    2\n0envoy.config.bootstrap.v3.RuntimeLayer.RtdsLayerB\x16\n\x0flayer_spe\
    cifier\x12\x03\xf8B\x01:-\x9a\xc5\x88\x1e(\n&envoy.config.bootstrap.v3.R\
    untimeLayer\"\x87\x01\n\x0eLayeredRuntime\x12D\n\x06layers\x18\x01\x20\
    \x03(\x0b2,.envoy.config.bootstrap.v4alpha.RuntimeLayerR\x06layers:/\x9a\
    \xc5\x88\x1e*\n(envoy.config.bootstrap.v3.LayeredRuntimeBH\n,io.envoypro\
    xy.envoy.config.bootstrap.v4alphaB\x0eBootstrapProtoP\x01\xba\x80\xc8\
    \xd1\x06\x02\x10\x03b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
