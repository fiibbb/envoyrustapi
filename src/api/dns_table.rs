// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/data/dns/v4alpha/dns_table.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable {
    // message fields
    pub external_retry_count: u32,
    pub virtual_domains: ::protobuf::RepeatedField<DnsTable_DnsVirtualDomain>,
    pub known_suffixes: ::protobuf::RepeatedField<super::string::StringMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable {
    fn default() -> &'a DnsTable {
        <DnsTable as ::protobuf::Message>::default_instance()
    }
}

impl DnsTable {
    pub fn new() -> DnsTable {
        ::std::default::Default::default()
    }

    // uint32 external_retry_count = 1;


    pub fn get_external_retry_count(&self) -> u32 {
        self.external_retry_count
    }
    pub fn clear_external_retry_count(&mut self) {
        self.external_retry_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_external_retry_count(&mut self, v: u32) {
        self.external_retry_count = v;
    }

    // repeated .envoy.data.dns.v4alpha.DnsTable.DnsVirtualDomain virtual_domains = 2;


    pub fn get_virtual_domains(&self) -> &[DnsTable_DnsVirtualDomain] {
        &self.virtual_domains
    }
    pub fn clear_virtual_domains(&mut self) {
        self.virtual_domains.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtual_domains(&mut self, v: ::protobuf::RepeatedField<DnsTable_DnsVirtualDomain>) {
        self.virtual_domains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtual_domains(&mut self) -> &mut ::protobuf::RepeatedField<DnsTable_DnsVirtualDomain> {
        &mut self.virtual_domains
    }

    // Take field
    pub fn take_virtual_domains(&mut self) -> ::protobuf::RepeatedField<DnsTable_DnsVirtualDomain> {
        ::std::mem::replace(&mut self.virtual_domains, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.type.matcher.v4alpha.StringMatcher known_suffixes = 3;


    pub fn get_known_suffixes(&self) -> &[super::string::StringMatcher] {
        &self.known_suffixes
    }
    pub fn clear_known_suffixes(&mut self) {
        self.known_suffixes.clear();
    }

    // Param is passed by value, moved
    pub fn set_known_suffixes(&mut self, v: ::protobuf::RepeatedField<super::string::StringMatcher>) {
        self.known_suffixes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_known_suffixes(&mut self) -> &mut ::protobuf::RepeatedField<super::string::StringMatcher> {
        &mut self.known_suffixes
    }

    // Take field
    pub fn take_known_suffixes(&mut self) -> ::protobuf::RepeatedField<super::string::StringMatcher> {
        ::std::mem::replace(&mut self.known_suffixes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DnsTable {
    fn is_initialized(&self) -> bool {
        for v in &self.virtual_domains {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.known_suffixes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.external_retry_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtual_domains)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.known_suffixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.external_retry_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.external_retry_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.virtual_domains {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.known_suffixes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.external_retry_count != 0 {
            os.write_uint32(1, self.external_retry_count)?;
        }
        for v in &self.virtual_domains {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.known_suffixes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable {
        DnsTable::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "external_retry_count",
                |m: &DnsTable| { &m.external_retry_count },
                |m: &mut DnsTable| { &mut m.external_retry_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DnsTable_DnsVirtualDomain>>(
                "virtual_domains",
                |m: &DnsTable| { &m.virtual_domains },
                |m: &mut DnsTable| { &mut m.virtual_domains },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::StringMatcher>>(
                "known_suffixes",
                |m: &DnsTable| { &m.known_suffixes },
                |m: &mut DnsTable| { &mut m.known_suffixes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable>(
                "DnsTable",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable {
        static instance: ::protobuf::rt::LazyV2<DnsTable> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable::new)
    }
}

impl ::protobuf::Clear for DnsTable {
    fn clear(&mut self) {
        self.external_retry_count = 0;
        self.virtual_domains.clear();
        self.known_suffixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_AddressList {
    // message fields
    pub address: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_AddressList {
    fn default() -> &'a DnsTable_AddressList {
        <DnsTable_AddressList as ::protobuf::Message>::default_instance()
    }
}

impl DnsTable_AddressList {
    pub fn new() -> DnsTable_AddressList {
        ::std::default::Default::default()
    }

    // repeated string address = 1;


    pub fn get_address(&self) -> &[::std::string::String] {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.address = v;
    }

    // Mutable pointer to the field.
    pub fn mut_address(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.address, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DnsTable_AddressList {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.address {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.address {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_AddressList {
        DnsTable_AddressList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &DnsTable_AddressList| { &m.address },
                |m: &mut DnsTable_AddressList| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_AddressList>(
                "DnsTable.AddressList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_AddressList {
        static instance: ::protobuf::rt::LazyV2<DnsTable_AddressList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_AddressList::new)
    }
}

impl ::protobuf::Clear for DnsTable_AddressList {
    fn clear(&mut self) {
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_AddressList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_AddressList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_DnsServiceProtocol {
    // message oneof groups
    pub protocol_config: ::std::option::Option<DnsTable_DnsServiceProtocol_oneof_protocol_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_DnsServiceProtocol {
    fn default() -> &'a DnsTable_DnsServiceProtocol {
        <DnsTable_DnsServiceProtocol as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DnsTable_DnsServiceProtocol_oneof_protocol_config {
    number(u32),
    name(::std::string::String),
}

impl DnsTable_DnsServiceProtocol {
    pub fn new() -> DnsTable_DnsServiceProtocol {
        ::std::default::Default::default()
    }

    // uint32 number = 1;


    pub fn get_number(&self) -> u32 {
        match self.protocol_config {
            ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::number(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_number(&mut self) {
        self.protocol_config = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        match self.protocol_config {
            ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::number(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: u32) {
        self.protocol_config = ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::number(v))
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        match self.protocol_config {
            ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.protocol_config = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        match self.protocol_config {
            ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.protocol_config = ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(_)) = self.protocol_config {
        } else {
            self.protocol_config = ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(::std::string::String::new()));
        }
        match self.protocol_config {
            ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        if self.has_name() {
            match self.protocol_config.take() {
                ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }
}

impl ::protobuf::Message for DnsTable_DnsServiceProtocol {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.protocol_config = ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::number(is.read_uint32()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.protocol_config = ::std::option::Option::Some(DnsTable_DnsServiceProtocol_oneof_protocol_config::name(is.read_string()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.protocol_config {
            match v {
                &DnsTable_DnsServiceProtocol_oneof_protocol_config::number(v) => {
                    my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &DnsTable_DnsServiceProtocol_oneof_protocol_config::name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.protocol_config {
            match v {
                &DnsTable_DnsServiceProtocol_oneof_protocol_config::number(v) => {
                    os.write_uint32(1, v)?;
                },
                &DnsTable_DnsServiceProtocol_oneof_protocol_config::name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_DnsServiceProtocol {
        DnsTable_DnsServiceProtocol::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "number",
                DnsTable_DnsServiceProtocol::has_number,
                DnsTable_DnsServiceProtocol::get_number,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "name",
                DnsTable_DnsServiceProtocol::has_name,
                DnsTable_DnsServiceProtocol::get_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_DnsServiceProtocol>(
                "DnsTable.DnsServiceProtocol",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_DnsServiceProtocol {
        static instance: ::protobuf::rt::LazyV2<DnsTable_DnsServiceProtocol> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_DnsServiceProtocol::new)
    }
}

impl ::protobuf::Clear for DnsTable_DnsServiceProtocol {
    fn clear(&mut self) {
        self.protocol_config = ::std::option::Option::None;
        self.protocol_config = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_DnsServiceProtocol {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_DnsServiceProtocol {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_DnsServiceTarget {
    // message fields
    pub priority: u32,
    pub weight: u32,
    pub port: u32,
    // message oneof groups
    pub endpoint_type: ::std::option::Option<DnsTable_DnsServiceTarget_oneof_endpoint_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_DnsServiceTarget {
    fn default() -> &'a DnsTable_DnsServiceTarget {
        <DnsTable_DnsServiceTarget as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DnsTable_DnsServiceTarget_oneof_endpoint_type {
    host_name(::std::string::String),
    cluster_name(::std::string::String),
}

impl DnsTable_DnsServiceTarget {
    pub fn new() -> DnsTable_DnsServiceTarget {
        ::std::default::Default::default()
    }

    // string host_name = 1;


    pub fn get_host_name(&self) -> &str {
        match self.endpoint_type {
            ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_host_name(&mut self) {
        self.endpoint_type = ::std::option::Option::None;
    }

    pub fn has_host_name(&self) -> bool {
        match self.endpoint_type {
            ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_host_name(&mut self, v: ::std::string::String) {
        self.endpoint_type = ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_host_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(_)) = self.endpoint_type {
        } else {
            self.endpoint_type = ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(::std::string::String::new()));
        }
        match self.endpoint_type {
            ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_host_name(&mut self) -> ::std::string::String {
        if self.has_host_name() {
            match self.endpoint_type.take() {
                ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string cluster_name = 2;


    pub fn get_cluster_name(&self) -> &str {
        match self.endpoint_type {
            ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster_name(&mut self) {
        self.endpoint_type = ::std::option::Option::None;
    }

    pub fn has_cluster_name(&self) -> bool {
        match self.endpoint_type {
            ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_name(&mut self, v: ::std::string::String) {
        self.endpoint_type = ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(_)) = self.endpoint_type {
        } else {
            self.endpoint_type = ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(::std::string::String::new()));
        }
        match self.endpoint_type {
            ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_name(&mut self) -> ::std::string::String {
        if self.has_cluster_name() {
            match self.endpoint_type.take() {
                ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // uint32 priority = 3;


    pub fn get_priority(&self) -> u32 {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: u32) {
        self.priority = v;
    }

    // uint32 weight = 4;


    pub fn get_weight(&self) -> u32 {
        self.weight
    }
    pub fn clear_weight(&mut self) {
        self.weight = 0;
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: u32) {
        self.weight = v;
    }

    // uint32 port = 5;


    pub fn get_port(&self) -> u32 {
        self.port
    }
    pub fn clear_port(&mut self) {
        self.port = 0;
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: u32) {
        self.port = v;
    }
}

impl ::protobuf::Message for DnsTable_DnsServiceTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.endpoint_type = ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.endpoint_type = ::std::option::Option::Some(DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.priority = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.weight = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.priority != 0 {
            my_size += ::protobuf::rt::value_size(3, self.priority, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.weight != 0 {
            my_size += ::protobuf::rt::value_size(4, self.weight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.port != 0 {
            my_size += ::protobuf::rt::value_size(5, self.port, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.endpoint_type {
            match v {
                &DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.priority != 0 {
            os.write_uint32(3, self.priority)?;
        }
        if self.weight != 0 {
            os.write_uint32(4, self.weight)?;
        }
        if self.port != 0 {
            os.write_uint32(5, self.port)?;
        }
        if let ::std::option::Option::Some(ref v) = self.endpoint_type {
            match v {
                &DnsTable_DnsServiceTarget_oneof_endpoint_type::host_name(ref v) => {
                    os.write_string(1, v)?;
                },
                &DnsTable_DnsServiceTarget_oneof_endpoint_type::cluster_name(ref v) => {
                    os.write_string(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_DnsServiceTarget {
        DnsTable_DnsServiceTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "host_name",
                DnsTable_DnsServiceTarget::has_host_name,
                DnsTable_DnsServiceTarget::get_host_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster_name",
                DnsTable_DnsServiceTarget::has_cluster_name,
                DnsTable_DnsServiceTarget::get_cluster_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "priority",
                |m: &DnsTable_DnsServiceTarget| { &m.priority },
                |m: &mut DnsTable_DnsServiceTarget| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "weight",
                |m: &DnsTable_DnsServiceTarget| { &m.weight },
                |m: &mut DnsTable_DnsServiceTarget| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port",
                |m: &DnsTable_DnsServiceTarget| { &m.port },
                |m: &mut DnsTable_DnsServiceTarget| { &mut m.port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_DnsServiceTarget>(
                "DnsTable.DnsServiceTarget",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_DnsServiceTarget {
        static instance: ::protobuf::rt::LazyV2<DnsTable_DnsServiceTarget> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_DnsServiceTarget::new)
    }
}

impl ::protobuf::Clear for DnsTable_DnsServiceTarget {
    fn clear(&mut self) {
        self.endpoint_type = ::std::option::Option::None;
        self.endpoint_type = ::std::option::Option::None;
        self.priority = 0;
        self.weight = 0;
        self.port = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_DnsServiceTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_DnsServiceTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_DnsService {
    // message fields
    pub service_name: ::std::string::String,
    pub protocol: ::protobuf::SingularPtrField<DnsTable_DnsServiceProtocol>,
    pub ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub targets: ::protobuf::RepeatedField<DnsTable_DnsServiceTarget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_DnsService {
    fn default() -> &'a DnsTable_DnsService {
        <DnsTable_DnsService as ::protobuf::Message>::default_instance()
    }
}

impl DnsTable_DnsService {
    pub fn new() -> DnsTable_DnsService {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // .envoy.data.dns.v4alpha.DnsTable.DnsServiceProtocol protocol = 2;


    pub fn get_protocol(&self) -> &DnsTable_DnsServiceProtocol {
        self.protocol.as_ref().unwrap_or_else(|| <DnsTable_DnsServiceProtocol as ::protobuf::Message>::default_instance())
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: DnsTable_DnsServiceProtocol) {
        self.protocol = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut DnsTable_DnsServiceProtocol {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> DnsTable_DnsServiceProtocol {
        self.protocol.take().unwrap_or_else(|| DnsTable_DnsServiceProtocol::new())
    }

    // .google.protobuf.Duration ttl = 3;


    pub fn get_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.ttl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ttl(&mut self) {
        self.ttl.clear();
    }

    pub fn has_ttl(&self) -> bool {
        self.ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.ttl.is_none() {
            self.ttl.set_default();
        }
        self.ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // repeated .envoy.data.dns.v4alpha.DnsTable.DnsServiceTarget targets = 4;


    pub fn get_targets(&self) -> &[DnsTable_DnsServiceTarget] {
        &self.targets
    }
    pub fn clear_targets(&mut self) {
        self.targets.clear();
    }

    // Param is passed by value, moved
    pub fn set_targets(&mut self, v: ::protobuf::RepeatedField<DnsTable_DnsServiceTarget>) {
        self.targets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targets(&mut self) -> &mut ::protobuf::RepeatedField<DnsTable_DnsServiceTarget> {
        &mut self.targets
    }

    // Take field
    pub fn take_targets(&mut self) -> ::protobuf::RepeatedField<DnsTable_DnsServiceTarget> {
        ::std::mem::replace(&mut self.targets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DnsTable_DnsService {
    fn is_initialized(&self) -> bool {
        for v in &self.protocol {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.targets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ttl)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.targets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.targets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ttl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.targets {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_DnsService {
        DnsTable_DnsService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &DnsTable_DnsService| { &m.service_name },
                |m: &mut DnsTable_DnsService| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DnsTable_DnsServiceProtocol>>(
                "protocol",
                |m: &DnsTable_DnsService| { &m.protocol },
                |m: &mut DnsTable_DnsService| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "ttl",
                |m: &DnsTable_DnsService| { &m.ttl },
                |m: &mut DnsTable_DnsService| { &mut m.ttl },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DnsTable_DnsServiceTarget>>(
                "targets",
                |m: &DnsTable_DnsService| { &m.targets },
                |m: &mut DnsTable_DnsService| { &mut m.targets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_DnsService>(
                "DnsTable.DnsService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_DnsService {
        static instance: ::protobuf::rt::LazyV2<DnsTable_DnsService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_DnsService::new)
    }
}

impl ::protobuf::Clear for DnsTable_DnsService {
    fn clear(&mut self) {
        self.service_name.clear();
        self.protocol.clear();
        self.ttl.clear();
        self.targets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_DnsService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_DnsService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_DnsServiceList {
    // message fields
    pub services: ::protobuf::RepeatedField<DnsTable_DnsService>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_DnsServiceList {
    fn default() -> &'a DnsTable_DnsServiceList {
        <DnsTable_DnsServiceList as ::protobuf::Message>::default_instance()
    }
}

impl DnsTable_DnsServiceList {
    pub fn new() -> DnsTable_DnsServiceList {
        ::std::default::Default::default()
    }

    // repeated .envoy.data.dns.v4alpha.DnsTable.DnsService services = 1;


    pub fn get_services(&self) -> &[DnsTable_DnsService] {
        &self.services
    }
    pub fn clear_services(&mut self) {
        self.services.clear();
    }

    // Param is passed by value, moved
    pub fn set_services(&mut self, v: ::protobuf::RepeatedField<DnsTable_DnsService>) {
        self.services = v;
    }

    // Mutable pointer to the field.
    pub fn mut_services(&mut self) -> &mut ::protobuf::RepeatedField<DnsTable_DnsService> {
        &mut self.services
    }

    // Take field
    pub fn take_services(&mut self) -> ::protobuf::RepeatedField<DnsTable_DnsService> {
        ::std::mem::replace(&mut self.services, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DnsTable_DnsServiceList {
    fn is_initialized(&self) -> bool {
        for v in &self.services {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.services)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.services {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_DnsServiceList {
        DnsTable_DnsServiceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DnsTable_DnsService>>(
                "services",
                |m: &DnsTable_DnsServiceList| { &m.services },
                |m: &mut DnsTable_DnsServiceList| { &mut m.services },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_DnsServiceList>(
                "DnsTable.DnsServiceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_DnsServiceList {
        static instance: ::protobuf::rt::LazyV2<DnsTable_DnsServiceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_DnsServiceList::new)
    }
}

impl ::protobuf::Clear for DnsTable_DnsServiceList {
    fn clear(&mut self) {
        self.services.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_DnsServiceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_DnsServiceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_DnsEndpoint {
    // message oneof groups
    pub endpoint_config: ::std::option::Option<DnsTable_DnsEndpoint_oneof_endpoint_config>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_DnsEndpoint {
    fn default() -> &'a DnsTable_DnsEndpoint {
        <DnsTable_DnsEndpoint as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum DnsTable_DnsEndpoint_oneof_endpoint_config {
    address_list(DnsTable_AddressList),
    cluster_name(::std::string::String),
    service_list(DnsTable_DnsServiceList),
}

impl DnsTable_DnsEndpoint {
    pub fn new() -> DnsTable_DnsEndpoint {
        ::std::default::Default::default()
    }

    // .envoy.data.dns.v4alpha.DnsTable.AddressList address_list = 1;


    pub fn get_address_list(&self) -> &DnsTable_AddressList {
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(ref v)) => v,
            _ => <DnsTable_AddressList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_address_list(&mut self) {
        self.endpoint_config = ::std::option::Option::None;
    }

    pub fn has_address_list(&self) -> bool {
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_address_list(&mut self, v: DnsTable_AddressList) {
        self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_address_list(&mut self) -> &mut DnsTable_AddressList {
        if let ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(_)) = self.endpoint_config {
        } else {
            self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(DnsTable_AddressList::new()));
        }
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_address_list(&mut self) -> DnsTable_AddressList {
        if self.has_address_list() {
            match self.endpoint_config.take() {
                ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(v)) => v,
                _ => panic!(),
            }
        } else {
            DnsTable_AddressList::new()
        }
    }

    // string cluster_name = 2;


    pub fn get_cluster_name(&self) -> &str {
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster_name(&mut self) {
        self.endpoint_config = ::std::option::Option::None;
    }

    pub fn has_cluster_name(&self) -> bool {
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_name(&mut self, v: ::std::string::String) {
        self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(_)) = self.endpoint_config {
        } else {
            self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(::std::string::String::new()));
        }
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_name(&mut self) -> ::std::string::String {
        if self.has_cluster_name() {
            match self.endpoint_config.take() {
                ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.data.dns.v4alpha.DnsTable.DnsServiceList service_list = 3;


    pub fn get_service_list(&self) -> &DnsTable_DnsServiceList {
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(ref v)) => v,
            _ => <DnsTable_DnsServiceList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_service_list(&mut self) {
        self.endpoint_config = ::std::option::Option::None;
    }

    pub fn has_service_list(&self) -> bool {
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_service_list(&mut self, v: DnsTable_DnsServiceList) {
        self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(v))
    }

    // Mutable pointer to the field.
    pub fn mut_service_list(&mut self) -> &mut DnsTable_DnsServiceList {
        if let ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(_)) = self.endpoint_config {
        } else {
            self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(DnsTable_DnsServiceList::new()));
        }
        match self.endpoint_config {
            ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_service_list(&mut self) -> DnsTable_DnsServiceList {
        if self.has_service_list() {
            match self.endpoint_config.take() {
                ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(v)) => v,
                _ => panic!(),
            }
        } else {
            DnsTable_DnsServiceList::new()
        }
    }
}

impl ::protobuf::Message for DnsTable_DnsEndpoint {
    fn is_initialized(&self) -> bool {
        if let Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(ref v)) = self.endpoint_config {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(ref v)) = self.endpoint_config {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.endpoint_config = ::std::option::Option::Some(DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.endpoint_config {
            match v {
                &DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.endpoint_config {
            match v {
                &DnsTable_DnsEndpoint_oneof_endpoint_config::address_list(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &DnsTable_DnsEndpoint_oneof_endpoint_config::cluster_name(ref v) => {
                    os.write_string(2, v)?;
                },
                &DnsTable_DnsEndpoint_oneof_endpoint_config::service_list(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_DnsEndpoint {
        DnsTable_DnsEndpoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DnsTable_AddressList>(
                "address_list",
                DnsTable_DnsEndpoint::has_address_list,
                DnsTable_DnsEndpoint::get_address_list,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster_name",
                DnsTable_DnsEndpoint::has_cluster_name,
                DnsTable_DnsEndpoint::get_cluster_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DnsTable_DnsServiceList>(
                "service_list",
                DnsTable_DnsEndpoint::has_service_list,
                DnsTable_DnsEndpoint::get_service_list,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_DnsEndpoint>(
                "DnsTable.DnsEndpoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_DnsEndpoint {
        static instance: ::protobuf::rt::LazyV2<DnsTable_DnsEndpoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_DnsEndpoint::new)
    }
}

impl ::protobuf::Clear for DnsTable_DnsEndpoint {
    fn clear(&mut self) {
        self.endpoint_config = ::std::option::Option::None;
        self.endpoint_config = ::std::option::Option::None;
        self.endpoint_config = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_DnsEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_DnsEndpoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DnsTable_DnsVirtualDomain {
    // message fields
    pub name: ::std::string::String,
    pub endpoint: ::protobuf::SingularPtrField<DnsTable_DnsEndpoint>,
    pub answer_ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DnsTable_DnsVirtualDomain {
    fn default() -> &'a DnsTable_DnsVirtualDomain {
        <DnsTable_DnsVirtualDomain as ::protobuf::Message>::default_instance()
    }
}

impl DnsTable_DnsVirtualDomain {
    pub fn new() -> DnsTable_DnsVirtualDomain {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.data.dns.v4alpha.DnsTable.DnsEndpoint endpoint = 2;


    pub fn get_endpoint(&self) -> &DnsTable_DnsEndpoint {
        self.endpoint.as_ref().unwrap_or_else(|| <DnsTable_DnsEndpoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    pub fn has_endpoint(&self) -> bool {
        self.endpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: DnsTable_DnsEndpoint) {
        self.endpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut DnsTable_DnsEndpoint {
        if self.endpoint.is_none() {
            self.endpoint.set_default();
        }
        self.endpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoint(&mut self) -> DnsTable_DnsEndpoint {
        self.endpoint.take().unwrap_or_else(|| DnsTable_DnsEndpoint::new())
    }

    // .google.protobuf.Duration answer_ttl = 3;


    pub fn get_answer_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.answer_ttl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_answer_ttl(&mut self) {
        self.answer_ttl.clear();
    }

    pub fn has_answer_ttl(&self) -> bool {
        self.answer_ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.answer_ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_answer_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.answer_ttl.is_none() {
            self.answer_ttl.set_default();
        }
        self.answer_ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_answer_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.answer_ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for DnsTable_DnsVirtualDomain {
    fn is_initialized(&self) -> bool {
        for v in &self.endpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.answer_ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.endpoint)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.answer_ttl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.answer_ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.endpoint.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.answer_ttl.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DnsTable_DnsVirtualDomain {
        DnsTable_DnsVirtualDomain::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DnsTable_DnsVirtualDomain| { &m.name },
                |m: &mut DnsTable_DnsVirtualDomain| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DnsTable_DnsEndpoint>>(
                "endpoint",
                |m: &DnsTable_DnsVirtualDomain| { &m.endpoint },
                |m: &mut DnsTable_DnsVirtualDomain| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "answer_ttl",
                |m: &DnsTable_DnsVirtualDomain| { &m.answer_ttl },
                |m: &mut DnsTable_DnsVirtualDomain| { &mut m.answer_ttl },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DnsTable_DnsVirtualDomain>(
                "DnsTable.DnsVirtualDomain",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DnsTable_DnsVirtualDomain {
        static instance: ::protobuf::rt::LazyV2<DnsTable_DnsVirtualDomain> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DnsTable_DnsVirtualDomain::new)
    }
}

impl ::protobuf::Clear for DnsTable_DnsVirtualDomain {
    fn clear(&mut self) {
        self.name.clear();
        self.endpoint.clear();
        self.answer_ttl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DnsTable_DnsVirtualDomain {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DnsTable_DnsVirtualDomain {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&envoy/data/dns/v4alpha/dns_table.proto\x12\x16envoy.data.dns.v4alpha\
    \x1a'envoy/type/matcher/v4alpha/string.proto\x1a\x1egoogle/protobuf/dura\
    tion.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/ver\
    sioning.proto\x1a\x17validate/validate.proto\"\xd0\x0e\n\x08DnsTable\x12\
    9\n\x14external_retry_count\x18\x01\x20\x01(\rR\x12externalRetryCountB\
    \x07\xfaB\x04*\x02\x18\x03\x12Z\n\x0fvirtual_domains\x18\x02\x20\x03(\
    \x0b21.envoy.data.dns.v4alpha.DnsTable.DnsVirtualDomainR\x0evirtualDomai\
    ns\x12P\n\x0eknown_suffixes\x18\x03\x20\x03(\x0b2).envoy.type.matcher.v4\
    alpha.StringMatcherR\rknownSuffixes\x1af\n\x0bAddressList\x12(\n\x07addr\
    ess\x18\x01\x20\x03(\tR\x07addressB\x0e\xfaB\x0b\x92\x01\x08\x08\x01\"\
    \x04r\x02\x10\x03:-\x9a\xc5\x88\x1e(\n&envoy.data.dns.v3.DnsTable.Addres\
    sList\x1a\xa8\x01\n\x12DnsServiceProtocol\x12\"\n\x06number\x18\x01\x20\
    \x01(\rH\0R\x06numberB\x08\xfaB\x05*\x03\x10\xff\x01\x12\x20\n\x04name\
    \x18\x02\x20\x01(\tH\0R\x04nameB\n\xfaB\x07r\x05\x10\x01\xc0\x01\x01B\
    \x16\n\x0fprotocol_config\x12\x03\xf8B\x01:4\x9a\xc5\x88\x1e/\n-envoy.da\
    ta.dns.v3.DnsTable.DnsServiceProtocol\x1a\xa1\x02\n\x10DnsServiceTarget\
    \x12)\n\thost_name\x18\x01\x20\x01(\tH\0R\x08hostNameB\n\xfaB\x07r\x05\
    \x10\x01\xc0\x01\x01\x12/\n\x0ccluster_name\x18\x02\x20\x01(\tH\0R\x0bcl\
    usterNameB\n\xfaB\x07r\x05\x10\x01\xc0\x01\x01\x12%\n\x08priority\x18\
    \x03\x20\x01(\rR\x08priorityB\t\xfaB\x06*\x04\x10\x80\x80\x04\x12!\n\x06\
    weight\x18\x04\x20\x01(\rR\x06weightB\t\xfaB\x06*\x04\x10\x80\x80\x04\
    \x12\x1d\n\x04port\x18\x05\x20\x01(\rR\x04portB\t\xfaB\x06*\x04\x10\x80\
    \x80\x04B\x14\n\rendpoint_type\x12\x03\xf8B\x01:2\x9a\xc5\x88\x1e-\n+env\
    oy.data.dns.v3.DnsTable.DnsServiceTarget\x1a\xca\x02\n\nDnsService\x12-\
    \n\x0cservice_name\x18\x01\x20\x01(\tR\x0bserviceNameB\n\xfaB\x07r\x05\
    \x10\x01\xc0\x01\x01\x12O\n\x08protocol\x18\x02\x20\x01(\x0b23.envoy.dat\
    a.dns.v4alpha.DnsTable.DnsServiceProtocolR\x08protocol\x127\n\x03ttl\x18\
    \x03\x20\x01(\x0b2\x19.google.protobuf.DurationR\x03ttlB\n\xfaB\x07\xaa\
    \x01\x042\x02\x08\x01\x12U\n\x07targets\x18\x04\x20\x03(\x0b21.envoy.dat\
    a.dns.v4alpha.DnsTable.DnsServiceTargetR\x07targetsB\x08\xfaB\x05\x92\
    \x01\x02\x08\x01:,\x9a\xc5\x88\x1e'\n%envoy.data.dns.v3.DnsTable.DnsServ\
    ice\x1a\x95\x01\n\x0eDnsServiceList\x12Q\n\x08services\x18\x01\x20\x03(\
    \x0b2+.envoy.data.dns.v4alpha.DnsTable.DnsServiceR\x08servicesB\x08\xfaB\
    \x05\x92\x01\x02\x08\x01:0\x9a\xc5\x88\x1e+\n)envoy.data.dns.v3.DnsTable\
    .DnsServiceList\x1a\xa2\x02\n\x0bDnsEndpoint\x12Q\n\x0caddress_list\x18\
    \x01\x20\x01(\x0b2,.envoy.data.dns.v4alpha.DnsTable.AddressListH\0R\x0ba\
    ddressList\x12#\n\x0ccluster_name\x18\x02\x20\x01(\tH\0R\x0bclusterName\
    \x12T\n\x0cservice_list\x18\x03\x20\x01(\x0b2/.envoy.data.dns.v4alpha.Dn\
    sTable.DnsServiceListH\0R\x0bserviceListB\x16\n\x0fendpoint_config\x12\
    \x03\xf8B\x01:-\x9a\xc5\x88\x1e(\n&envoy.data.dns.v3.DnsTable.DnsEndpoin\
    t\x1a\xf6\x01\n\x10DnsVirtualDomain\x12\x1e\n\x04name\x18\x01\x20\x01(\t\
    R\x04nameB\n\xfaB\x07r\x05\x10\x01\xc0\x01\x01\x12H\n\x08endpoint\x18\
    \x02\x20\x01(\x0b2,.envoy.data.dns.v4alpha.DnsTable.DnsEndpointR\x08endp\
    oint\x12D\n\nanswer_ttl\x18\x03\x20\x01(\x0b2\x19.google.protobuf.Durati\
    onR\tanswerTtlB\n\xfaB\x07\xaa\x01\x042\x02\x08\x1e:2\x9a\xc5\x88\x1e-\n\
    +envoy.data.dns.v3.DnsTable.DnsVirtualDomain:!\x9a\xc5\x88\x1e\x1c\n\x1a\
    envoy.data.dns.v3.DnsTableB?\n$io.envoyproxy.envoy.data.dns.v4alphaB\rDn\
    sTableProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\x03b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
