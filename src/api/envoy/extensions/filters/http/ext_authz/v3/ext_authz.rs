// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct ExtAuthz {
    // message fields
    pub transport_api_version: super::config_source::ApiVersion,
    pub failure_mode_allow: bool,
    pub with_request_body: ::protobuf::SingularPtrField<BufferSettings>,
    pub clear_route_cache: bool,
    pub status_on_error: ::protobuf::SingularPtrField<super::http_status::HttpStatus>,
    pub metadata_context_namespaces: ::protobuf::RepeatedField<::std::string::String>,
    pub filter_enabled: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    pub filter_enabled_metadata: ::protobuf::SingularPtrField<super::metadata::MetadataMatcher>,
    pub deny_at_disable: ::protobuf::SingularPtrField<super::base::RuntimeFeatureFlag>,
    pub include_peer_certificate: bool,
    pub stat_prefix: ::std::string::String,
    // message oneof groups
    pub services: ::std::option::Option<ExtAuthz_oneof_services>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtAuthz {
    fn default() -> &'a ExtAuthz {
        <ExtAuthz as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExtAuthz_oneof_services {
    grpc_service(super::grpc_service::GrpcService),
    http_service(HttpService),
}

impl ExtAuthz {
    pub fn new() -> ExtAuthz {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.GrpcService grpc_service = 1;


    pub fn get_grpc_service(&self) -> &super::grpc_service::GrpcService {
        match self.services {
            ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(ref v)) => v,
            _ => <super::grpc_service::GrpcService as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_grpc_service(&mut self) {
        self.services = ::std::option::Option::None;
    }

    pub fn has_grpc_service(&self) -> bool {
        match self.services {
            ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_grpc_service(&mut self, v: super::grpc_service::GrpcService) {
        self.services = ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_grpc_service(&mut self) -> &mut super::grpc_service::GrpcService {
        if let ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(_)) = self.services {
        } else {
            self.services = ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(super::grpc_service::GrpcService::new()));
        }
        match self.services {
            ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_grpc_service(&mut self) -> super::grpc_service::GrpcService {
        if self.has_grpc_service() {
            match self.services.take() {
                ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(v)) => v,
                _ => panic!(),
            }
        } else {
            super::grpc_service::GrpcService::new()
        }
    }

    // .envoy.extensions.filters.http.ext_authz.v3.HttpService http_service = 3;


    pub fn get_http_service(&self) -> &HttpService {
        match self.services {
            ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(ref v)) => v,
            _ => <HttpService as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_http_service(&mut self) {
        self.services = ::std::option::Option::None;
    }

    pub fn has_http_service(&self) -> bool {
        match self.services {
            ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http_service(&mut self, v: HttpService) {
        self.services = ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http_service(&mut self) -> &mut HttpService {
        if let ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(_)) = self.services {
        } else {
            self.services = ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(HttpService::new()));
        }
        match self.services {
            ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http_service(&mut self) -> HttpService {
        if self.has_http_service() {
            match self.services.take() {
                ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpService::new()
        }
    }

    // .envoy.config.core.v3.ApiVersion transport_api_version = 12;


    pub fn get_transport_api_version(&self) -> super::config_source::ApiVersion {
        self.transport_api_version
    }
    pub fn clear_transport_api_version(&mut self) {
        self.transport_api_version = super::config_source::ApiVersion::AUTO;
    }

    // Param is passed by value, moved
    pub fn set_transport_api_version(&mut self, v: super::config_source::ApiVersion) {
        self.transport_api_version = v;
    }

    // bool failure_mode_allow = 2;


    pub fn get_failure_mode_allow(&self) -> bool {
        self.failure_mode_allow
    }
    pub fn clear_failure_mode_allow(&mut self) {
        self.failure_mode_allow = false;
    }

    // Param is passed by value, moved
    pub fn set_failure_mode_allow(&mut self, v: bool) {
        self.failure_mode_allow = v;
    }

    // .envoy.extensions.filters.http.ext_authz.v3.BufferSettings with_request_body = 5;


    pub fn get_with_request_body(&self) -> &BufferSettings {
        self.with_request_body.as_ref().unwrap_or_else(|| <BufferSettings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_with_request_body(&mut self) {
        self.with_request_body.clear();
    }

    pub fn has_with_request_body(&self) -> bool {
        self.with_request_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_with_request_body(&mut self, v: BufferSettings) {
        self.with_request_body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_with_request_body(&mut self) -> &mut BufferSettings {
        if self.with_request_body.is_none() {
            self.with_request_body.set_default();
        }
        self.with_request_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_with_request_body(&mut self) -> BufferSettings {
        self.with_request_body.take().unwrap_or_else(|| BufferSettings::new())
    }

    // bool clear_route_cache = 6;


    pub fn get_clear_route_cache(&self) -> bool {
        self.clear_route_cache
    }
    pub fn clear_clear_route_cache(&mut self) {
        self.clear_route_cache = false;
    }

    // Param is passed by value, moved
    pub fn set_clear_route_cache(&mut self, v: bool) {
        self.clear_route_cache = v;
    }

    // .envoy.type.v3.HttpStatus status_on_error = 7;


    pub fn get_status_on_error(&self) -> &super::http_status::HttpStatus {
        self.status_on_error.as_ref().unwrap_or_else(|| <super::http_status::HttpStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status_on_error(&mut self) {
        self.status_on_error.clear();
    }

    pub fn has_status_on_error(&self) -> bool {
        self.status_on_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_on_error(&mut self, v: super::http_status::HttpStatus) {
        self.status_on_error = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_on_error(&mut self) -> &mut super::http_status::HttpStatus {
        if self.status_on_error.is_none() {
            self.status_on_error.set_default();
        }
        self.status_on_error.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_on_error(&mut self) -> super::http_status::HttpStatus {
        self.status_on_error.take().unwrap_or_else(|| super::http_status::HttpStatus::new())
    }

    // repeated string metadata_context_namespaces = 8;


    pub fn get_metadata_context_namespaces(&self) -> &[::std::string::String] {
        &self.metadata_context_namespaces
    }
    pub fn clear_metadata_context_namespaces(&mut self) {
        self.metadata_context_namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata_context_namespaces(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.metadata_context_namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata_context_namespaces(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.metadata_context_namespaces
    }

    // Take field
    pub fn take_metadata_context_namespaces(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.metadata_context_namespaces, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.core.v3.RuntimeFractionalPercent filter_enabled = 9;


    pub fn get_filter_enabled(&self) -> &super::base::RuntimeFractionalPercent {
        self.filter_enabled.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter_enabled(&mut self) {
        self.filter_enabled.clear();
    }

    pub fn has_filter_enabled(&self) -> bool {
        self.filter_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_enabled(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.filter_enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_enabled(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.filter_enabled.is_none() {
            self.filter_enabled.set_default();
        }
        self.filter_enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_enabled(&mut self) -> super::base::RuntimeFractionalPercent {
        self.filter_enabled.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }

    // .envoy.type.matcher.v3.MetadataMatcher filter_enabled_metadata = 14;


    pub fn get_filter_enabled_metadata(&self) -> &super::metadata::MetadataMatcher {
        self.filter_enabled_metadata.as_ref().unwrap_or_else(|| <super::metadata::MetadataMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter_enabled_metadata(&mut self) {
        self.filter_enabled_metadata.clear();
    }

    pub fn has_filter_enabled_metadata(&self) -> bool {
        self.filter_enabled_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_enabled_metadata(&mut self, v: super::metadata::MetadataMatcher) {
        self.filter_enabled_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_enabled_metadata(&mut self) -> &mut super::metadata::MetadataMatcher {
        if self.filter_enabled_metadata.is_none() {
            self.filter_enabled_metadata.set_default();
        }
        self.filter_enabled_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_enabled_metadata(&mut self) -> super::metadata::MetadataMatcher {
        self.filter_enabled_metadata.take().unwrap_or_else(|| super::metadata::MetadataMatcher::new())
    }

    // .envoy.config.core.v3.RuntimeFeatureFlag deny_at_disable = 11;


    pub fn get_deny_at_disable(&self) -> &super::base::RuntimeFeatureFlag {
        self.deny_at_disable.as_ref().unwrap_or_else(|| <super::base::RuntimeFeatureFlag as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deny_at_disable(&mut self) {
        self.deny_at_disable.clear();
    }

    pub fn has_deny_at_disable(&self) -> bool {
        self.deny_at_disable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deny_at_disable(&mut self, v: super::base::RuntimeFeatureFlag) {
        self.deny_at_disable = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deny_at_disable(&mut self) -> &mut super::base::RuntimeFeatureFlag {
        if self.deny_at_disable.is_none() {
            self.deny_at_disable.set_default();
        }
        self.deny_at_disable.as_mut().unwrap()
    }

    // Take field
    pub fn take_deny_at_disable(&mut self) -> super::base::RuntimeFeatureFlag {
        self.deny_at_disable.take().unwrap_or_else(|| super::base::RuntimeFeatureFlag::new())
    }

    // bool include_peer_certificate = 10;


    pub fn get_include_peer_certificate(&self) -> bool {
        self.include_peer_certificate
    }
    pub fn clear_include_peer_certificate(&mut self) {
        self.include_peer_certificate = false;
    }

    // Param is passed by value, moved
    pub fn set_include_peer_certificate(&mut self, v: bool) {
        self.include_peer_certificate = v;
    }

    // string stat_prefix = 13;


    pub fn get_stat_prefix(&self) -> &str {
        &self.stat_prefix
    }
    pub fn clear_stat_prefix(&mut self) {
        self.stat_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_stat_prefix(&mut self, v: ::std::string::String) {
        self.stat_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stat_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.stat_prefix
    }

    // Take field
    pub fn take_stat_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.stat_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ExtAuthz {
    fn is_initialized(&self) -> bool {
        if let Some(ExtAuthz_oneof_services::grpc_service(ref v)) = self.services {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ExtAuthz_oneof_services::http_service(ref v)) = self.services {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.with_request_body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status_on_error {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filter_enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filter_enabled_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deny_at_disable {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.services = ::std::option::Option::Some(ExtAuthz_oneof_services::grpc_service(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.services = ::std::option::Option::Some(ExtAuthz_oneof_services::http_service(is.read_message()?));
                },
                12 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.transport_api_version, 12, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.failure_mode_allow = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.with_request_body)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clear_route_cache = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status_on_error)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.metadata_context_namespaces)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter_enabled)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter_enabled_metadata)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deny_at_disable)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_peer_certificate = tmp;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.stat_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.transport_api_version != super::config_source::ApiVersion::AUTO {
            my_size += ::protobuf::rt::enum_size(12, self.transport_api_version);
        }
        if self.failure_mode_allow != false {
            my_size += 2;
        }
        if let Some(ref v) = self.with_request_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.clear_route_cache != false {
            my_size += 2;
        }
        if let Some(ref v) = self.status_on_error.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.metadata_context_namespaces {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if let Some(ref v) = self.filter_enabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.filter_enabled_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deny_at_disable.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.include_peer_certificate != false {
            my_size += 2;
        }
        if !self.stat_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.stat_prefix);
        }
        if let ::std::option::Option::Some(ref v) = self.services {
            match v {
                &ExtAuthz_oneof_services::grpc_service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ExtAuthz_oneof_services::http_service(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.transport_api_version != super::config_source::ApiVersion::AUTO {
            os.write_enum(12, ::protobuf::ProtobufEnum::value(&self.transport_api_version))?;
        }
        if self.failure_mode_allow != false {
            os.write_bool(2, self.failure_mode_allow)?;
        }
        if let Some(ref v) = self.with_request_body.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.clear_route_cache != false {
            os.write_bool(6, self.clear_route_cache)?;
        }
        if let Some(ref v) = self.status_on_error.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.metadata_context_namespaces {
            os.write_string(8, &v)?;
        };
        if let Some(ref v) = self.filter_enabled.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.filter_enabled_metadata.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deny_at_disable.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.include_peer_certificate != false {
            os.write_bool(10, self.include_peer_certificate)?;
        }
        if !self.stat_prefix.is_empty() {
            os.write_string(13, &self.stat_prefix)?;
        }
        if let ::std::option::Option::Some(ref v) = self.services {
            match v {
                &ExtAuthz_oneof_services::grpc_service(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ExtAuthz_oneof_services::http_service(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtAuthz {
        ExtAuthz::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::grpc_service::GrpcService>(
                "grpc_service",
                ExtAuthz::has_grpc_service,
                ExtAuthz::get_grpc_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpService>(
                "http_service",
                ExtAuthz::has_http_service,
                ExtAuthz::get_http_service,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::config_source::ApiVersion>>(
                "transport_api_version",
                |m: &ExtAuthz| { &m.transport_api_version },
                |m: &mut ExtAuthz| { &mut m.transport_api_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "failure_mode_allow",
                |m: &ExtAuthz| { &m.failure_mode_allow },
                |m: &mut ExtAuthz| { &mut m.failure_mode_allow },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BufferSettings>>(
                "with_request_body",
                |m: &ExtAuthz| { &m.with_request_body },
                |m: &mut ExtAuthz| { &mut m.with_request_body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clear_route_cache",
                |m: &ExtAuthz| { &m.clear_route_cache },
                |m: &mut ExtAuthz| { &mut m.clear_route_cache },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http_status::HttpStatus>>(
                "status_on_error",
                |m: &ExtAuthz| { &m.status_on_error },
                |m: &mut ExtAuthz| { &mut m.status_on_error },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "metadata_context_namespaces",
                |m: &ExtAuthz| { &m.metadata_context_namespaces },
                |m: &mut ExtAuthz| { &mut m.metadata_context_namespaces },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "filter_enabled",
                |m: &ExtAuthz| { &m.filter_enabled },
                |m: &mut ExtAuthz| { &mut m.filter_enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::metadata::MetadataMatcher>>(
                "filter_enabled_metadata",
                |m: &ExtAuthz| { &m.filter_enabled_metadata },
                |m: &mut ExtAuthz| { &mut m.filter_enabled_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFeatureFlag>>(
                "deny_at_disable",
                |m: &ExtAuthz| { &m.deny_at_disable },
                |m: &mut ExtAuthz| { &mut m.deny_at_disable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_peer_certificate",
                |m: &ExtAuthz| { &m.include_peer_certificate },
                |m: &mut ExtAuthz| { &mut m.include_peer_certificate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "stat_prefix",
                |m: &ExtAuthz| { &m.stat_prefix },
                |m: &mut ExtAuthz| { &mut m.stat_prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtAuthz>(
                "ExtAuthz",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExtAuthz {
        static instance: ::protobuf::rt::LazyV2<ExtAuthz> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtAuthz::new)
    }
}

impl ::protobuf::Clear for ExtAuthz {
    fn clear(&mut self) {
        self.services = ::std::option::Option::None;
        self.services = ::std::option::Option::None;
        self.transport_api_version = super::config_source::ApiVersion::AUTO;
        self.failure_mode_allow = false;
        self.with_request_body.clear();
        self.clear_route_cache = false;
        self.status_on_error.clear();
        self.metadata_context_namespaces.clear();
        self.filter_enabled.clear();
        self.filter_enabled_metadata.clear();
        self.deny_at_disable.clear();
        self.include_peer_certificate = false;
        self.stat_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtAuthz {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtAuthz {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BufferSettings {
    // message fields
    pub max_request_bytes: u32,
    pub allow_partial_message: bool,
    pub pack_as_bytes: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BufferSettings {
    fn default() -> &'a BufferSettings {
        <BufferSettings as ::protobuf::Message>::default_instance()
    }
}

impl BufferSettings {
    pub fn new() -> BufferSettings {
        ::std::default::Default::default()
    }

    // uint32 max_request_bytes = 1;


    pub fn get_max_request_bytes(&self) -> u32 {
        self.max_request_bytes
    }
    pub fn clear_max_request_bytes(&mut self) {
        self.max_request_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_request_bytes(&mut self, v: u32) {
        self.max_request_bytes = v;
    }

    // bool allow_partial_message = 2;


    pub fn get_allow_partial_message(&self) -> bool {
        self.allow_partial_message
    }
    pub fn clear_allow_partial_message(&mut self) {
        self.allow_partial_message = false;
    }

    // Param is passed by value, moved
    pub fn set_allow_partial_message(&mut self, v: bool) {
        self.allow_partial_message = v;
    }

    // bool pack_as_bytes = 3;


    pub fn get_pack_as_bytes(&self) -> bool {
        self.pack_as_bytes
    }
    pub fn clear_pack_as_bytes(&mut self) {
        self.pack_as_bytes = false;
    }

    // Param is passed by value, moved
    pub fn set_pack_as_bytes(&mut self, v: bool) {
        self.pack_as_bytes = v;
    }
}

impl ::protobuf::Message for BufferSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.max_request_bytes = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allow_partial_message = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.pack_as_bytes = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_request_bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_request_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allow_partial_message != false {
            my_size += 2;
        }
        if self.pack_as_bytes != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_request_bytes != 0 {
            os.write_uint32(1, self.max_request_bytes)?;
        }
        if self.allow_partial_message != false {
            os.write_bool(2, self.allow_partial_message)?;
        }
        if self.pack_as_bytes != false {
            os.write_bool(3, self.pack_as_bytes)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BufferSettings {
        BufferSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "max_request_bytes",
                |m: &BufferSettings| { &m.max_request_bytes },
                |m: &mut BufferSettings| { &mut m.max_request_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allow_partial_message",
                |m: &BufferSettings| { &m.allow_partial_message },
                |m: &mut BufferSettings| { &mut m.allow_partial_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "pack_as_bytes",
                |m: &BufferSettings| { &m.pack_as_bytes },
                |m: &mut BufferSettings| { &mut m.pack_as_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BufferSettings>(
                "BufferSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BufferSettings {
        static instance: ::protobuf::rt::LazyV2<BufferSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BufferSettings::new)
    }
}

impl ::protobuf::Clear for BufferSettings {
    fn clear(&mut self) {
        self.max_request_bytes = 0;
        self.allow_partial_message = false;
        self.pack_as_bytes = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BufferSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpService {
    // message fields
    pub server_uri: ::protobuf::SingularPtrField<super::http_uri::HttpUri>,
    pub path_prefix: ::std::string::String,
    pub authorization_request: ::protobuf::SingularPtrField<AuthorizationRequest>,
    pub authorization_response: ::protobuf::SingularPtrField<AuthorizationResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpService {
    fn default() -> &'a HttpService {
        <HttpService as ::protobuf::Message>::default_instance()
    }
}

impl HttpService {
    pub fn new() -> HttpService {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.HttpUri server_uri = 1;


    pub fn get_server_uri(&self) -> &super::http_uri::HttpUri {
        self.server_uri.as_ref().unwrap_or_else(|| <super::http_uri::HttpUri as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_uri(&mut self) {
        self.server_uri.clear();
    }

    pub fn has_server_uri(&self) -> bool {
        self.server_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_uri(&mut self, v: super::http_uri::HttpUri) {
        self.server_uri = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_uri(&mut self) -> &mut super::http_uri::HttpUri {
        if self.server_uri.is_none() {
            self.server_uri.set_default();
        }
        self.server_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_uri(&mut self) -> super::http_uri::HttpUri {
        self.server_uri.take().unwrap_or_else(|| super::http_uri::HttpUri::new())
    }

    // string path_prefix = 2;


    pub fn get_path_prefix(&self) -> &str {
        &self.path_prefix
    }
    pub fn clear_path_prefix(&mut self) {
        self.path_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_path_prefix(&mut self, v: ::std::string::String) {
        self.path_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.path_prefix
    }

    // Take field
    pub fn take_path_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path_prefix, ::std::string::String::new())
    }

    // .envoy.extensions.filters.http.ext_authz.v3.AuthorizationRequest authorization_request = 7;


    pub fn get_authorization_request(&self) -> &AuthorizationRequest {
        self.authorization_request.as_ref().unwrap_or_else(|| <AuthorizationRequest as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_request(&mut self) {
        self.authorization_request.clear();
    }

    pub fn has_authorization_request(&self) -> bool {
        self.authorization_request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_request(&mut self, v: AuthorizationRequest) {
        self.authorization_request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_request(&mut self) -> &mut AuthorizationRequest {
        if self.authorization_request.is_none() {
            self.authorization_request.set_default();
        }
        self.authorization_request.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_request(&mut self) -> AuthorizationRequest {
        self.authorization_request.take().unwrap_or_else(|| AuthorizationRequest::new())
    }

    // .envoy.extensions.filters.http.ext_authz.v3.AuthorizationResponse authorization_response = 8;


    pub fn get_authorization_response(&self) -> &AuthorizationResponse {
        self.authorization_response.as_ref().unwrap_or_else(|| <AuthorizationResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authorization_response(&mut self) {
        self.authorization_response.clear();
    }

    pub fn has_authorization_response(&self) -> bool {
        self.authorization_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authorization_response(&mut self, v: AuthorizationResponse) {
        self.authorization_response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authorization_response(&mut self) -> &mut AuthorizationResponse {
        if self.authorization_response.is_none() {
            self.authorization_response.set_default();
        }
        self.authorization_response.as_mut().unwrap()
    }

    // Take field
    pub fn take_authorization_response(&mut self) -> AuthorizationResponse {
        self.authorization_response.take().unwrap_or_else(|| AuthorizationResponse::new())
    }
}

impl ::protobuf::Message for HttpService {
    fn is_initialized(&self) -> bool {
        for v in &self.server_uri {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_request {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authorization_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path_prefix)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_request)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authorization_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server_uri.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.path_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path_prefix);
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authorization_response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server_uri.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.path_prefix.is_empty() {
            os.write_string(2, &self.path_prefix)?;
        }
        if let Some(ref v) = self.authorization_request.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authorization_response.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpService {
        HttpService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http_uri::HttpUri>>(
                "server_uri",
                |m: &HttpService| { &m.server_uri },
                |m: &mut HttpService| { &mut m.server_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path_prefix",
                |m: &HttpService| { &m.path_prefix },
                |m: &mut HttpService| { &mut m.path_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthorizationRequest>>(
                "authorization_request",
                |m: &HttpService| { &m.authorization_request },
                |m: &mut HttpService| { &mut m.authorization_request },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthorizationResponse>>(
                "authorization_response",
                |m: &HttpService| { &m.authorization_response },
                |m: &mut HttpService| { &mut m.authorization_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpService>(
                "HttpService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpService {
        static instance: ::protobuf::rt::LazyV2<HttpService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpService::new)
    }
}

impl ::protobuf::Clear for HttpService {
    fn clear(&mut self) {
        self.server_uri.clear();
        self.path_prefix.clear();
        self.authorization_request.clear();
        self.authorization_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthorizationRequest {
    // message fields
    pub allowed_headers: ::protobuf::SingularPtrField<super::string::ListStringMatcher>,
    pub headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthorizationRequest {
    fn default() -> &'a AuthorizationRequest {
        <AuthorizationRequest as ::protobuf::Message>::default_instance()
    }
}

impl AuthorizationRequest {
    pub fn new() -> AuthorizationRequest {
        ::std::default::Default::default()
    }

    // .envoy.type.matcher.v3.ListStringMatcher allowed_headers = 1;


    pub fn get_allowed_headers(&self) -> &super::string::ListStringMatcher {
        self.allowed_headers.as_ref().unwrap_or_else(|| <super::string::ListStringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allowed_headers(&mut self) {
        self.allowed_headers.clear();
    }

    pub fn has_allowed_headers(&self) -> bool {
        self.allowed_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_headers(&mut self, v: super::string::ListStringMatcher) {
        self.allowed_headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowed_headers(&mut self) -> &mut super::string::ListStringMatcher {
        if self.allowed_headers.is_none() {
            self.allowed_headers.set_default();
        }
        self.allowed_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_allowed_headers(&mut self) -> super::string::ListStringMatcher {
        self.allowed_headers.take().unwrap_or_else(|| super::string::ListStringMatcher::new())
    }

    // repeated .envoy.config.core.v3.HeaderValue headers_to_add = 2;


    pub fn get_headers_to_add(&self) -> &[super::base::HeaderValue] {
        &self.headers_to_add
    }
    pub fn clear_headers_to_add(&mut self) {
        self.headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValue>) {
        self.headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValue> {
        &mut self.headers_to_add
    }

    // Take field
    pub fn take_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValue> {
        ::std::mem::replace(&mut self.headers_to_add, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthorizationRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.allowed_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allowed_headers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers_to_add)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.allowed_headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.allowed_headers.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.headers_to_add {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthorizationRequest {
        AuthorizationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::ListStringMatcher>>(
                "allowed_headers",
                |m: &AuthorizationRequest| { &m.allowed_headers },
                |m: &mut AuthorizationRequest| { &mut m.allowed_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValue>>(
                "headers_to_add",
                |m: &AuthorizationRequest| { &m.headers_to_add },
                |m: &mut AuthorizationRequest| { &mut m.headers_to_add },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthorizationRequest>(
                "AuthorizationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthorizationRequest {
        static instance: ::protobuf::rt::LazyV2<AuthorizationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthorizationRequest::new)
    }
}

impl ::protobuf::Clear for AuthorizationRequest {
    fn clear(&mut self) {
        self.allowed_headers.clear();
        self.headers_to_add.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthorizationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthorizationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthorizationResponse {
    // message fields
    pub allowed_upstream_headers: ::protobuf::SingularPtrField<super::string::ListStringMatcher>,
    pub allowed_upstream_headers_to_append: ::protobuf::SingularPtrField<super::string::ListStringMatcher>,
    pub allowed_client_headers: ::protobuf::SingularPtrField<super::string::ListStringMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthorizationResponse {
    fn default() -> &'a AuthorizationResponse {
        <AuthorizationResponse as ::protobuf::Message>::default_instance()
    }
}

impl AuthorizationResponse {
    pub fn new() -> AuthorizationResponse {
        ::std::default::Default::default()
    }

    // .envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers = 1;


    pub fn get_allowed_upstream_headers(&self) -> &super::string::ListStringMatcher {
        self.allowed_upstream_headers.as_ref().unwrap_or_else(|| <super::string::ListStringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allowed_upstream_headers(&mut self) {
        self.allowed_upstream_headers.clear();
    }

    pub fn has_allowed_upstream_headers(&self) -> bool {
        self.allowed_upstream_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_upstream_headers(&mut self, v: super::string::ListStringMatcher) {
        self.allowed_upstream_headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowed_upstream_headers(&mut self) -> &mut super::string::ListStringMatcher {
        if self.allowed_upstream_headers.is_none() {
            self.allowed_upstream_headers.set_default();
        }
        self.allowed_upstream_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_allowed_upstream_headers(&mut self) -> super::string::ListStringMatcher {
        self.allowed_upstream_headers.take().unwrap_or_else(|| super::string::ListStringMatcher::new())
    }

    // .envoy.type.matcher.v3.ListStringMatcher allowed_upstream_headers_to_append = 3;


    pub fn get_allowed_upstream_headers_to_append(&self) -> &super::string::ListStringMatcher {
        self.allowed_upstream_headers_to_append.as_ref().unwrap_or_else(|| <super::string::ListStringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allowed_upstream_headers_to_append(&mut self) {
        self.allowed_upstream_headers_to_append.clear();
    }

    pub fn has_allowed_upstream_headers_to_append(&self) -> bool {
        self.allowed_upstream_headers_to_append.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_upstream_headers_to_append(&mut self, v: super::string::ListStringMatcher) {
        self.allowed_upstream_headers_to_append = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowed_upstream_headers_to_append(&mut self) -> &mut super::string::ListStringMatcher {
        if self.allowed_upstream_headers_to_append.is_none() {
            self.allowed_upstream_headers_to_append.set_default();
        }
        self.allowed_upstream_headers_to_append.as_mut().unwrap()
    }

    // Take field
    pub fn take_allowed_upstream_headers_to_append(&mut self) -> super::string::ListStringMatcher {
        self.allowed_upstream_headers_to_append.take().unwrap_or_else(|| super::string::ListStringMatcher::new())
    }

    // .envoy.type.matcher.v3.ListStringMatcher allowed_client_headers = 2;


    pub fn get_allowed_client_headers(&self) -> &super::string::ListStringMatcher {
        self.allowed_client_headers.as_ref().unwrap_or_else(|| <super::string::ListStringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allowed_client_headers(&mut self) {
        self.allowed_client_headers.clear();
    }

    pub fn has_allowed_client_headers(&self) -> bool {
        self.allowed_client_headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed_client_headers(&mut self, v: super::string::ListStringMatcher) {
        self.allowed_client_headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowed_client_headers(&mut self) -> &mut super::string::ListStringMatcher {
        if self.allowed_client_headers.is_none() {
            self.allowed_client_headers.set_default();
        }
        self.allowed_client_headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_allowed_client_headers(&mut self) -> super::string::ListStringMatcher {
        self.allowed_client_headers.take().unwrap_or_else(|| super::string::ListStringMatcher::new())
    }
}

impl ::protobuf::Message for AuthorizationResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.allowed_upstream_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allowed_upstream_headers_to_append {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allowed_client_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allowed_upstream_headers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allowed_upstream_headers_to_append)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allowed_client_headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.allowed_upstream_headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.allowed_upstream_headers_to_append.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.allowed_client_headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.allowed_upstream_headers.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.allowed_upstream_headers_to_append.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.allowed_client_headers.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthorizationResponse {
        AuthorizationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::ListStringMatcher>>(
                "allowed_upstream_headers",
                |m: &AuthorizationResponse| { &m.allowed_upstream_headers },
                |m: &mut AuthorizationResponse| { &mut m.allowed_upstream_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::ListStringMatcher>>(
                "allowed_upstream_headers_to_append",
                |m: &AuthorizationResponse| { &m.allowed_upstream_headers_to_append },
                |m: &mut AuthorizationResponse| { &mut m.allowed_upstream_headers_to_append },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::ListStringMatcher>>(
                "allowed_client_headers",
                |m: &AuthorizationResponse| { &m.allowed_client_headers },
                |m: &mut AuthorizationResponse| { &mut m.allowed_client_headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthorizationResponse>(
                "AuthorizationResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthorizationResponse {
        static instance: ::protobuf::rt::LazyV2<AuthorizationResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthorizationResponse::new)
    }
}

impl ::protobuf::Clear for AuthorizationResponse {
    fn clear(&mut self) {
        self.allowed_upstream_headers.clear();
        self.allowed_upstream_headers_to_append.clear();
        self.allowed_client_headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthorizationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthorizationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExtAuthzPerRoute {
    // message oneof groups
    pub field_override: ::std::option::Option<ExtAuthzPerRoute_oneof_override>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExtAuthzPerRoute {
    fn default() -> &'a ExtAuthzPerRoute {
        <ExtAuthzPerRoute as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ExtAuthzPerRoute_oneof_override {
    disabled(bool),
    check_settings(CheckSettings),
}

impl ExtAuthzPerRoute {
    pub fn new() -> ExtAuthzPerRoute {
        ::std::default::Default::default()
    }

    // bool disabled = 1;


    pub fn get_disabled(&self) -> bool {
        match self.field_override {
            ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::disabled(v)) => v,
            _ => false,
        }
    }
    pub fn clear_disabled(&mut self) {
        self.field_override = ::std::option::Option::None;
    }

    pub fn has_disabled(&self) -> bool {
        match self.field_override {
            ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::disabled(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.field_override = ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::disabled(v))
    }

    // .envoy.extensions.filters.http.ext_authz.v3.CheckSettings check_settings = 2;


    pub fn get_check_settings(&self) -> &CheckSettings {
        match self.field_override {
            ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(ref v)) => v,
            _ => <CheckSettings as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_check_settings(&mut self) {
        self.field_override = ::std::option::Option::None;
    }

    pub fn has_check_settings(&self) -> bool {
        match self.field_override {
            ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_check_settings(&mut self, v: CheckSettings) {
        self.field_override = ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(v))
    }

    // Mutable pointer to the field.
    pub fn mut_check_settings(&mut self) -> &mut CheckSettings {
        if let ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(_)) = self.field_override {
        } else {
            self.field_override = ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(CheckSettings::new()));
        }
        match self.field_override {
            ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_check_settings(&mut self) -> CheckSettings {
        if self.has_check_settings() {
            match self.field_override.take() {
                ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(v)) => v,
                _ => panic!(),
            }
        } else {
            CheckSettings::new()
        }
    }
}

impl ::protobuf::Message for ExtAuthzPerRoute {
    fn is_initialized(&self) -> bool {
        if let Some(ExtAuthzPerRoute_oneof_override::check_settings(ref v)) = self.field_override {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_override = ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::disabled(is.read_bool()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_override = ::std::option::Option::Some(ExtAuthzPerRoute_oneof_override::check_settings(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.field_override {
            match v {
                &ExtAuthzPerRoute_oneof_override::disabled(v) => {
                    my_size += 2;
                },
                &ExtAuthzPerRoute_oneof_override::check_settings(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.field_override {
            match v {
                &ExtAuthzPerRoute_oneof_override::disabled(v) => {
                    os.write_bool(1, v)?;
                },
                &ExtAuthzPerRoute_oneof_override::check_settings(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExtAuthzPerRoute {
        ExtAuthzPerRoute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "disabled",
                ExtAuthzPerRoute::has_disabled,
                ExtAuthzPerRoute::get_disabled,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CheckSettings>(
                "check_settings",
                ExtAuthzPerRoute::has_check_settings,
                ExtAuthzPerRoute::get_check_settings,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExtAuthzPerRoute>(
                "ExtAuthzPerRoute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExtAuthzPerRoute {
        static instance: ::protobuf::rt::LazyV2<ExtAuthzPerRoute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExtAuthzPerRoute::new)
    }
}

impl ::protobuf::Clear for ExtAuthzPerRoute {
    fn clear(&mut self) {
        self.field_override = ::std::option::Option::None;
        self.field_override = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExtAuthzPerRoute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExtAuthzPerRoute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CheckSettings {
    // message fields
    pub context_extensions: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub disable_request_body_buffering: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CheckSettings {
    fn default() -> &'a CheckSettings {
        <CheckSettings as ::protobuf::Message>::default_instance()
    }
}

impl CheckSettings {
    pub fn new() -> CheckSettings {
        ::std::default::Default::default()
    }

    // repeated .envoy.extensions.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntry context_extensions = 1;


    pub fn get_context_extensions(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.context_extensions
    }
    pub fn clear_context_extensions(&mut self) {
        self.context_extensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_context_extensions(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.context_extensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_context_extensions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.context_extensions
    }

    // Take field
    pub fn take_context_extensions(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.context_extensions, ::std::collections::HashMap::new())
    }

    // bool disable_request_body_buffering = 2;


    pub fn get_disable_request_body_buffering(&self) -> bool {
        self.disable_request_body_buffering
    }
    pub fn clear_disable_request_body_buffering(&mut self) {
        self.disable_request_body_buffering = false;
    }

    // Param is passed by value, moved
    pub fn set_disable_request_body_buffering(&mut self, v: bool) {
        self.disable_request_body_buffering = v;
    }
}

impl ::protobuf::Message for CheckSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.context_extensions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_request_body_buffering = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.context_extensions);
        if self.disable_request_body_buffering != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.context_extensions, os)?;
        if self.disable_request_body_buffering != false {
            os.write_bool(2, self.disable_request_body_buffering)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CheckSettings {
        CheckSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "context_extensions",
                |m: &CheckSettings| { &m.context_extensions },
                |m: &mut CheckSettings| { &mut m.context_extensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_request_body_buffering",
                |m: &CheckSettings| { &m.disable_request_body_buffering },
                |m: &mut CheckSettings| { &mut m.disable_request_body_buffering },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CheckSettings>(
                "CheckSettings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CheckSettings {
        static instance: ::protobuf::rt::LazyV2<CheckSettings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CheckSettings::new)
    }
}

impl ::protobuf::Clear for CheckSettings {
    fn clear(&mut self) {
        self.context_extensions.clear();
        self.disable_request_body_buffering = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CheckSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CheckSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n:envoy/extensions/filters/http/ext_authz/v3/ext_authz.proto\x12*envoy.\
    extensions.filters.http.ext_authz.v3\x1a\x1fenvoy/config/core/v3/base.pr\
    oto\x1a(envoy/config/core/v3/config_source.proto\x1a'envoy/config/core/v\
    3/grpc_service.proto\x1a#envoy/config/core/v3/http_uri.proto\x1a$envoy/t\
    ype/matcher/v3/metadata.proto\x1a\"envoy/type/matcher/v3/string.proto\
    \x1a\x1fenvoy/type/v3/http_status.proto\x1a#envoy/annotations/deprecatio\
    n.proto\x1a\x1dudpa/annotations/status.proto\x1a!udpa/annotations/versio\
    ning.proto\x1a\x17validate/validate.proto\"\x8d\x08\n\x08ExtAuthz\x12F\n\
    \x0cgrpc_service\x18\x01\x20\x01(\x0b2!.envoy.config.core.v3.GrpcService\
    H\0R\x0bgrpcService\x12\\\n\x0chttp_service\x18\x03\x20\x01(\x0b27.envoy\
    .extensions.filters.http.ext_authz.v3.HttpServiceH\0R\x0bhttpService\x12\
    ^\n\x15transport_api_version\x18\x0c\x20\x01(\x0e2\x20.envoy.config.core\
    .v3.ApiVersionR\x13transportApiVersionB\x08\xfaB\x05\x82\x01\x02\x10\x01\
    \x12,\n\x12failure_mode_allow\x18\x02\x20\x01(\x08R\x10failureModeAllow\
    \x12f\n\x11with_request_body\x18\x05\x20\x01(\x0b2:.envoy.extensions.fil\
    ters.http.ext_authz.v3.BufferSettingsR\x0fwithRequestBody\x12*\n\x11clea\
    r_route_cache\x18\x06\x20\x01(\x08R\x0fclearRouteCache\x12A\n\x0fstatus_\
    on_error\x18\x07\x20\x01(\x0b2\x19.envoy.type.v3.HttpStatusR\rstatusOnEr\
    ror\x12>\n\x1bmetadata_context_namespaces\x18\x08\x20\x03(\tR\x19metadat\
    aContextNamespaces\x12U\n\x0efilter_enabled\x18\t\x20\x01(\x0b2..envoy.c\
    onfig.core.v3.RuntimeFractionalPercentR\rfilterEnabled\x12^\n\x17filter_\
    enabled_metadata\x18\x0e\x20\x01(\x0b2&.envoy.type.matcher.v3.MetadataMa\
    tcherR\x15filterEnabledMetadata\x12P\n\x0fdeny_at_disable\x18\x0b\x20\
    \x01(\x0b2(.envoy.config.core.v3.RuntimeFeatureFlagR\rdenyAtDisable\x128\
    \n\x18include_peer_certificate\x18\n\x20\x01(\x08R\x16includePeerCertifi\
    cate\x12\x1f\n\x0bstat_prefix\x18\r\x20\x01(\tR\nstatPrefixB\n\n\x08serv\
    ices:5\x9a\xc5\x88\x1e0\n.envoy.config.filter.http.ext_authz.v2.ExtAuthz\
    J\x04\x08\x04\x10\x05R\tuse_alpha\"\xda\x01\n\x0eBufferSettings\x123\n\
    \x11max_request_bytes\x18\x01\x20\x01(\rR\x0fmaxRequestBytesB\x07\xfaB\
    \x04*\x02\x20\0\x122\n\x15allow_partial_message\x18\x02\x20\x01(\x08R\
    \x13allowPartialMessage\x12\"\n\rpack_as_bytes\x18\x03\x20\x01(\x08R\x0b\
    packAsBytes:;\x9a\xc5\x88\x1e6\n4envoy.config.filter.http.ext_authz.v2.B\
    ufferSettings\"\xaf\x03\n\x0bHttpService\x12<\n\nserver_uri\x18\x01\x20\
    \x01(\x0b2\x1d.envoy.config.core.v3.HttpUriR\tserverUri\x12\x1f\n\x0bpat\
    h_prefix\x18\x02\x20\x01(\tR\npathPrefix\x12u\n\x15authorization_request\
    \x18\x07\x20\x01(\x0b2@.envoy.extensions.filters.http.ext_authz.v3.Autho\
    rizationRequestR\x14authorizationRequest\x12x\n\x16authorization_respons\
    e\x18\x08\x20\x01(\x0b2A.envoy.extensions.filters.http.ext_authz.v3.Auth\
    orizationResponseR\x15authorizationResponse:8\x9a\xc5\x88\x1e3\n1envoy.c\
    onfig.filter.http.ext_authz.v2.HttpServiceJ\x04\x08\x03\x10\x04J\x04\x08\
    \x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07\"\xf5\x01\n\x14Au\
    thorizationRequest\x12Q\n\x0fallowed_headers\x18\x01\x20\x01(\x0b2(.envo\
    y.type.matcher.v3.ListStringMatcherR\x0eallowedHeaders\x12G\n\x0eheaders\
    _to_add\x18\x02\x20\x03(\x0b2!.envoy.config.core.v3.HeaderValueR\x0chead\
    ersToAdd:A\x9a\xc5\x88\x1e<\n:envoy.config.filter.http.ext_authz.v2.Auth\
    orizationRequest\"\x95\x03\n\x15AuthorizationResponse\x12b\n\x18allowed_\
    upstream_headers\x18\x01\x20\x01(\x0b2(.envoy.type.matcher.v3.ListString\
    MatcherR\x16allowedUpstreamHeaders\x12t\n\"allowed_upstream_headers_to_a\
    ppend\x18\x03\x20\x01(\x0b2(.envoy.type.matcher.v3.ListStringMatcherR\
    \x1eallowedUpstreamHeadersToAppend\x12^\n\x16allowed_client_headers\x18\
    \x02\x20\x01(\x0b2(.envoy.type.matcher.v3.ListStringMatcherR\x14allowedC\
    lientHeaders:B\x9a\xc5\x88\x1e=\n;envoy.config.filter.http.ext_authz.v2.\
    AuthorizationResponse\"\xf7\x01\n\x10ExtAuthzPerRoute\x12%\n\x08disabled\
    \x18\x01\x20\x01(\x08H\0R\x08disabledB\x07\xfaB\x04j\x02\x08\x01\x12l\n\
    \x0echeck_settings\x18\x02\x20\x01(\x0b29.envoy.extensions.filters.http.\
    ext_authz.v3.CheckSettingsH\0R\rcheckSettingsB\x08\xfaB\x05\x8a\x01\x02\
    \x10\x01B\x0f\n\x08override\x12\x03\xf8B\x01:=\x9a\xc5\x88\x1e8\n6envoy.\
    config.filter.http.ext_authz.v2.ExtAuthzPerRoute\"\xd7\x02\n\rCheckSetti\
    ngs\x12\x7f\n\x12context_extensions\x18\x01\x20\x03(\x0b2P.envoy.extensi\
    ons.filters.http.ext_authz.v3.CheckSettings.ContextExtensionsEntryR\x11c\
    ontextExtensions\x12C\n\x1edisable_request_body_buffering\x18\x02\x20\
    \x01(\x08R\x1bdisableRequestBodyBuffering\x1aD\n\x16ContextExtensionsEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01::\x9a\xc5\x88\x1e5\n3envoy.config.fi\
    lter.http.ext_authz.v2.CheckSettingsBS\n8io.envoyproxy.envoy.extensions.\
    filters.http.ext_authz.v3B\rExtAuthzProtoP\x01\xba\x80\xc8\xd1\x06\x02\
    \x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
