// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/data/core/v2alpha/health_check_event.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheckEvent {
    // message fields
    pub health_checker_type: HealthCheckerType,
    pub host: ::protobuf::SingularPtrField<super::address::Address>,
    pub cluster_name: ::std::string::String,
    pub timestamp: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub event: ::std::option::Option<HealthCheckEvent_oneof_event>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheckEvent {
    fn default() -> &'a HealthCheckEvent {
        <HealthCheckEvent as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HealthCheckEvent_oneof_event {
    eject_unhealthy_event(HealthCheckEjectUnhealthy),
    add_healthy_event(HealthCheckAddHealthy),
    health_check_failure_event(HealthCheckFailure),
    degraded_healthy_host(DegradedHealthyHost),
    no_longer_degraded_host(NoLongerDegradedHost),
}

impl HealthCheckEvent {
    pub fn new() -> HealthCheckEvent {
        ::std::default::Default::default()
    }

    // .envoy.data.core.v2alpha.HealthCheckerType health_checker_type = 1;


    pub fn get_health_checker_type(&self) -> HealthCheckerType {
        self.health_checker_type
    }
    pub fn clear_health_checker_type(&mut self) {
        self.health_checker_type = HealthCheckerType::HTTP;
    }

    // Param is passed by value, moved
    pub fn set_health_checker_type(&mut self, v: HealthCheckerType) {
        self.health_checker_type = v;
    }

    // .envoy.api.v2.core.Address host = 2;


    pub fn get_host(&self) -> &super::address::Address {
        self.host.as_ref().unwrap_or_else(|| <super::address::Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: super::address::Address) {
        self.host = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut super::address::Address {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> super::address::Address {
        self.host.take().unwrap_or_else(|| super::address::Address::new())
    }

    // string cluster_name = 3;


    pub fn get_cluster_name(&self) -> &str {
        &self.cluster_name
    }
    pub fn clear_cluster_name(&mut self) {
        self.cluster_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_name(&mut self, v: ::std::string::String) {
        self.cluster_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_name(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_name
    }

    // Take field
    pub fn take_cluster_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_name, ::std::string::String::new())
    }

    // .envoy.data.core.v2alpha.HealthCheckEjectUnhealthy eject_unhealthy_event = 4;


    pub fn get_eject_unhealthy_event(&self) -> &HealthCheckEjectUnhealthy {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(ref v)) => v,
            _ => <HealthCheckEjectUnhealthy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_eject_unhealthy_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_eject_unhealthy_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_eject_unhealthy_event(&mut self, v: HealthCheckEjectUnhealthy) {
        self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_eject_unhealthy_event(&mut self) -> &mut HealthCheckEjectUnhealthy {
        if let ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(HealthCheckEjectUnhealthy::new()));
        }
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_eject_unhealthy_event(&mut self) -> HealthCheckEjectUnhealthy {
        if self.has_eject_unhealthy_event() {
            match self.event.take() {
                ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheckEjectUnhealthy::new()
        }
    }

    // .envoy.data.core.v2alpha.HealthCheckAddHealthy add_healthy_event = 5;


    pub fn get_add_healthy_event(&self) -> &HealthCheckAddHealthy {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(ref v)) => v,
            _ => <HealthCheckAddHealthy as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_add_healthy_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_add_healthy_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_add_healthy_event(&mut self, v: HealthCheckAddHealthy) {
        self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_add_healthy_event(&mut self) -> &mut HealthCheckAddHealthy {
        if let ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(HealthCheckAddHealthy::new()));
        }
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_add_healthy_event(&mut self) -> HealthCheckAddHealthy {
        if self.has_add_healthy_event() {
            match self.event.take() {
                ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheckAddHealthy::new()
        }
    }

    // .envoy.data.core.v2alpha.HealthCheckFailure health_check_failure_event = 7;


    pub fn get_health_check_failure_event(&self) -> &HealthCheckFailure {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(ref v)) => v,
            _ => <HealthCheckFailure as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_health_check_failure_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_health_check_failure_event(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_health_check_failure_event(&mut self, v: HealthCheckFailure) {
        self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_health_check_failure_event(&mut self) -> &mut HealthCheckFailure {
        if let ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(HealthCheckFailure::new()));
        }
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_health_check_failure_event(&mut self) -> HealthCheckFailure {
        if self.has_health_check_failure_event() {
            match self.event.take() {
                ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheckFailure::new()
        }
    }

    // .envoy.data.core.v2alpha.DegradedHealthyHost degraded_healthy_host = 8;


    pub fn get_degraded_healthy_host(&self) -> &DegradedHealthyHost {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(ref v)) => v,
            _ => <DegradedHealthyHost as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_degraded_healthy_host(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_degraded_healthy_host(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_degraded_healthy_host(&mut self, v: DegradedHealthyHost) {
        self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(v))
    }

    // Mutable pointer to the field.
    pub fn mut_degraded_healthy_host(&mut self) -> &mut DegradedHealthyHost {
        if let ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(DegradedHealthyHost::new()));
        }
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_degraded_healthy_host(&mut self) -> DegradedHealthyHost {
        if self.has_degraded_healthy_host() {
            match self.event.take() {
                ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(v)) => v,
                _ => panic!(),
            }
        } else {
            DegradedHealthyHost::new()
        }
    }

    // .envoy.data.core.v2alpha.NoLongerDegradedHost no_longer_degraded_host = 9;


    pub fn get_no_longer_degraded_host(&self) -> &NoLongerDegradedHost {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(ref v)) => v,
            _ => <NoLongerDegradedHost as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_no_longer_degraded_host(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_no_longer_degraded_host(&self) -> bool {
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_no_longer_degraded_host(&mut self, v: NoLongerDegradedHost) {
        self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(v))
    }

    // Mutable pointer to the field.
    pub fn mut_no_longer_degraded_host(&mut self) -> &mut NoLongerDegradedHost {
        if let ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(_)) = self.event {
        } else {
            self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(NoLongerDegradedHost::new()));
        }
        match self.event {
            ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_no_longer_degraded_host(&mut self) -> NoLongerDegradedHost {
        if self.has_no_longer_degraded_host() {
            match self.event.take() {
                ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(v)) => v,
                _ => panic!(),
            }
        } else {
            NoLongerDegradedHost::new()
        }
    }

    // .google.protobuf.Timestamp timestamp = 6;


    pub fn get_timestamp(&self) -> &::protobuf::well_known_types::Timestamp {
        self.timestamp.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.timestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.timestamp.is_none() {
            self.timestamp.set_default();
        }
        self.timestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.timestamp.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for HealthCheckEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.host {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheckEvent_oneof_event::add_healthy_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheckEvent_oneof_event::health_check_failure_event(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheckEvent_oneof_event::degraded_healthy_host(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(ref v)) = self.event {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.timestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.health_checker_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.host)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::eject_unhealthy_event(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::add_healthy_event(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::health_check_failure_event(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::degraded_healthy_host(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.event = ::std::option::Option::Some(HealthCheckEvent_oneof_event::no_longer_degraded_host(is.read_message()?));
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.health_checker_type != HealthCheckerType::HTTP {
            my_size += ::protobuf::rt::enum_size(1, self.health_checker_type);
        }
        if let Some(ref v) = self.host.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cluster_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_name);
        }
        if let Some(ref v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &HealthCheckEvent_oneof_event::eject_unhealthy_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheckEvent_oneof_event::add_healthy_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheckEvent_oneof_event::health_check_failure_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheckEvent_oneof_event::degraded_healthy_host(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheckEvent_oneof_event::no_longer_degraded_host(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.health_checker_type != HealthCheckerType::HTTP {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.health_checker_type))?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cluster_name.is_empty() {
            os.write_string(3, &self.cluster_name)?;
        }
        if let Some(ref v) = self.timestamp.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.event {
            match v {
                &HealthCheckEvent_oneof_event::eject_unhealthy_event(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheckEvent_oneof_event::add_healthy_event(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheckEvent_oneof_event::health_check_failure_event(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheckEvent_oneof_event::degraded_healthy_host(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheckEvent_oneof_event::no_longer_degraded_host(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheckEvent {
        HealthCheckEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HealthCheckerType>>(
                "health_checker_type",
                |m: &HealthCheckEvent| { &m.health_checker_type },
                |m: &mut HealthCheckEvent| { &mut m.health_checker_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::address::Address>>(
                "host",
                |m: &HealthCheckEvent| { &m.host },
                |m: &mut HealthCheckEvent| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_name",
                |m: &HealthCheckEvent| { &m.cluster_name },
                |m: &mut HealthCheckEvent| { &mut m.cluster_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheckEjectUnhealthy>(
                "eject_unhealthy_event",
                HealthCheckEvent::has_eject_unhealthy_event,
                HealthCheckEvent::get_eject_unhealthy_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheckAddHealthy>(
                "add_healthy_event",
                HealthCheckEvent::has_add_healthy_event,
                HealthCheckEvent::get_add_healthy_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheckFailure>(
                "health_check_failure_event",
                HealthCheckEvent::has_health_check_failure_event,
                HealthCheckEvent::get_health_check_failure_event,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DegradedHealthyHost>(
                "degraded_healthy_host",
                HealthCheckEvent::has_degraded_healthy_host,
                HealthCheckEvent::get_degraded_healthy_host,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NoLongerDegradedHost>(
                "no_longer_degraded_host",
                HealthCheckEvent::has_no_longer_degraded_host,
                HealthCheckEvent::get_no_longer_degraded_host,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "timestamp",
                |m: &HealthCheckEvent| { &m.timestamp },
                |m: &mut HealthCheckEvent| { &mut m.timestamp },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheckEvent>(
                "HealthCheckEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheckEvent {
        static instance: ::protobuf::rt::LazyV2<HealthCheckEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheckEvent::new)
    }
}

impl ::protobuf::Clear for HealthCheckEvent {
    fn clear(&mut self) {
        self.health_checker_type = HealthCheckerType::HTTP;
        self.host.clear();
        self.cluster_name.clear();
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheckEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheckEjectUnhealthy {
    // message fields
    pub failure_type: HealthCheckFailureType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheckEjectUnhealthy {
    fn default() -> &'a HealthCheckEjectUnhealthy {
        <HealthCheckEjectUnhealthy as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckEjectUnhealthy {
    pub fn new() -> HealthCheckEjectUnhealthy {
        ::std::default::Default::default()
    }

    // .envoy.data.core.v2alpha.HealthCheckFailureType failure_type = 1;


    pub fn get_failure_type(&self) -> HealthCheckFailureType {
        self.failure_type
    }
    pub fn clear_failure_type(&mut self) {
        self.failure_type = HealthCheckFailureType::ACTIVE;
    }

    // Param is passed by value, moved
    pub fn set_failure_type(&mut self, v: HealthCheckFailureType) {
        self.failure_type = v;
    }
}

impl ::protobuf::Message for HealthCheckEjectUnhealthy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.failure_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.failure_type != HealthCheckFailureType::ACTIVE {
            my_size += ::protobuf::rt::enum_size(1, self.failure_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.failure_type != HealthCheckFailureType::ACTIVE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.failure_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheckEjectUnhealthy {
        HealthCheckEjectUnhealthy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HealthCheckFailureType>>(
                "failure_type",
                |m: &HealthCheckEjectUnhealthy| { &m.failure_type },
                |m: &mut HealthCheckEjectUnhealthy| { &mut m.failure_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheckEjectUnhealthy>(
                "HealthCheckEjectUnhealthy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheckEjectUnhealthy {
        static instance: ::protobuf::rt::LazyV2<HealthCheckEjectUnhealthy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheckEjectUnhealthy::new)
    }
}

impl ::protobuf::Clear for HealthCheckEjectUnhealthy {
    fn clear(&mut self) {
        self.failure_type = HealthCheckFailureType::ACTIVE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheckEjectUnhealthy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckEjectUnhealthy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheckAddHealthy {
    // message fields
    pub first_check: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheckAddHealthy {
    fn default() -> &'a HealthCheckAddHealthy {
        <HealthCheckAddHealthy as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckAddHealthy {
    pub fn new() -> HealthCheckAddHealthy {
        ::std::default::Default::default()
    }

    // bool first_check = 1;


    pub fn get_first_check(&self) -> bool {
        self.first_check
    }
    pub fn clear_first_check(&mut self) {
        self.first_check = false;
    }

    // Param is passed by value, moved
    pub fn set_first_check(&mut self, v: bool) {
        self.first_check = v;
    }
}

impl ::protobuf::Message for HealthCheckAddHealthy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.first_check = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.first_check != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.first_check != false {
            os.write_bool(1, self.first_check)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheckAddHealthy {
        HealthCheckAddHealthy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "first_check",
                |m: &HealthCheckAddHealthy| { &m.first_check },
                |m: &mut HealthCheckAddHealthy| { &mut m.first_check },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheckAddHealthy>(
                "HealthCheckAddHealthy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheckAddHealthy {
        static instance: ::protobuf::rt::LazyV2<HealthCheckAddHealthy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheckAddHealthy::new)
    }
}

impl ::protobuf::Clear for HealthCheckAddHealthy {
    fn clear(&mut self) {
        self.first_check = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheckAddHealthy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckAddHealthy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheckFailure {
    // message fields
    pub failure_type: HealthCheckFailureType,
    pub first_check: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheckFailure {
    fn default() -> &'a HealthCheckFailure {
        <HealthCheckFailure as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheckFailure {
    pub fn new() -> HealthCheckFailure {
        ::std::default::Default::default()
    }

    // .envoy.data.core.v2alpha.HealthCheckFailureType failure_type = 1;


    pub fn get_failure_type(&self) -> HealthCheckFailureType {
        self.failure_type
    }
    pub fn clear_failure_type(&mut self) {
        self.failure_type = HealthCheckFailureType::ACTIVE;
    }

    // Param is passed by value, moved
    pub fn set_failure_type(&mut self, v: HealthCheckFailureType) {
        self.failure_type = v;
    }

    // bool first_check = 2;


    pub fn get_first_check(&self) -> bool {
        self.first_check
    }
    pub fn clear_first_check(&mut self) {
        self.first_check = false;
    }

    // Param is passed by value, moved
    pub fn set_first_check(&mut self, v: bool) {
        self.first_check = v;
    }
}

impl ::protobuf::Message for HealthCheckFailure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.failure_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.first_check = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.failure_type != HealthCheckFailureType::ACTIVE {
            my_size += ::protobuf::rt::enum_size(1, self.failure_type);
        }
        if self.first_check != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.failure_type != HealthCheckFailureType::ACTIVE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.failure_type))?;
        }
        if self.first_check != false {
            os.write_bool(2, self.first_check)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheckFailure {
        HealthCheckFailure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HealthCheckFailureType>>(
                "failure_type",
                |m: &HealthCheckFailure| { &m.failure_type },
                |m: &mut HealthCheckFailure| { &mut m.failure_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "first_check",
                |m: &HealthCheckFailure| { &m.first_check },
                |m: &mut HealthCheckFailure| { &mut m.first_check },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheckFailure>(
                "HealthCheckFailure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheckFailure {
        static instance: ::protobuf::rt::LazyV2<HealthCheckFailure> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheckFailure::new)
    }
}

impl ::protobuf::Clear for HealthCheckFailure {
    fn clear(&mut self) {
        self.failure_type = HealthCheckFailureType::ACTIVE;
        self.first_check = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheckFailure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckFailure {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DegradedHealthyHost {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DegradedHealthyHost {
    fn default() -> &'a DegradedHealthyHost {
        <DegradedHealthyHost as ::protobuf::Message>::default_instance()
    }
}

impl DegradedHealthyHost {
    pub fn new() -> DegradedHealthyHost {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DegradedHealthyHost {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DegradedHealthyHost {
        DegradedHealthyHost::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DegradedHealthyHost>(
                "DegradedHealthyHost",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DegradedHealthyHost {
        static instance: ::protobuf::rt::LazyV2<DegradedHealthyHost> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DegradedHealthyHost::new)
    }
}

impl ::protobuf::Clear for DegradedHealthyHost {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DegradedHealthyHost {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DegradedHealthyHost {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NoLongerDegradedHost {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NoLongerDegradedHost {
    fn default() -> &'a NoLongerDegradedHost {
        <NoLongerDegradedHost as ::protobuf::Message>::default_instance()
    }
}

impl NoLongerDegradedHost {
    pub fn new() -> NoLongerDegradedHost {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for NoLongerDegradedHost {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NoLongerDegradedHost {
        NoLongerDegradedHost::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NoLongerDegradedHost>(
                "NoLongerDegradedHost",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NoLongerDegradedHost {
        static instance: ::protobuf::rt::LazyV2<NoLongerDegradedHost> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NoLongerDegradedHost::new)
    }
}

impl ::protobuf::Clear for NoLongerDegradedHost {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NoLongerDegradedHost {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoLongerDegradedHost {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HealthCheckFailureType {
    ACTIVE = 0,
    PASSIVE = 1,
    NETWORK = 2,
}

impl ::protobuf::ProtobufEnum for HealthCheckFailureType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HealthCheckFailureType> {
        match value {
            0 => ::std::option::Option::Some(HealthCheckFailureType::ACTIVE),
            1 => ::std::option::Option::Some(HealthCheckFailureType::PASSIVE),
            2 => ::std::option::Option::Some(HealthCheckFailureType::NETWORK),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HealthCheckFailureType] = &[
            HealthCheckFailureType::ACTIVE,
            HealthCheckFailureType::PASSIVE,
            HealthCheckFailureType::NETWORK,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HealthCheckFailureType>("HealthCheckFailureType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HealthCheckFailureType {
}

impl ::std::default::Default for HealthCheckFailureType {
    fn default() -> Self {
        HealthCheckFailureType::ACTIVE
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckFailureType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HealthCheckerType {
    HTTP = 0,
    TCP = 1,
    GRPC = 2,
    REDIS = 3,
}

impl ::protobuf::ProtobufEnum for HealthCheckerType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HealthCheckerType> {
        match value {
            0 => ::std::option::Option::Some(HealthCheckerType::HTTP),
            1 => ::std::option::Option::Some(HealthCheckerType::TCP),
            2 => ::std::option::Option::Some(HealthCheckerType::GRPC),
            3 => ::std::option::Option::Some(HealthCheckerType::REDIS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HealthCheckerType] = &[
            HealthCheckerType::HTTP,
            HealthCheckerType::TCP,
            HealthCheckerType::GRPC,
            HealthCheckerType::REDIS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HealthCheckerType>("HealthCheckerType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HealthCheckerType {
}

impl ::std::default::Default for HealthCheckerType {
    fn default() -> Self {
        HealthCheckerType::HTTP
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheckerType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n0envoy/data/core/v2alpha/health_check_event.proto\x12\x17envoy.data.co\
    re.v2alpha\x1a\x1fenvoy/api/v2/core/address.proto\x1a\x1fgoogle/protobuf\
    /timestamp.proto\x1a\x1dudpa/annotations/status.proto\x1a\x17validate/va\
    lidate.proto\"\x9c\x06\n\x10HealthCheckEvent\x12d\n\x13health_checker_ty\
    pe\x18\x01\x20\x01(\x0e2*.envoy.data.core.v2alpha.HealthCheckerTypeR\x11\
    healthCheckerTypeB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12.\n\x04host\x18\
    \x02\x20\x01(\x0b2\x1a.envoy.api.v2.core.AddressR\x04host\x12*\n\x0cclus\
    ter_name\x18\x03\x20\x01(\tR\x0bclusterNameB\x07\xfaB\x04r\x02\x20\x01\
    \x12h\n\x15eject_unhealthy_event\x18\x04\x20\x01(\x0b22.envoy.data.core.\
    v2alpha.HealthCheckEjectUnhealthyH\0R\x13ejectUnhealthyEvent\x12\\\n\x11\
    add_healthy_event\x18\x05\x20\x01(\x0b2..envoy.data.core.v2alpha.HealthC\
    heckAddHealthyH\0R\x0faddHealthyEvent\x12j\n\x1ahealth_check_failure_eve\
    nt\x18\x07\x20\x01(\x0b2+.envoy.data.core.v2alpha.HealthCheckFailureH\0R\
    \x17healthCheckFailureEvent\x12b\n\x15degraded_healthy_host\x18\x08\x20\
    \x01(\x0b2,.envoy.data.core.v2alpha.DegradedHealthyHostH\0R\x13degradedH\
    ealthyHost\x12f\n\x17no_longer_degraded_host\x18\t\x20\x01(\x0b2-.envoy.\
    data.core.v2alpha.NoLongerDegradedHostH\0R\x14noLongerDegradedHost\x128\
    \n\ttimestamp\x18\x06\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\ttime\
    stampB\x0c\n\x05event\x12\x03\xf8B\x01\"y\n\x19HealthCheckEjectUnhealthy\
    \x12\\\n\x0cfailure_type\x18\x01\x20\x01(\x0e2/.envoy.data.core.v2alpha.\
    HealthCheckFailureTypeR\x0bfailureTypeB\x08\xfaB\x05\x82\x01\x02\x10\x01\
    \"8\n\x15HealthCheckAddHealthy\x12\x1f\n\x0bfirst_check\x18\x01\x20\x01(\
    \x08R\nfirstCheck\"\x93\x01\n\x12HealthCheckFailure\x12\\\n\x0cfailure_t\
    ype\x18\x01\x20\x01(\x0e2/.envoy.data.core.v2alpha.HealthCheckFailureTyp\
    eR\x0bfailureTypeB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12\x1f\n\x0bfirst_c\
    heck\x18\x02\x20\x01(\x08R\nfirstCheck\"\x15\n\x13DegradedHealthyHost\"\
    \x16\n\x14NoLongerDegradedHost*>\n\x16HealthCheckFailureType\x12\n\n\x06\
    ACTIVE\x10\0\x12\x0b\n\x07PASSIVE\x10\x01\x12\x0b\n\x07NETWORK\x10\x02*;\
    \n\x11HealthCheckerType\x12\x08\n\x04HTTP\x10\0\x12\x07\n\x03TCP\x10\x01\
    \x12\x08\n\x04GRPC\x10\x02\x12\t\n\x05REDIS\x10\x03BH\n%io.envoyproxy.en\
    voy.data.core.v2alphaB\x15HealthCheckEventProtoP\x01\xba\x80\xc8\xd1\x06\
    \x02\x10\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
