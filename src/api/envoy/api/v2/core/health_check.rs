// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/api/v2/core/health_check.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck {
    // message fields
    pub timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub initial_jitter: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub interval_jitter: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub interval_jitter_percent: u32,
    pub unhealthy_threshold: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub healthy_threshold: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub alt_port: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub reuse_connection: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub no_traffic_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub unhealthy_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub unhealthy_edge_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub healthy_edge_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub event_log_path: ::std::string::String,
    pub event_service: ::protobuf::SingularPtrField<super::event_service_config::EventServiceConfig>,
    pub always_log_health_check_failures: bool,
    pub tls_options: ::protobuf::SingularPtrField<HealthCheck_TlsOptions>,
    // message oneof groups
    pub health_checker: ::std::option::Option<HealthCheck_oneof_health_checker>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck {
    fn default() -> &'a HealthCheck {
        <HealthCheck as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HealthCheck_oneof_health_checker {
    http_health_check(HealthCheck_HttpHealthCheck),
    tcp_health_check(HealthCheck_TcpHealthCheck),
    grpc_health_check(HealthCheck_GrpcHealthCheck),
    custom_health_check(HealthCheck_CustomHealthCheck),
}

impl HealthCheck {
    pub fn new() -> HealthCheck {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration timeout = 1;


    pub fn get_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeout(&mut self) {
        self.timeout.clear();
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.timeout.is_none() {
            self.timeout.set_default();
        }
        self.timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration interval = 2;


    pub fn get_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interval(&mut self) {
        self.interval.clear();
    }

    pub fn has_interval(&self) -> bool {
        self.interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.interval.is_none() {
            self.interval.set_default();
        }
        self.interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration initial_jitter = 20;


    pub fn get_initial_jitter(&self) -> &::protobuf::well_known_types::Duration {
        self.initial_jitter.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initial_jitter(&mut self) {
        self.initial_jitter.clear();
    }

    pub fn has_initial_jitter(&self) -> bool {
        self.initial_jitter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_jitter(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.initial_jitter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_jitter(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.initial_jitter.is_none() {
            self.initial_jitter.set_default();
        }
        self.initial_jitter.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_jitter(&mut self) -> ::protobuf::well_known_types::Duration {
        self.initial_jitter.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration interval_jitter = 3;


    pub fn get_interval_jitter(&self) -> &::protobuf::well_known_types::Duration {
        self.interval_jitter.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_interval_jitter(&mut self) {
        self.interval_jitter.clear();
    }

    pub fn has_interval_jitter(&self) -> bool {
        self.interval_jitter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interval_jitter(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.interval_jitter = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interval_jitter(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.interval_jitter.is_none() {
            self.interval_jitter.set_default();
        }
        self.interval_jitter.as_mut().unwrap()
    }

    // Take field
    pub fn take_interval_jitter(&mut self) -> ::protobuf::well_known_types::Duration {
        self.interval_jitter.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // uint32 interval_jitter_percent = 18;


    pub fn get_interval_jitter_percent(&self) -> u32 {
        self.interval_jitter_percent
    }
    pub fn clear_interval_jitter_percent(&mut self) {
        self.interval_jitter_percent = 0;
    }

    // Param is passed by value, moved
    pub fn set_interval_jitter_percent(&mut self, v: u32) {
        self.interval_jitter_percent = v;
    }

    // .google.protobuf.UInt32Value unhealthy_threshold = 4;


    pub fn get_unhealthy_threshold(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.unhealthy_threshold.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unhealthy_threshold(&mut self) {
        self.unhealthy_threshold.clear();
    }

    pub fn has_unhealthy_threshold(&self) -> bool {
        self.unhealthy_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unhealthy_threshold(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.unhealthy_threshold = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unhealthy_threshold(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.unhealthy_threshold.is_none() {
            self.unhealthy_threshold.set_default();
        }
        self.unhealthy_threshold.as_mut().unwrap()
    }

    // Take field
    pub fn take_unhealthy_threshold(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.unhealthy_threshold.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.UInt32Value healthy_threshold = 5;


    pub fn get_healthy_threshold(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.healthy_threshold.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_healthy_threshold(&mut self) {
        self.healthy_threshold.clear();
    }

    pub fn has_healthy_threshold(&self) -> bool {
        self.healthy_threshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthy_threshold(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.healthy_threshold = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_healthy_threshold(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.healthy_threshold.is_none() {
            self.healthy_threshold.set_default();
        }
        self.healthy_threshold.as_mut().unwrap()
    }

    // Take field
    pub fn take_healthy_threshold(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.healthy_threshold.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.UInt32Value alt_port = 6;


    pub fn get_alt_port(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.alt_port.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_alt_port(&mut self) {
        self.alt_port.clear();
    }

    pub fn has_alt_port(&self) -> bool {
        self.alt_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_alt_port(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.alt_port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alt_port(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.alt_port.is_none() {
            self.alt_port.set_default();
        }
        self.alt_port.as_mut().unwrap()
    }

    // Take field
    pub fn take_alt_port(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.alt_port.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.BoolValue reuse_connection = 7;


    pub fn get_reuse_connection(&self) -> &::protobuf::well_known_types::BoolValue {
        self.reuse_connection.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reuse_connection(&mut self) {
        self.reuse_connection.clear();
    }

    pub fn has_reuse_connection(&self) -> bool {
        self.reuse_connection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reuse_connection(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.reuse_connection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reuse_connection(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.reuse_connection.is_none() {
            self.reuse_connection.set_default();
        }
        self.reuse_connection.as_mut().unwrap()
    }

    // Take field
    pub fn take_reuse_connection(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.reuse_connection.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.api.v2.core.HealthCheck.HttpHealthCheck http_health_check = 8;


    pub fn get_http_health_check(&self) -> &HealthCheck_HttpHealthCheck {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(ref v)) => v,
            _ => <HealthCheck_HttpHealthCheck as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_http_health_check(&mut self) {
        self.health_checker = ::std::option::Option::None;
    }

    pub fn has_http_health_check(&self) -> bool {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_http_health_check(&mut self, v: HealthCheck_HttpHealthCheck) {
        self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(v))
    }

    // Mutable pointer to the field.
    pub fn mut_http_health_check(&mut self) -> &mut HealthCheck_HttpHealthCheck {
        if let ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(_)) = self.health_checker {
        } else {
            self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(HealthCheck_HttpHealthCheck::new()));
        }
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_http_health_check(&mut self) -> HealthCheck_HttpHealthCheck {
        if self.has_http_health_check() {
            match self.health_checker.take() {
                ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheck_HttpHealthCheck::new()
        }
    }

    // .envoy.api.v2.core.HealthCheck.TcpHealthCheck tcp_health_check = 9;


    pub fn get_tcp_health_check(&self) -> &HealthCheck_TcpHealthCheck {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(ref v)) => v,
            _ => <HealthCheck_TcpHealthCheck as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tcp_health_check(&mut self) {
        self.health_checker = ::std::option::Option::None;
    }

    pub fn has_tcp_health_check(&self) -> bool {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tcp_health_check(&mut self, v: HealthCheck_TcpHealthCheck) {
        self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tcp_health_check(&mut self) -> &mut HealthCheck_TcpHealthCheck {
        if let ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(_)) = self.health_checker {
        } else {
            self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(HealthCheck_TcpHealthCheck::new()));
        }
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tcp_health_check(&mut self) -> HealthCheck_TcpHealthCheck {
        if self.has_tcp_health_check() {
            match self.health_checker.take() {
                ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheck_TcpHealthCheck::new()
        }
    }

    // .envoy.api.v2.core.HealthCheck.GrpcHealthCheck grpc_health_check = 11;


    pub fn get_grpc_health_check(&self) -> &HealthCheck_GrpcHealthCheck {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(ref v)) => v,
            _ => <HealthCheck_GrpcHealthCheck as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_grpc_health_check(&mut self) {
        self.health_checker = ::std::option::Option::None;
    }

    pub fn has_grpc_health_check(&self) -> bool {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_grpc_health_check(&mut self, v: HealthCheck_GrpcHealthCheck) {
        self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(v))
    }

    // Mutable pointer to the field.
    pub fn mut_grpc_health_check(&mut self) -> &mut HealthCheck_GrpcHealthCheck {
        if let ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(_)) = self.health_checker {
        } else {
            self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(HealthCheck_GrpcHealthCheck::new()));
        }
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_grpc_health_check(&mut self) -> HealthCheck_GrpcHealthCheck {
        if self.has_grpc_health_check() {
            match self.health_checker.take() {
                ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheck_GrpcHealthCheck::new()
        }
    }

    // .envoy.api.v2.core.HealthCheck.CustomHealthCheck custom_health_check = 13;


    pub fn get_custom_health_check(&self) -> &HealthCheck_CustomHealthCheck {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(ref v)) => v,
            _ => <HealthCheck_CustomHealthCheck as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_custom_health_check(&mut self) {
        self.health_checker = ::std::option::Option::None;
    }

    pub fn has_custom_health_check(&self) -> bool {
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_custom_health_check(&mut self, v: HealthCheck_CustomHealthCheck) {
        self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(v))
    }

    // Mutable pointer to the field.
    pub fn mut_custom_health_check(&mut self) -> &mut HealthCheck_CustomHealthCheck {
        if let ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(_)) = self.health_checker {
        } else {
            self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(HealthCheck_CustomHealthCheck::new()));
        }
        match self.health_checker {
            ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_custom_health_check(&mut self) -> HealthCheck_CustomHealthCheck {
        if self.has_custom_health_check() {
            match self.health_checker.take() {
                ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(v)) => v,
                _ => panic!(),
            }
        } else {
            HealthCheck_CustomHealthCheck::new()
        }
    }

    // .google.protobuf.Duration no_traffic_interval = 12;


    pub fn get_no_traffic_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.no_traffic_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_no_traffic_interval(&mut self) {
        self.no_traffic_interval.clear();
    }

    pub fn has_no_traffic_interval(&self) -> bool {
        self.no_traffic_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_traffic_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.no_traffic_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_no_traffic_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.no_traffic_interval.is_none() {
            self.no_traffic_interval.set_default();
        }
        self.no_traffic_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_no_traffic_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.no_traffic_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration unhealthy_interval = 14;


    pub fn get_unhealthy_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.unhealthy_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unhealthy_interval(&mut self) {
        self.unhealthy_interval.clear();
    }

    pub fn has_unhealthy_interval(&self) -> bool {
        self.unhealthy_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unhealthy_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.unhealthy_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unhealthy_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.unhealthy_interval.is_none() {
            self.unhealthy_interval.set_default();
        }
        self.unhealthy_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_unhealthy_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.unhealthy_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration unhealthy_edge_interval = 15;


    pub fn get_unhealthy_edge_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.unhealthy_edge_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_unhealthy_edge_interval(&mut self) {
        self.unhealthy_edge_interval.clear();
    }

    pub fn has_unhealthy_edge_interval(&self) -> bool {
        self.unhealthy_edge_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unhealthy_edge_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.unhealthy_edge_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unhealthy_edge_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.unhealthy_edge_interval.is_none() {
            self.unhealthy_edge_interval.set_default();
        }
        self.unhealthy_edge_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_unhealthy_edge_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.unhealthy_edge_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration healthy_edge_interval = 16;


    pub fn get_healthy_edge_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.healthy_edge_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_healthy_edge_interval(&mut self) {
        self.healthy_edge_interval.clear();
    }

    pub fn has_healthy_edge_interval(&self) -> bool {
        self.healthy_edge_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthy_edge_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.healthy_edge_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_healthy_edge_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.healthy_edge_interval.is_none() {
            self.healthy_edge_interval.set_default();
        }
        self.healthy_edge_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_healthy_edge_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.healthy_edge_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // string event_log_path = 17;


    pub fn get_event_log_path(&self) -> &str {
        &self.event_log_path
    }
    pub fn clear_event_log_path(&mut self) {
        self.event_log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_log_path(&mut self, v: ::std::string::String) {
        self.event_log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.event_log_path
    }

    // Take field
    pub fn take_event_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_log_path, ::std::string::String::new())
    }

    // .envoy.api.v2.core.EventServiceConfig event_service = 22;


    pub fn get_event_service(&self) -> &super::event_service_config::EventServiceConfig {
        self.event_service.as_ref().unwrap_or_else(|| <super::event_service_config::EventServiceConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event_service(&mut self) {
        self.event_service.clear();
    }

    pub fn has_event_service(&self) -> bool {
        self.event_service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_service(&mut self, v: super::event_service_config::EventServiceConfig) {
        self.event_service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_service(&mut self) -> &mut super::event_service_config::EventServiceConfig {
        if self.event_service.is_none() {
            self.event_service.set_default();
        }
        self.event_service.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_service(&mut self) -> super::event_service_config::EventServiceConfig {
        self.event_service.take().unwrap_or_else(|| super::event_service_config::EventServiceConfig::new())
    }

    // bool always_log_health_check_failures = 19;


    pub fn get_always_log_health_check_failures(&self) -> bool {
        self.always_log_health_check_failures
    }
    pub fn clear_always_log_health_check_failures(&mut self) {
        self.always_log_health_check_failures = false;
    }

    // Param is passed by value, moved
    pub fn set_always_log_health_check_failures(&mut self, v: bool) {
        self.always_log_health_check_failures = v;
    }

    // .envoy.api.v2.core.HealthCheck.TlsOptions tls_options = 21;


    pub fn get_tls_options(&self) -> &HealthCheck_TlsOptions {
        self.tls_options.as_ref().unwrap_or_else(|| <HealthCheck_TlsOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tls_options(&mut self) {
        self.tls_options.clear();
    }

    pub fn has_tls_options(&self) -> bool {
        self.tls_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_options(&mut self, v: HealthCheck_TlsOptions) {
        self.tls_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls_options(&mut self) -> &mut HealthCheck_TlsOptions {
        if self.tls_options.is_none() {
            self.tls_options.set_default();
        }
        self.tls_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_tls_options(&mut self) -> HealthCheck_TlsOptions {
        self.tls_options.take().unwrap_or_else(|| HealthCheck_TlsOptions::new())
    }
}

impl ::protobuf::Message for HealthCheck {
    fn is_initialized(&self) -> bool {
        for v in &self.timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initial_jitter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.interval_jitter {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unhealthy_threshold {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.healthy_threshold {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.alt_port {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reuse_connection {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(HealthCheck_oneof_health_checker::http_health_check(ref v)) = self.health_checker {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheck_oneof_health_checker::tcp_health_check(ref v)) = self.health_checker {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheck_oneof_health_checker::grpc_health_check(ref v)) = self.health_checker {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheck_oneof_health_checker::custom_health_check(ref v)) = self.health_checker {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.no_traffic_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unhealthy_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.unhealthy_edge_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.healthy_edge_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.event_service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tls_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeout)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interval)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initial_jitter)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.interval_jitter)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.interval_jitter_percent = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unhealthy_threshold)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.healthy_threshold)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.alt_port)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reuse_connection)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::http_health_check(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::tcp_health_check(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::grpc_health_check(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.health_checker = ::std::option::Option::Some(HealthCheck_oneof_health_checker::custom_health_check(is.read_message()?));
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.no_traffic_interval)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unhealthy_interval)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.unhealthy_edge_interval)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.healthy_edge_interval)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_log_path)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_service)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.always_log_health_check_failures = tmp;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tls_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initial_jitter.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.interval_jitter.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.interval_jitter_percent != 0 {
            my_size += ::protobuf::rt::value_size(18, self.interval_jitter_percent, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.unhealthy_threshold.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.healthy_threshold.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.alt_port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reuse_connection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.no_traffic_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unhealthy_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.unhealthy_edge_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.healthy_edge_interval.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.event_log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.event_log_path);
        }
        if let Some(ref v) = self.event_service.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.always_log_health_check_failures != false {
            my_size += 3;
        }
        if let Some(ref v) = self.tls_options.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.health_checker {
            match v {
                &HealthCheck_oneof_health_checker::http_health_check(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheck_oneof_health_checker::tcp_health_check(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheck_oneof_health_checker::grpc_health_check(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheck_oneof_health_checker::custom_health_check(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.timeout.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initial_jitter.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.interval_jitter.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.interval_jitter_percent != 0 {
            os.write_uint32(18, self.interval_jitter_percent)?;
        }
        if let Some(ref v) = self.unhealthy_threshold.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.healthy_threshold.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.alt_port.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reuse_connection.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.no_traffic_interval.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unhealthy_interval.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.unhealthy_edge_interval.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.healthy_edge_interval.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.event_log_path.is_empty() {
            os.write_string(17, &self.event_log_path)?;
        }
        if let Some(ref v) = self.event_service.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.always_log_health_check_failures != false {
            os.write_bool(19, self.always_log_health_check_failures)?;
        }
        if let Some(ref v) = self.tls_options.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.health_checker {
            match v {
                &HealthCheck_oneof_health_checker::http_health_check(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheck_oneof_health_checker::tcp_health_check(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheck_oneof_health_checker::grpc_health_check(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheck_oneof_health_checker::custom_health_check(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck {
        HealthCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "timeout",
                |m: &HealthCheck| { &m.timeout },
                |m: &mut HealthCheck| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "interval",
                |m: &HealthCheck| { &m.interval },
                |m: &mut HealthCheck| { &mut m.interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "initial_jitter",
                |m: &HealthCheck| { &m.initial_jitter },
                |m: &mut HealthCheck| { &mut m.initial_jitter },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "interval_jitter",
                |m: &HealthCheck| { &m.interval_jitter },
                |m: &mut HealthCheck| { &mut m.interval_jitter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "interval_jitter_percent",
                |m: &HealthCheck| { &m.interval_jitter_percent },
                |m: &mut HealthCheck| { &mut m.interval_jitter_percent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "unhealthy_threshold",
                |m: &HealthCheck| { &m.unhealthy_threshold },
                |m: &mut HealthCheck| { &mut m.unhealthy_threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "healthy_threshold",
                |m: &HealthCheck| { &m.healthy_threshold },
                |m: &mut HealthCheck| { &mut m.healthy_threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "alt_port",
                |m: &HealthCheck| { &m.alt_port },
                |m: &mut HealthCheck| { &mut m.alt_port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "reuse_connection",
                |m: &HealthCheck| { &m.reuse_connection },
                |m: &mut HealthCheck| { &mut m.reuse_connection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheck_HttpHealthCheck>(
                "http_health_check",
                HealthCheck::has_http_health_check,
                HealthCheck::get_http_health_check,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheck_TcpHealthCheck>(
                "tcp_health_check",
                HealthCheck::has_tcp_health_check,
                HealthCheck::get_tcp_health_check,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheck_GrpcHealthCheck>(
                "grpc_health_check",
                HealthCheck::has_grpc_health_check,
                HealthCheck::get_grpc_health_check,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HealthCheck_CustomHealthCheck>(
                "custom_health_check",
                HealthCheck::has_custom_health_check,
                HealthCheck::get_custom_health_check,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "no_traffic_interval",
                |m: &HealthCheck| { &m.no_traffic_interval },
                |m: &mut HealthCheck| { &mut m.no_traffic_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "unhealthy_interval",
                |m: &HealthCheck| { &m.unhealthy_interval },
                |m: &mut HealthCheck| { &mut m.unhealthy_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "unhealthy_edge_interval",
                |m: &HealthCheck| { &m.unhealthy_edge_interval },
                |m: &mut HealthCheck| { &mut m.unhealthy_edge_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "healthy_edge_interval",
                |m: &HealthCheck| { &m.healthy_edge_interval },
                |m: &mut HealthCheck| { &mut m.healthy_edge_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_log_path",
                |m: &HealthCheck| { &m.event_log_path },
                |m: &mut HealthCheck| { &mut m.event_log_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::event_service_config::EventServiceConfig>>(
                "event_service",
                |m: &HealthCheck| { &m.event_service },
                |m: &mut HealthCheck| { &mut m.event_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "always_log_health_check_failures",
                |m: &HealthCheck| { &m.always_log_health_check_failures },
                |m: &mut HealthCheck| { &mut m.always_log_health_check_failures },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_TlsOptions>>(
                "tls_options",
                |m: &HealthCheck| { &m.tls_options },
                |m: &mut HealthCheck| { &mut m.tls_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck>(
                "HealthCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck {
        static instance: ::protobuf::rt::LazyV2<HealthCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck::new)
    }
}

impl ::protobuf::Clear for HealthCheck {
    fn clear(&mut self) {
        self.timeout.clear();
        self.interval.clear();
        self.initial_jitter.clear();
        self.interval_jitter.clear();
        self.interval_jitter_percent = 0;
        self.unhealthy_threshold.clear();
        self.healthy_threshold.clear();
        self.alt_port.clear();
        self.reuse_connection.clear();
        self.health_checker = ::std::option::Option::None;
        self.health_checker = ::std::option::Option::None;
        self.health_checker = ::std::option::Option::None;
        self.health_checker = ::std::option::Option::None;
        self.no_traffic_interval.clear();
        self.unhealthy_interval.clear();
        self.unhealthy_edge_interval.clear();
        self.healthy_edge_interval.clear();
        self.event_log_path.clear();
        self.event_service.clear();
        self.always_log_health_check_failures = false;
        self.tls_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_Payload {
    // message oneof groups
    pub payload: ::std::option::Option<HealthCheck_Payload_oneof_payload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_Payload {
    fn default() -> &'a HealthCheck_Payload {
        <HealthCheck_Payload as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HealthCheck_Payload_oneof_payload {
    text(::std::string::String),
    binary(::std::vec::Vec<u8>),
}

impl HealthCheck_Payload {
    pub fn new() -> HealthCheck_Payload {
        ::std::default::Default::default()
    }

    // string text = 1;


    pub fn get_text(&self) -> &str {
        match self.payload {
            ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_text(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.payload = ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(v))
    }

    // Mutable pointer to the field.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(::std::string::String::new()));
        }
        match self.payload {
            ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        if self.has_text() {
            match self.payload.take() {
                ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bytes binary = 2;


    pub fn get_binary(&self) -> &[u8] {
        match self.payload {
            ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_binary(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_binary(&self) -> bool {
        match self.payload {
            ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_binary(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(v))
    }

    // Mutable pointer to the field.
    pub fn mut_binary(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(_)) = self.payload {
        } else {
            self.payload = ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(::std::vec::Vec::new()));
        }
        match self.payload {
            ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_binary(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_binary() {
            match self.payload.take() {
                ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for HealthCheck_Payload {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::text(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.payload = ::std::option::Option::Some(HealthCheck_Payload_oneof_payload::binary(is.read_bytes()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &HealthCheck_Payload_oneof_payload::text(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &HealthCheck_Payload_oneof_payload::binary(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.payload {
            match v {
                &HealthCheck_Payload_oneof_payload::text(ref v) => {
                    os.write_string(1, v)?;
                },
                &HealthCheck_Payload_oneof_payload::binary(ref v) => {
                    os.write_bytes(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_Payload {
        HealthCheck_Payload::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "text",
                HealthCheck_Payload::has_text,
                HealthCheck_Payload::get_text,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "binary",
                HealthCheck_Payload::has_binary,
                HealthCheck_Payload::get_binary,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_Payload>(
                "HealthCheck.Payload",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_Payload {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_Payload> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_Payload::new)
    }
}

impl ::protobuf::Clear for HealthCheck_Payload {
    fn clear(&mut self) {
        self.payload = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_Payload {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_Payload {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_HttpHealthCheck {
    // message fields
    pub host: ::std::string::String,
    pub path: ::std::string::String,
    pub send: ::protobuf::SingularPtrField<HealthCheck_Payload>,
    pub receive: ::protobuf::SingularPtrField<HealthCheck_Payload>,
    pub service_name: ::std::string::String,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub use_http2: bool,
    pub expected_statuses: ::protobuf::RepeatedField<super::range::Int64Range>,
    pub codec_client_type: super::http::CodecClientType,
    pub service_name_matcher: ::protobuf::SingularPtrField<super::string::StringMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_HttpHealthCheck {
    fn default() -> &'a HealthCheck_HttpHealthCheck {
        <HealthCheck_HttpHealthCheck as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheck_HttpHealthCheck {
    pub fn new() -> HealthCheck_HttpHealthCheck {
        ::std::default::Default::default()
    }

    // string host = 1;


    pub fn get_host(&self) -> &str {
        &self.host
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        &mut self.host
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host, ::std::string::String::new())
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }

    // .envoy.api.v2.core.HealthCheck.Payload send = 3;


    pub fn get_send(&self) -> &HealthCheck_Payload {
        self.send.as_ref().unwrap_or_else(|| <HealthCheck_Payload as ::protobuf::Message>::default_instance())
    }
    pub fn clear_send(&mut self) {
        self.send.clear();
    }

    pub fn has_send(&self) -> bool {
        self.send.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: HealthCheck_Payload) {
        self.send = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send(&mut self) -> &mut HealthCheck_Payload {
        if self.send.is_none() {
            self.send.set_default();
        }
        self.send.as_mut().unwrap()
    }

    // Take field
    pub fn take_send(&mut self) -> HealthCheck_Payload {
        self.send.take().unwrap_or_else(|| HealthCheck_Payload::new())
    }

    // .envoy.api.v2.core.HealthCheck.Payload receive = 4;


    pub fn get_receive(&self) -> &HealthCheck_Payload {
        self.receive.as_ref().unwrap_or_else(|| <HealthCheck_Payload as ::protobuf::Message>::default_instance())
    }
    pub fn clear_receive(&mut self) {
        self.receive.clear();
    }

    pub fn has_receive(&self) -> bool {
        self.receive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: HealthCheck_Payload) {
        self.receive = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_receive(&mut self) -> &mut HealthCheck_Payload {
        if self.receive.is_none() {
            self.receive.set_default();
        }
        self.receive.as_mut().unwrap()
    }

    // Take field
    pub fn take_receive(&mut self) -> HealthCheck_Payload {
        self.receive.take().unwrap_or_else(|| HealthCheck_Payload::new())
    }

    // string service_name = 5;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption request_headers_to_add = 6;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 8;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // bool use_http2 = 7;


    pub fn get_use_http2(&self) -> bool {
        self.use_http2
    }
    pub fn clear_use_http2(&mut self) {
        self.use_http2 = false;
    }

    // Param is passed by value, moved
    pub fn set_use_http2(&mut self, v: bool) {
        self.use_http2 = v;
    }

    // repeated .envoy.type.Int64Range expected_statuses = 9;


    pub fn get_expected_statuses(&self) -> &[super::range::Int64Range] {
        &self.expected_statuses
    }
    pub fn clear_expected_statuses(&mut self) {
        self.expected_statuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_expected_statuses(&mut self, v: ::protobuf::RepeatedField<super::range::Int64Range>) {
        self.expected_statuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_expected_statuses(&mut self) -> &mut ::protobuf::RepeatedField<super::range::Int64Range> {
        &mut self.expected_statuses
    }

    // Take field
    pub fn take_expected_statuses(&mut self) -> ::protobuf::RepeatedField<super::range::Int64Range> {
        ::std::mem::replace(&mut self.expected_statuses, ::protobuf::RepeatedField::new())
    }

    // .envoy.type.CodecClientType codec_client_type = 10;


    pub fn get_codec_client_type(&self) -> super::http::CodecClientType {
        self.codec_client_type
    }
    pub fn clear_codec_client_type(&mut self) {
        self.codec_client_type = super::http::CodecClientType::HTTP1;
    }

    // Param is passed by value, moved
    pub fn set_codec_client_type(&mut self, v: super::http::CodecClientType) {
        self.codec_client_type = v;
    }

    // .envoy.type.matcher.StringMatcher service_name_matcher = 11;


    pub fn get_service_name_matcher(&self) -> &super::string::StringMatcher {
        self.service_name_matcher.as_ref().unwrap_or_else(|| <super::string::StringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service_name_matcher(&mut self) {
        self.service_name_matcher.clear();
    }

    pub fn has_service_name_matcher(&self) -> bool {
        self.service_name_matcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service_name_matcher(&mut self, v: super::string::StringMatcher) {
        self.service_name_matcher = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name_matcher(&mut self) -> &mut super::string::StringMatcher {
        if self.service_name_matcher.is_none() {
            self.service_name_matcher.set_default();
        }
        self.service_name_matcher.as_mut().unwrap()
    }

    // Take field
    pub fn take_service_name_matcher(&mut self) -> super::string::StringMatcher {
        self.service_name_matcher.take().unwrap_or_else(|| super::string::StringMatcher::new())
    }
}

impl ::protobuf::Message for HealthCheck_HttpHealthCheck {
    fn is_initialized(&self) -> bool {
        for v in &self.send {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.receive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.expected_statuses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service_name_matcher {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.receive)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_http2 = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.expected_statuses)?;
                },
                10 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.codec_client_type, 10, &mut self.unknown_fields)?
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service_name_matcher)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path);
        }
        if let Some(ref v) = self.send.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.receive.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.service_name);
        }
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.use_http2 != false {
            my_size += 2;
        }
        for value in &self.expected_statuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.codec_client_type != super::http::CodecClientType::HTTP1 {
            my_size += ::protobuf::rt::enum_size(10, self.codec_client_type);
        }
        if let Some(ref v) = self.service_name_matcher.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host.is_empty() {
            os.write_string(1, &self.host)?;
        }
        if !self.path.is_empty() {
            os.write_string(2, &self.path)?;
        }
        if let Some(ref v) = self.send.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.receive.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.service_name.is_empty() {
            os.write_string(5, &self.service_name)?;
        }
        for v in &self.request_headers_to_add {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(8, &v)?;
        };
        if self.use_http2 != false {
            os.write_bool(7, self.use_http2)?;
        }
        for v in &self.expected_statuses {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.codec_client_type != super::http::CodecClientType::HTTP1 {
            os.write_enum(10, ::protobuf::ProtobufEnum::value(&self.codec_client_type))?;
        }
        if let Some(ref v) = self.service_name_matcher.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_HttpHealthCheck {
        HealthCheck_HttpHealthCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &HealthCheck_HttpHealthCheck| { &m.host },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &HealthCheck_HttpHealthCheck| { &m.path },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_Payload>>(
                "send",
                |m: &HealthCheck_HttpHealthCheck| { &m.send },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.send },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_Payload>>(
                "receive",
                |m: &HealthCheck_HttpHealthCheck| { &m.receive },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.receive },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &HealthCheck_HttpHealthCheck| { &m.service_name },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &HealthCheck_HttpHealthCheck| { &m.request_headers_to_add },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &HealthCheck_HttpHealthCheck| { &m.request_headers_to_remove },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_http2",
                |m: &HealthCheck_HttpHealthCheck| { &m.use_http2 },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.use_http2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::range::Int64Range>>(
                "expected_statuses",
                |m: &HealthCheck_HttpHealthCheck| { &m.expected_statuses },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.expected_statuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::http::CodecClientType>>(
                "codec_client_type",
                |m: &HealthCheck_HttpHealthCheck| { &m.codec_client_type },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.codec_client_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::StringMatcher>>(
                "service_name_matcher",
                |m: &HealthCheck_HttpHealthCheck| { &m.service_name_matcher },
                |m: &mut HealthCheck_HttpHealthCheck| { &mut m.service_name_matcher },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_HttpHealthCheck>(
                "HealthCheck.HttpHealthCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_HttpHealthCheck {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_HttpHealthCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_HttpHealthCheck::new)
    }
}

impl ::protobuf::Clear for HealthCheck_HttpHealthCheck {
    fn clear(&mut self) {
        self.host.clear();
        self.path.clear();
        self.send.clear();
        self.receive.clear();
        self.service_name.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.use_http2 = false;
        self.expected_statuses.clear();
        self.codec_client_type = super::http::CodecClientType::HTTP1;
        self.service_name_matcher.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_HttpHealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_HttpHealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_TcpHealthCheck {
    // message fields
    pub send: ::protobuf::SingularPtrField<HealthCheck_Payload>,
    pub receive: ::protobuf::RepeatedField<HealthCheck_Payload>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_TcpHealthCheck {
    fn default() -> &'a HealthCheck_TcpHealthCheck {
        <HealthCheck_TcpHealthCheck as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheck_TcpHealthCheck {
    pub fn new() -> HealthCheck_TcpHealthCheck {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.core.HealthCheck.Payload send = 1;


    pub fn get_send(&self) -> &HealthCheck_Payload {
        self.send.as_ref().unwrap_or_else(|| <HealthCheck_Payload as ::protobuf::Message>::default_instance())
    }
    pub fn clear_send(&mut self) {
        self.send.clear();
    }

    pub fn has_send(&self) -> bool {
        self.send.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: HealthCheck_Payload) {
        self.send = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_send(&mut self) -> &mut HealthCheck_Payload {
        if self.send.is_none() {
            self.send.set_default();
        }
        self.send.as_mut().unwrap()
    }

    // Take field
    pub fn take_send(&mut self) -> HealthCheck_Payload {
        self.send.take().unwrap_or_else(|| HealthCheck_Payload::new())
    }

    // repeated .envoy.api.v2.core.HealthCheck.Payload receive = 2;


    pub fn get_receive(&self) -> &[HealthCheck_Payload] {
        &self.receive
    }
    pub fn clear_receive(&mut self) {
        self.receive.clear();
    }

    // Param is passed by value, moved
    pub fn set_receive(&mut self, v: ::protobuf::RepeatedField<HealthCheck_Payload>) {
        self.receive = v;
    }

    // Mutable pointer to the field.
    pub fn mut_receive(&mut self) -> &mut ::protobuf::RepeatedField<HealthCheck_Payload> {
        &mut self.receive
    }

    // Take field
    pub fn take_receive(&mut self) -> ::protobuf::RepeatedField<HealthCheck_Payload> {
        ::std::mem::replace(&mut self.receive, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HealthCheck_TcpHealthCheck {
    fn is_initialized(&self) -> bool {
        for v in &self.send {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.receive {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.send)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.receive)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.send.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.receive {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.send.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.receive {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_TcpHealthCheck {
        HealthCheck_TcpHealthCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_Payload>>(
                "send",
                |m: &HealthCheck_TcpHealthCheck| { &m.send },
                |m: &mut HealthCheck_TcpHealthCheck| { &mut m.send },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HealthCheck_Payload>>(
                "receive",
                |m: &HealthCheck_TcpHealthCheck| { &m.receive },
                |m: &mut HealthCheck_TcpHealthCheck| { &mut m.receive },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_TcpHealthCheck>(
                "HealthCheck.TcpHealthCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_TcpHealthCheck {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_TcpHealthCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_TcpHealthCheck::new)
    }
}

impl ::protobuf::Clear for HealthCheck_TcpHealthCheck {
    fn clear(&mut self) {
        self.send.clear();
        self.receive.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_TcpHealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_TcpHealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_RedisHealthCheck {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_RedisHealthCheck {
    fn default() -> &'a HealthCheck_RedisHealthCheck {
        <HealthCheck_RedisHealthCheck as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheck_RedisHealthCheck {
    pub fn new() -> HealthCheck_RedisHealthCheck {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HealthCheck_RedisHealthCheck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_RedisHealthCheck {
        HealthCheck_RedisHealthCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &HealthCheck_RedisHealthCheck| { &m.key },
                |m: &mut HealthCheck_RedisHealthCheck| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_RedisHealthCheck>(
                "HealthCheck.RedisHealthCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_RedisHealthCheck {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_RedisHealthCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_RedisHealthCheck::new)
    }
}

impl ::protobuf::Clear for HealthCheck_RedisHealthCheck {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_RedisHealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_RedisHealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_GrpcHealthCheck {
    // message fields
    pub service_name: ::std::string::String,
    pub authority: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_GrpcHealthCheck {
    fn default() -> &'a HealthCheck_GrpcHealthCheck {
        <HealthCheck_GrpcHealthCheck as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheck_GrpcHealthCheck {
    pub fn new() -> HealthCheck_GrpcHealthCheck {
        ::std::default::Default::default()
    }

    // string service_name = 1;


    pub fn get_service_name(&self) -> &str {
        &self.service_name
    }
    pub fn clear_service_name(&mut self) {
        self.service_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_name(&mut self, v: ::std::string::String) {
        self.service_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_name(&mut self) -> &mut ::std::string::String {
        &mut self.service_name
    }

    // Take field
    pub fn take_service_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_name, ::std::string::String::new())
    }

    // string authority = 2;


    pub fn get_authority(&self) -> &str {
        &self.authority
    }
    pub fn clear_authority(&mut self) {
        self.authority.clear();
    }

    // Param is passed by value, moved
    pub fn set_authority(&mut self, v: ::std::string::String) {
        self.authority = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authority(&mut self) -> &mut ::std::string::String {
        &mut self.authority
    }

    // Take field
    pub fn take_authority(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.authority, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HealthCheck_GrpcHealthCheck {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.authority)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.service_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service_name);
        }
        if !self.authority.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.authority);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.service_name.is_empty() {
            os.write_string(1, &self.service_name)?;
        }
        if !self.authority.is_empty() {
            os.write_string(2, &self.authority)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_GrpcHealthCheck {
        HealthCheck_GrpcHealthCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_name",
                |m: &HealthCheck_GrpcHealthCheck| { &m.service_name },
                |m: &mut HealthCheck_GrpcHealthCheck| { &mut m.service_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "authority",
                |m: &HealthCheck_GrpcHealthCheck| { &m.authority },
                |m: &mut HealthCheck_GrpcHealthCheck| { &mut m.authority },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_GrpcHealthCheck>(
                "HealthCheck.GrpcHealthCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_GrpcHealthCheck {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_GrpcHealthCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_GrpcHealthCheck::new)
    }
}

impl ::protobuf::Clear for HealthCheck_GrpcHealthCheck {
    fn clear(&mut self) {
        self.service_name.clear();
        self.authority.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_GrpcHealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_GrpcHealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_CustomHealthCheck {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub config_type: ::std::option::Option<HealthCheck_CustomHealthCheck_oneof_config_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_CustomHealthCheck {
    fn default() -> &'a HealthCheck_CustomHealthCheck {
        <HealthCheck_CustomHealthCheck as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HealthCheck_CustomHealthCheck_oneof_config_type {
    config(::protobuf::well_known_types::Struct),
    typed_config(::protobuf::well_known_types::Any),
}

impl HealthCheck_CustomHealthCheck {
    pub fn new() -> HealthCheck_CustomHealthCheck {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct config = 2;


    pub fn get_config(&self) -> &::protobuf::well_known_types::Struct {
        match self.config_type {
            ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(ref v)) => v,
            _ => <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.config_type = ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if let ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(::protobuf::well_known_types::Struct::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> ::protobuf::well_known_types::Struct {
        if self.has_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Struct::new()
        }
    }

    // .google.protobuf.Any typed_config = 3;


    pub fn get_typed_config(&self) -> &::protobuf::well_known_types::Any {
        match self.config_type {
            ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_typed_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_typed_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config_type = ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(::protobuf::well_known_types::Any::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_typed_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for HealthCheck_CustomHealthCheck {
    fn is_initialized(&self) -> bool {
        if let Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::config(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &HealthCheck_CustomHealthCheck_oneof_config_type::config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &HealthCheck_CustomHealthCheck_oneof_config_type::config(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HealthCheck_CustomHealthCheck_oneof_config_type::typed_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_CustomHealthCheck {
        HealthCheck_CustomHealthCheck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HealthCheck_CustomHealthCheck| { &m.name },
                |m: &mut HealthCheck_CustomHealthCheck| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Struct>(
                "config",
                HealthCheck_CustomHealthCheck::has_config,
                HealthCheck_CustomHealthCheck::get_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "typed_config",
                HealthCheck_CustomHealthCheck::has_typed_config,
                HealthCheck_CustomHealthCheck::get_typed_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_CustomHealthCheck>(
                "HealthCheck.CustomHealthCheck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_CustomHealthCheck {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_CustomHealthCheck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_CustomHealthCheck::new)
    }
}

impl ::protobuf::Clear for HealthCheck_CustomHealthCheck {
    fn clear(&mut self) {
        self.name.clear();
        self.config_type = ::std::option::Option::None;
        self.config_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_CustomHealthCheck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_CustomHealthCheck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthCheck_TlsOptions {
    // message fields
    pub alpn_protocols: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthCheck_TlsOptions {
    fn default() -> &'a HealthCheck_TlsOptions {
        <HealthCheck_TlsOptions as ::protobuf::Message>::default_instance()
    }
}

impl HealthCheck_TlsOptions {
    pub fn new() -> HealthCheck_TlsOptions {
        ::std::default::Default::default()
    }

    // repeated string alpn_protocols = 1;


    pub fn get_alpn_protocols(&self) -> &[::std::string::String] {
        &self.alpn_protocols
    }
    pub fn clear_alpn_protocols(&mut self) {
        self.alpn_protocols.clear();
    }

    // Param is passed by value, moved
    pub fn set_alpn_protocols(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.alpn_protocols = v;
    }

    // Mutable pointer to the field.
    pub fn mut_alpn_protocols(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.alpn_protocols
    }

    // Take field
    pub fn take_alpn_protocols(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.alpn_protocols, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HealthCheck_TlsOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.alpn_protocols)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.alpn_protocols {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.alpn_protocols {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthCheck_TlsOptions {
        HealthCheck_TlsOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alpn_protocols",
                |m: &HealthCheck_TlsOptions| { &m.alpn_protocols },
                |m: &mut HealthCheck_TlsOptions| { &mut m.alpn_protocols },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HealthCheck_TlsOptions>(
                "HealthCheck.TlsOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HealthCheck_TlsOptions {
        static instance: ::protobuf::rt::LazyV2<HealthCheck_TlsOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HealthCheck_TlsOptions::new)
    }
}

impl ::protobuf::Clear for HealthCheck_TlsOptions {
    fn clear(&mut self) {
        self.alpn_protocols.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthCheck_TlsOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthCheck_TlsOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HealthStatus {
    UNKNOWN = 0,
    HEALTHY = 1,
    UNHEALTHY = 2,
    DRAINING = 3,
    TIMEOUT = 4,
    DEGRADED = 5,
}

impl ::protobuf::ProtobufEnum for HealthStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HealthStatus> {
        match value {
            0 => ::std::option::Option::Some(HealthStatus::UNKNOWN),
            1 => ::std::option::Option::Some(HealthStatus::HEALTHY),
            2 => ::std::option::Option::Some(HealthStatus::UNHEALTHY),
            3 => ::std::option::Option::Some(HealthStatus::DRAINING),
            4 => ::std::option::Option::Some(HealthStatus::TIMEOUT),
            5 => ::std::option::Option::Some(HealthStatus::DEGRADED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HealthStatus] = &[
            HealthStatus::UNKNOWN,
            HealthStatus::HEALTHY,
            HealthStatus::UNHEALTHY,
            HealthStatus::DRAINING,
            HealthStatus::TIMEOUT,
            HealthStatus::DEGRADED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HealthStatus>("HealthStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HealthStatus {
}

impl ::std::default::Default for HealthStatus {
    fn default() -> Self {
        HealthStatus::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$envoy/api/v2/core/health_check.proto\x12\x11envoy.api.v2.core\x1a\x1c\
    envoy/api/v2/core/base.proto\x1a,envoy/api/v2/core/event_service_config.\
    proto\x1a\x15envoy/type/http.proto\x1a\x1fenvoy/type/matcher/string.prot\
    o\x1a\x16envoy/type/range.proto\x1a\x19google/protobuf/any.proto\x1a\x1e\
    google/protobuf/duration.proto\x1a\x1cgoogle/protobuf/struct.proto\x1a\
    \x1egoogle/protobuf/wrappers.proto\x1a#envoy/annotations/deprecation.pro\
    to\x1a\x1eudpa/annotations/migrate.proto\x1a\x1dudpa/annotations/status.\
    proto\x1a\x17validate/validate.proto\"\xe1\x16\n\x0bHealthCheck\x12?\n\
    \x07timeout\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x07timeo\
    utB\n\xfaB\x07\xaa\x01\x04\x08\x01*\0\x12A\n\x08interval\x18\x02\x20\x01\
    (\x0b2\x19.google.protobuf.DurationR\x08intervalB\n\xfaB\x07\xaa\x01\x04\
    \x08\x01*\0\x12@\n\x0einitial_jitter\x18\x14\x20\x01(\x0b2\x19.google.pr\
    otobuf.DurationR\rinitialJitter\x12B\n\x0finterval_jitter\x18\x03\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x0eintervalJitter\x126\n\x17int\
    erval_jitter_percent\x18\x12\x20\x01(\rR\x15intervalJitterPercent\x12W\n\
    \x13unhealthy_threshold\x18\x04\x20\x01(\x0b2\x1c.google.protobuf.UInt32\
    ValueR\x12unhealthyThresholdB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x12S\n\
    \x11healthy_threshold\x18\x05\x20\x01(\x0b2\x1c.google.protobuf.UInt32Va\
    lueR\x10healthyThresholdB\x08\xfaB\x05\x8a\x01\x02\x10\x01\x127\n\x08alt\
    _port\x18\x06\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x07altPort\
    \x12E\n\x10reuse_connection\x18\x07\x20\x01(\x0b2\x1a.google.protobuf.Bo\
    olValueR\x0freuseConnection\x12\\\n\x11http_health_check\x18\x08\x20\x01\
    (\x0b2..envoy.api.v2.core.HealthCheck.HttpHealthCheckH\0R\x0fhttpHealthC\
    heck\x12Y\n\x10tcp_health_check\x18\t\x20\x01(\x0b2-.envoy.api.v2.core.H\
    ealthCheck.TcpHealthCheckH\0R\x0etcpHealthCheck\x12\\\n\x11grpc_health_c\
    heck\x18\x0b\x20\x01(\x0b2..envoy.api.v2.core.HealthCheck.GrpcHealthChec\
    kH\0R\x0fgrpcHealthCheck\x12b\n\x13custom_health_check\x18\r\x20\x01(\
    \x0b20.envoy.api.v2.core.HealthCheck.CustomHealthCheckH\0R\x11customHeal\
    thCheck\x12S\n\x13no_traffic_interval\x18\x0c\x20\x01(\x0b2\x19.google.p\
    rotobuf.DurationR\x11noTrafficIntervalB\x08\xfaB\x05\xaa\x01\x02*\0\x12R\
    \n\x12unhealthy_interval\x18\x0e\x20\x01(\x0b2\x19.google.protobuf.Durat\
    ionR\x11unhealthyIntervalB\x08\xfaB\x05\xaa\x01\x02*\0\x12[\n\x17unhealt\
    hy_edge_interval\x18\x0f\x20\x01(\x0b2\x19.google.protobuf.DurationR\x15\
    unhealthyEdgeIntervalB\x08\xfaB\x05\xaa\x01\x02*\0\x12W\n\x15healthy_edg\
    e_interval\x18\x10\x20\x01(\x0b2\x19.google.protobuf.DurationR\x13health\
    yEdgeIntervalB\x08\xfaB\x05\xaa\x01\x02*\0\x12$\n\x0eevent_log_path\x18\
    \x11\x20\x01(\tR\x0ceventLogPath\x12J\n\revent_service\x18\x16\x20\x01(\
    \x0b2%.envoy.api.v2.core.EventServiceConfigR\x0ceventService\x12F\n\x20a\
    lways_log_health_check_failures\x18\x13\x20\x01(\x08R\x1calwaysLogHealth\
    CheckFailures\x12J\n\x0btls_options\x18\x15\x20\x01(\x0b2).envoy.api.v2.\
    core.HealthCheck.TlsOptionsR\ntlsOptions\x1aR\n\x07Payload\x12\x1d\n\x04\
    text\x18\x01\x20\x01(\tH\0R\x04textB\x07\xfaB\x04r\x02\x20\x01\x12\x18\n\
    \x06binary\x18\x02\x20\x01(\x0cH\0R\x06binaryB\x0e\n\x07payload\x12\x03\
    \xf8B\x01\x1a\x9c\x05\n\x0fHttpHealthCheck\x12\x12\n\x04host\x18\x01\x20\
    \x01(\tR\x04host\x12\x1b\n\x04path\x18\x02\x20\x01(\tR\x04pathB\x07\xfaB\
    \x04r\x02\x20\x01\x12:\n\x04send\x18\x03\x20\x01(\x0b2&.envoy.api.v2.cor\
    e.HealthCheck.PayloadR\x04send\x12@\n\x07receive\x18\x04\x20\x01(\x0b2&.\
    envoy.api.v2.core.HealthCheck.PayloadR\x07receive\x12%\n\x0cservice_name\
    \x18\x05\x20\x01(\tR\x0bserviceNameB\x02\x18\x01\x12d\n\x16request_heade\
    rs_to_add\x18\x06\x20\x03(\x0b2$.envoy.api.v2.core.HeaderValueOptionR\
    \x13requestHeadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x129\n\x19re\
    quest_headers_to_remove\x18\x08\x20\x03(\tR\x16requestHeadersToRemove\
    \x12%\n\tuse_http2\x18\x07\x20\x01(\x08R\x08useHttp2B\x08\x18\x01\xb8\
    \xee\xf2\xd2\x05\x01\x12C\n\x11expected_statuses\x18\t\x20\x03(\x0b2\x16\
    .envoy.type.Int64RangeR\x10expectedStatuses\x12Q\n\x11codec_client_type\
    \x18\n\x20\x01(\x0e2\x1b.envoy.type.CodecClientTypeR\x0fcodecClientTypeB\
    \x08\xfaB\x05\x82\x01\x02\x10\x01\x12S\n\x14service_name_matcher\x18\x0b\
    \x20\x01(\x0b2!.envoy.type.matcher.StringMatcherR\x12serviceNameMatcher\
    \x1a\x8e\x01\n\x0eTcpHealthCheck\x12:\n\x04send\x18\x01\x20\x01(\x0b2&.e\
    nvoy.api.v2.core.HealthCheck.PayloadR\x04send\x12@\n\x07receive\x18\x02\
    \x20\x03(\x0b2&.envoy.api.v2.core.HealthCheck.PayloadR\x07receive\x1a$\n\
    \x10RedisHealthCheck\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x1aR\n\
    \x0fGrpcHealthCheck\x12!\n\x0cservice_name\x18\x01\x20\x01(\tR\x0bservic\
    eName\x12\x1c\n\tauthority\x18\x02\x20\x01(\tR\tauthority\x1a\xb1\x01\n\
    \x11CustomHealthCheck\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\
    \xfaB\x04r\x02\x20\x01\x125\n\x06config\x18\x02\x20\x01(\x0b2\x17.google\
    .protobuf.StructH\0R\x06configB\x02\x18\x01\x129\n\x0ctyped_config\x18\
    \x03\x20\x01(\x0b2\x14.google.protobuf.AnyH\0R\x0btypedConfigB\r\n\x0bco\
    nfig_type\x1a3\n\nTlsOptions\x12%\n\x0ealpn_protocols\x18\x01\x20\x03(\t\
    R\ralpnProtocolsB\x15\n\x0ehealth_checker\x12\x03\xf8B\x01J\x04\x08\n\
    \x10\x0b*`\n\x0cHealthStatus\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07HEA\
    LTHY\x10\x01\x12\r\n\tUNHEALTHY\x10\x02\x12\x0c\n\x08DRAINING\x10\x03\
    \x12\x0b\n\x07TIMEOUT\x10\x04\x12\x0c\n\x08DEGRADED\x10\x05BY\n\x1fio.en\
    voyproxy.envoy.api.v2.coreB\x10HealthCheckProtoP\x01\xf2\x98\xfe\x8f\x05\
    \x16\x12\x14envoy.config.core.v3\xba\x80\xc8\xd1\x06\x02\x10\x01b\x06pro\
    to3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
