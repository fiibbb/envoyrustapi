// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/api/v2/route/route_components.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct VirtualHost {
    // message fields
    pub name: ::std::string::String,
    pub domains: ::protobuf::RepeatedField<::std::string::String>,
    pub routes: ::protobuf::RepeatedField<Route>,
    pub require_tls: VirtualHost_TlsRequirementType,
    pub virtual_clusters: ::protobuf::RepeatedField<VirtualCluster>,
    pub rate_limits: ::protobuf::RepeatedField<RateLimit>,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub response_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub response_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub cors: ::protobuf::SingularPtrField<CorsPolicy>,
    pub per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>,
    pub typed_per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    pub include_request_attempt_count: bool,
    pub include_attempt_count_in_response: bool,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    pub retry_policy_typed_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub hedge_policy: ::protobuf::SingularPtrField<HedgePolicy>,
    pub per_request_buffer_limit_bytes: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualHost {
    fn default() -> &'a VirtualHost {
        <VirtualHost as ::protobuf::Message>::default_instance()
    }
}

impl VirtualHost {
    pub fn new() -> VirtualHost {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated string domains = 2;


    pub fn get_domains(&self) -> &[::std::string::String] {
        &self.domains
    }
    pub fn clear_domains(&mut self) {
        self.domains.clear();
    }

    // Param is passed by value, moved
    pub fn set_domains(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.domains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_domains(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.domains
    }

    // Take field
    pub fn take_domains(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.domains, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.route.Route routes = 3;


    pub fn get_routes(&self) -> &[Route] {
        &self.routes
    }
    pub fn clear_routes(&mut self) {
        self.routes.clear();
    }

    // Param is passed by value, moved
    pub fn set_routes(&mut self, v: ::protobuf::RepeatedField<Route>) {
        self.routes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routes(&mut self) -> &mut ::protobuf::RepeatedField<Route> {
        &mut self.routes
    }

    // Take field
    pub fn take_routes(&mut self) -> ::protobuf::RepeatedField<Route> {
        ::std::mem::replace(&mut self.routes, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.route.VirtualHost.TlsRequirementType require_tls = 4;


    pub fn get_require_tls(&self) -> VirtualHost_TlsRequirementType {
        self.require_tls
    }
    pub fn clear_require_tls(&mut self) {
        self.require_tls = VirtualHost_TlsRequirementType::NONE;
    }

    // Param is passed by value, moved
    pub fn set_require_tls(&mut self, v: VirtualHost_TlsRequirementType) {
        self.require_tls = v;
    }

    // repeated .envoy.api.v2.route.VirtualCluster virtual_clusters = 5;


    pub fn get_virtual_clusters(&self) -> &[VirtualCluster] {
        &self.virtual_clusters
    }
    pub fn clear_virtual_clusters(&mut self) {
        self.virtual_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtual_clusters(&mut self, v: ::protobuf::RepeatedField<VirtualCluster>) {
        self.virtual_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtual_clusters(&mut self) -> &mut ::protobuf::RepeatedField<VirtualCluster> {
        &mut self.virtual_clusters
    }

    // Take field
    pub fn take_virtual_clusters(&mut self) -> ::protobuf::RepeatedField<VirtualCluster> {
        ::std::mem::replace(&mut self.virtual_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.route.RateLimit rate_limits = 6;


    pub fn get_rate_limits(&self) -> &[RateLimit] {
        &self.rate_limits
    }
    pub fn clear_rate_limits(&mut self) {
        self.rate_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.rate_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rate_limits(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.rate_limits
    }

    // Take field
    pub fn take_rate_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.rate_limits, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption request_headers_to_add = 7;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 13;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10;


    pub fn get_response_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.response_headers_to_add
    }
    pub fn clear_response_headers_to_add(&mut self) {
        self.response_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.response_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.response_headers_to_add
    }

    // Take field
    pub fn take_response_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.response_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string response_headers_to_remove = 11;


    pub fn get_response_headers_to_remove(&self) -> &[::std::string::String] {
        &self.response_headers_to_remove
    }
    pub fn clear_response_headers_to_remove(&mut self) {
        self.response_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_headers_to_remove
    }

    // Take field
    pub fn take_response_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.route.CorsPolicy cors = 8;


    pub fn get_cors(&self) -> &CorsPolicy {
        self.cors.as_ref().unwrap_or_else(|| <CorsPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cors(&mut self) {
        self.cors.clear();
    }

    pub fn has_cors(&self) -> bool {
        self.cors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cors(&mut self, v: CorsPolicy) {
        self.cors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cors(&mut self) -> &mut CorsPolicy {
        if self.cors.is_none() {
            self.cors.set_default();
        }
        self.cors.as_mut().unwrap()
    }

    // Take field
    pub fn take_cors(&mut self) -> CorsPolicy {
        self.cors.take().unwrap_or_else(|| CorsPolicy::new())
    }

    // repeated .envoy.api.v2.route.VirtualHost.PerFilterConfigEntry per_filter_config = 12;


    pub fn get_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &self.per_filter_config
    }
    pub fn clear_per_filter_config(&mut self) {
        self.per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>) {
        self.per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &mut self.per_filter_config
    }

    // Take field
    pub fn take_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        ::std::mem::replace(&mut self.per_filter_config, ::std::collections::HashMap::new())
    }

    // repeated .envoy.api.v2.route.VirtualHost.TypedPerFilterConfigEntry typed_per_filter_config = 15;


    pub fn get_typed_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_per_filter_config
    }
    pub fn clear_typed_per_filter_config(&mut self) {
        self.typed_per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_per_filter_config
    }

    // Take field
    pub fn take_typed_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_per_filter_config, ::std::collections::HashMap::new())
    }

    // bool include_request_attempt_count = 14;


    pub fn get_include_request_attempt_count(&self) -> bool {
        self.include_request_attempt_count
    }
    pub fn clear_include_request_attempt_count(&mut self) {
        self.include_request_attempt_count = false;
    }

    // Param is passed by value, moved
    pub fn set_include_request_attempt_count(&mut self, v: bool) {
        self.include_request_attempt_count = v;
    }

    // bool include_attempt_count_in_response = 19;


    pub fn get_include_attempt_count_in_response(&self) -> bool {
        self.include_attempt_count_in_response
    }
    pub fn clear_include_attempt_count_in_response(&mut self) {
        self.include_attempt_count_in_response = false;
    }

    // Param is passed by value, moved
    pub fn set_include_attempt_count_in_response(&mut self, v: bool) {
        self.include_attempt_count_in_response = v;
    }

    // .envoy.api.v2.route.RetryPolicy retry_policy = 16;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }

    // .google.protobuf.Any retry_policy_typed_config = 20;


    pub fn get_retry_policy_typed_config(&self) -> &::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy_typed_config(&mut self) {
        self.retry_policy_typed_config.clear();
    }

    pub fn has_retry_policy_typed_config(&self) -> bool {
        self.retry_policy_typed_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.retry_policy_typed_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.retry_policy_typed_config.is_none() {
            self.retry_policy_typed_config.set_default();
        }
        self.retry_policy_typed_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .envoy.api.v2.route.HedgePolicy hedge_policy = 17;


    pub fn get_hedge_policy(&self) -> &HedgePolicy {
        self.hedge_policy.as_ref().unwrap_or_else(|| <HedgePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hedge_policy(&mut self) {
        self.hedge_policy.clear();
    }

    pub fn has_hedge_policy(&self) -> bool {
        self.hedge_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hedge_policy(&mut self, v: HedgePolicy) {
        self.hedge_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hedge_policy(&mut self) -> &mut HedgePolicy {
        if self.hedge_policy.is_none() {
            self.hedge_policy.set_default();
        }
        self.hedge_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_hedge_policy(&mut self) -> HedgePolicy {
        self.hedge_policy.take().unwrap_or_else(|| HedgePolicy::new())
    }

    // .google.protobuf.UInt32Value per_request_buffer_limit_bytes = 18;


    pub fn get_per_request_buffer_limit_bytes(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_request_buffer_limit_bytes(&mut self) {
        self.per_request_buffer_limit_bytes.clear();
    }

    pub fn has_per_request_buffer_limit_bytes(&self) -> bool {
        self.per_request_buffer_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_request_buffer_limit_bytes(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.per_request_buffer_limit_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_request_buffer_limit_bytes(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.per_request_buffer_limit_bytes.is_none() {
            self.per_request_buffer_limit_bytes.set_default();
        }
        self.per_request_buffer_limit_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_request_buffer_limit_bytes(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for VirtualHost {
    fn is_initialized(&self) -> bool {
        for v in &self.routes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtual_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rate_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy_typed_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hedge_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_request_buffer_limit_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.domains)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routes)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.require_tls, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtual_clusters)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rate_limits)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_headers_to_add)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_headers_to_remove)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cors)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(wire_type, is, &mut self.per_filter_config)?;
                },
                15 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_per_filter_config)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_request_attempt_count = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.include_attempt_count_in_response = tmp;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy_typed_config)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hedge_policy)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_request_buffer_limit_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.domains {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.routes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.require_tls != VirtualHost_TlsRequirementType::NONE {
            my_size += ::protobuf::rt::enum_size(4, self.require_tls);
        }
        for value in &self.virtual_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.rate_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        for value in &self.response_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response_headers_to_remove {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.cors.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(12, &self.per_filter_config);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(15, &self.typed_per_filter_config);
        if self.include_request_attempt_count != false {
            my_size += 2;
        }
        if self.include_attempt_count_in_response != false {
            my_size += 3;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.domains {
            os.write_string(2, &v)?;
        };
        for v in &self.routes {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.require_tls != VirtualHost_TlsRequirementType::NONE {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.require_tls))?;
        }
        for v in &self.virtual_clusters {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.rate_limits {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_add {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(13, &v)?;
        };
        for v in &self.response_headers_to_add {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response_headers_to_remove {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.cors.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(12, &self.per_filter_config, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(15, &self.typed_per_filter_config, os)?;
        if self.include_request_attempt_count != false {
            os.write_bool(14, self.include_request_attempt_count)?;
        }
        if self.include_attempt_count_in_response != false {
            os.write_bool(19, self.include_attempt_count_in_response)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualHost {
        VirtualHost::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VirtualHost| { &m.name },
                |m: &mut VirtualHost| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "domains",
                |m: &VirtualHost| { &m.domains },
                |m: &mut VirtualHost| { &mut m.domains },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Route>>(
                "routes",
                |m: &VirtualHost| { &m.routes },
                |m: &mut VirtualHost| { &mut m.routes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VirtualHost_TlsRequirementType>>(
                "require_tls",
                |m: &VirtualHost| { &m.require_tls },
                |m: &mut VirtualHost| { &mut m.require_tls },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualCluster>>(
                "virtual_clusters",
                |m: &VirtualHost| { &m.virtual_clusters },
                |m: &mut VirtualHost| { &mut m.virtual_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit>>(
                "rate_limits",
                |m: &VirtualHost| { &m.rate_limits },
                |m: &mut VirtualHost| { &mut m.rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &VirtualHost| { &m.request_headers_to_add },
                |m: &mut VirtualHost| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &VirtualHost| { &m.request_headers_to_remove },
                |m: &mut VirtualHost| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "response_headers_to_add",
                |m: &VirtualHost| { &m.response_headers_to_add },
                |m: &mut VirtualHost| { &mut m.response_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_headers_to_remove",
                |m: &VirtualHost| { &m.response_headers_to_remove },
                |m: &mut VirtualHost| { &mut m.response_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorsPolicy>>(
                "cors",
                |m: &VirtualHost| { &m.cors },
                |m: &mut VirtualHost| { &mut m.cors },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "per_filter_config",
                |m: &VirtualHost| { &m.per_filter_config },
                |m: &mut VirtualHost| { &mut m.per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_per_filter_config",
                |m: &VirtualHost| { &m.typed_per_filter_config },
                |m: &mut VirtualHost| { &mut m.typed_per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_request_attempt_count",
                |m: &VirtualHost| { &m.include_request_attempt_count },
                |m: &mut VirtualHost| { &mut m.include_request_attempt_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "include_attempt_count_in_response",
                |m: &VirtualHost| { &m.include_attempt_count_in_response },
                |m: &mut VirtualHost| { &mut m.include_attempt_count_in_response },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &VirtualHost| { &m.retry_policy },
                |m: &mut VirtualHost| { &mut m.retry_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "retry_policy_typed_config",
                |m: &VirtualHost| { &m.retry_policy_typed_config },
                |m: &mut VirtualHost| { &mut m.retry_policy_typed_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HedgePolicy>>(
                "hedge_policy",
                |m: &VirtualHost| { &m.hedge_policy },
                |m: &mut VirtualHost| { &mut m.hedge_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "per_request_buffer_limit_bytes",
                |m: &VirtualHost| { &m.per_request_buffer_limit_bytes },
                |m: &mut VirtualHost| { &mut m.per_request_buffer_limit_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualHost>(
                "VirtualHost",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualHost {
        static instance: ::protobuf::rt::LazyV2<VirtualHost> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualHost::new)
    }
}

impl ::protobuf::Clear for VirtualHost {
    fn clear(&mut self) {
        self.name.clear();
        self.domains.clear();
        self.routes.clear();
        self.require_tls = VirtualHost_TlsRequirementType::NONE;
        self.virtual_clusters.clear();
        self.rate_limits.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.response_headers_to_add.clear();
        self.response_headers_to_remove.clear();
        self.cors.clear();
        self.per_filter_config.clear();
        self.typed_per_filter_config.clear();
        self.include_request_attempt_count = false;
        self.include_attempt_count_in_response = false;
        self.retry_policy.clear();
        self.retry_policy_typed_config.clear();
        self.hedge_policy.clear();
        self.per_request_buffer_limit_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualHost {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualHost {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VirtualHost_TlsRequirementType {
    NONE = 0,
    EXTERNAL_ONLY = 1,
    ALL = 2,
}

impl ::protobuf::ProtobufEnum for VirtualHost_TlsRequirementType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VirtualHost_TlsRequirementType> {
        match value {
            0 => ::std::option::Option::Some(VirtualHost_TlsRequirementType::NONE),
            1 => ::std::option::Option::Some(VirtualHost_TlsRequirementType::EXTERNAL_ONLY),
            2 => ::std::option::Option::Some(VirtualHost_TlsRequirementType::ALL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VirtualHost_TlsRequirementType] = &[
            VirtualHost_TlsRequirementType::NONE,
            VirtualHost_TlsRequirementType::EXTERNAL_ONLY,
            VirtualHost_TlsRequirementType::ALL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<VirtualHost_TlsRequirementType>("VirtualHost.TlsRequirementType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for VirtualHost_TlsRequirementType {
}

impl ::std::default::Default for VirtualHost_TlsRequirementType {
    fn default() -> Self {
        VirtualHost_TlsRequirementType::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualHost_TlsRequirementType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilterAction {
    // message fields
    pub action: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterAction {
    fn default() -> &'a FilterAction {
        <FilterAction as ::protobuf::Message>::default_instance()
    }
}

impl FilterAction {
    pub fn new() -> FilterAction {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any action = 1;


    pub fn get_action(&self) -> &::protobuf::well_known_types::Any {
        self.action.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::protobuf::well_known_types::Any) {
        self.action = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::protobuf::well_known_types::Any {
        self.action.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for FilterAction {
    fn is_initialized(&self) -> bool {
        for v in &self.action {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.action)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.action.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.action.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterAction {
        FilterAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "action",
                |m: &FilterAction| { &m.action },
                |m: &mut FilterAction| { &mut m.action },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterAction>(
                "FilterAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterAction {
        static instance: ::protobuf::rt::LazyV2<FilterAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterAction::new)
    }
}

impl ::protobuf::Clear for FilterAction {
    fn clear(&mut self) {
        self.action.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Route {
    // message fields
    pub name: ::std::string::String,
    pub field_match: ::protobuf::SingularPtrField<RouteMatch>,
    pub metadata: ::protobuf::SingularPtrField<super::base::Metadata>,
    pub decorator: ::protobuf::SingularPtrField<Decorator>,
    pub per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>,
    pub typed_per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub response_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub response_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub tracing: ::protobuf::SingularPtrField<Tracing>,
    pub per_request_buffer_limit_bytes: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // message oneof groups
    pub action: ::std::option::Option<Route_oneof_action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Route {
    fn default() -> &'a Route {
        <Route as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Route_oneof_action {
    route(RouteAction),
    redirect(RedirectAction),
    direct_response(DirectResponseAction),
    filter_action(FilterAction),
}

impl Route {
    pub fn new() -> Route {
        ::std::default::Default::default()
    }

    // string name = 14;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.api.v2.route.RouteMatch match = 1;


    pub fn get_field_match(&self) -> &RouteMatch {
        self.field_match.as_ref().unwrap_or_else(|| <RouteMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: RouteMatch) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut RouteMatch {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> RouteMatch {
        self.field_match.take().unwrap_or_else(|| RouteMatch::new())
    }

    // .envoy.api.v2.route.RouteAction route = 2;


    pub fn get_route(&self) -> &RouteAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::route(ref v)) => v,
            _ => <RouteAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_route(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_route(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::route(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_route(&mut self, v: RouteAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::route(v))
    }

    // Mutable pointer to the field.
    pub fn mut_route(&mut self) -> &mut RouteAction {
        if let ::std::option::Option::Some(Route_oneof_action::route(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::route(RouteAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::route(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_route(&mut self) -> RouteAction {
        if self.has_route() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::route(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction::new()
        }
    }

    // .envoy.api.v2.route.RedirectAction redirect = 3;


    pub fn get_redirect(&self) -> &RedirectAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::redirect(ref v)) => v,
            _ => <RedirectAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_redirect(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_redirect(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_redirect(&mut self, v: RedirectAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::redirect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_redirect(&mut self) -> &mut RedirectAction {
        if let ::std::option::Option::Some(Route_oneof_action::redirect(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::redirect(RedirectAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::redirect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_redirect(&mut self) -> RedirectAction {
        if self.has_redirect() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::redirect(v)) => v,
                _ => panic!(),
            }
        } else {
            RedirectAction::new()
        }
    }

    // .envoy.api.v2.route.DirectResponseAction direct_response = 7;


    pub fn get_direct_response(&self) -> &DirectResponseAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::direct_response(ref v)) => v,
            _ => <DirectResponseAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_direct_response(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_direct_response(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::direct_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_response(&mut self, v: DirectResponseAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::direct_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_response(&mut self) -> &mut DirectResponseAction {
        if let ::std::option::Option::Some(Route_oneof_action::direct_response(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::direct_response(DirectResponseAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::direct_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_response(&mut self) -> DirectResponseAction {
        if self.has_direct_response() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::direct_response(v)) => v,
                _ => panic!(),
            }
        } else {
            DirectResponseAction::new()
        }
    }

    // .envoy.api.v2.route.FilterAction filter_action = 17;


    pub fn get_filter_action(&self) -> &FilterAction {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::filter_action(ref v)) => v,
            _ => <FilterAction as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_filter_action(&self) -> bool {
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::filter_action(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_action(&mut self, v: FilterAction) {
        self.action = ::std::option::Option::Some(Route_oneof_action::filter_action(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_action(&mut self) -> &mut FilterAction {
        if let ::std::option::Option::Some(Route_oneof_action::filter_action(_)) = self.action {
        } else {
            self.action = ::std::option::Option::Some(Route_oneof_action::filter_action(FilterAction::new()));
        }
        match self.action {
            ::std::option::Option::Some(Route_oneof_action::filter_action(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_action(&mut self) -> FilterAction {
        if self.has_filter_action() {
            match self.action.take() {
                ::std::option::Option::Some(Route_oneof_action::filter_action(v)) => v,
                _ => panic!(),
            }
        } else {
            FilterAction::new()
        }
    }

    // .envoy.api.v2.core.Metadata metadata = 4;


    pub fn get_metadata(&self) -> &super::base::Metadata {
        self.metadata.as_ref().unwrap_or_else(|| <super::base::Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::base::Metadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::base::Metadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::base::Metadata {
        self.metadata.take().unwrap_or_else(|| super::base::Metadata::new())
    }

    // .envoy.api.v2.route.Decorator decorator = 5;


    pub fn get_decorator(&self) -> &Decorator {
        self.decorator.as_ref().unwrap_or_else(|| <Decorator as ::protobuf::Message>::default_instance())
    }
    pub fn clear_decorator(&mut self) {
        self.decorator.clear();
    }

    pub fn has_decorator(&self) -> bool {
        self.decorator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decorator(&mut self, v: Decorator) {
        self.decorator = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_decorator(&mut self) -> &mut Decorator {
        if self.decorator.is_none() {
            self.decorator.set_default();
        }
        self.decorator.as_mut().unwrap()
    }

    // Take field
    pub fn take_decorator(&mut self) -> Decorator {
        self.decorator.take().unwrap_or_else(|| Decorator::new())
    }

    // repeated .envoy.api.v2.route.Route.PerFilterConfigEntry per_filter_config = 8;


    pub fn get_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &self.per_filter_config
    }
    pub fn clear_per_filter_config(&mut self) {
        self.per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>) {
        self.per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &mut self.per_filter_config
    }

    // Take field
    pub fn take_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        ::std::mem::replace(&mut self.per_filter_config, ::std::collections::HashMap::new())
    }

    // repeated .envoy.api.v2.route.Route.TypedPerFilterConfigEntry typed_per_filter_config = 13;


    pub fn get_typed_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_per_filter_config
    }
    pub fn clear_typed_per_filter_config(&mut self) {
        self.typed_per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_per_filter_config
    }

    // Take field
    pub fn take_typed_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_per_filter_config, ::std::collections::HashMap::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption request_headers_to_add = 9;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 12;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption response_headers_to_add = 10;


    pub fn get_response_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.response_headers_to_add
    }
    pub fn clear_response_headers_to_add(&mut self) {
        self.response_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.response_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.response_headers_to_add
    }

    // Take field
    pub fn take_response_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.response_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string response_headers_to_remove = 11;


    pub fn get_response_headers_to_remove(&self) -> &[::std::string::String] {
        &self.response_headers_to_remove
    }
    pub fn clear_response_headers_to_remove(&mut self) {
        self.response_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_headers_to_remove
    }

    // Take field
    pub fn take_response_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.route.Tracing tracing = 15;


    pub fn get_tracing(&self) -> &Tracing {
        self.tracing.as_ref().unwrap_or_else(|| <Tracing as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tracing(&mut self) {
        self.tracing.clear();
    }

    pub fn has_tracing(&self) -> bool {
        self.tracing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracing(&mut self, v: Tracing) {
        self.tracing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracing(&mut self) -> &mut Tracing {
        if self.tracing.is_none() {
            self.tracing.set_default();
        }
        self.tracing.as_mut().unwrap()
    }

    // Take field
    pub fn take_tracing(&mut self) -> Tracing {
        self.tracing.take().unwrap_or_else(|| Tracing::new())
    }

    // .google.protobuf.UInt32Value per_request_buffer_limit_bytes = 16;


    pub fn get_per_request_buffer_limit_bytes(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_request_buffer_limit_bytes(&mut self) {
        self.per_request_buffer_limit_bytes.clear();
    }

    pub fn has_per_request_buffer_limit_bytes(&self) -> bool {
        self.per_request_buffer_limit_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_request_buffer_limit_bytes(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.per_request_buffer_limit_bytes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_request_buffer_limit_bytes(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.per_request_buffer_limit_bytes.is_none() {
            self.per_request_buffer_limit_bytes.set_default();
        }
        self.per_request_buffer_limit_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_request_buffer_limit_bytes(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.per_request_buffer_limit_bytes.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for Route {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Route_oneof_action::route(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::redirect(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::direct_response(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Route_oneof_action::filter_action(ref v)) = self.action {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.decorator {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tracing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_request_buffer_limit_bytes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::route(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::redirect(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::direct_response(is.read_message()?));
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action = ::std::option::Option::Some(Route_oneof_action::filter_action(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.decorator)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(wire_type, is, &mut self.per_filter_config)?;
                },
                13 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_per_filter_config)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_headers_to_add)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_headers_to_remove)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tracing)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_request_buffer_limit_bytes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.name);
        }
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.decorator.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(8, &self.per_filter_config);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(13, &self.typed_per_filter_config);
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        for value in &self.response_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response_headers_to_remove {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if let Some(ref v) = self.tracing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Route_oneof_action::route(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::redirect(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::direct_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Route_oneof_action::filter_action(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(14, &self.name)?;
        }
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.decorator.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(8, &self.per_filter_config, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(13, &self.typed_per_filter_config, os)?;
        for v in &self.request_headers_to_add {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(12, &v)?;
        };
        for v in &self.response_headers_to_add {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response_headers_to_remove {
            os.write_string(11, &v)?;
        };
        if let Some(ref v) = self.tracing.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_request_buffer_limit_bytes.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.action {
            match v {
                &Route_oneof_action::route(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::redirect(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::direct_response(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Route_oneof_action::filter_action(ref v) => {
                    os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Route {
        Route::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Route| { &m.name },
                |m: &mut Route| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteMatch>>(
                "match",
                |m: &Route| { &m.field_match },
                |m: &mut Route| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction>(
                "route",
                Route::has_route,
                Route::get_route,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RedirectAction>(
                "redirect",
                Route::has_redirect,
                Route::get_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DirectResponseAction>(
                "direct_response",
                Route::has_direct_response,
                Route::get_direct_response,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FilterAction>(
                "filter_action",
                Route::has_filter_action,
                Route::get_filter_action,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Metadata>>(
                "metadata",
                |m: &Route| { &m.metadata },
                |m: &mut Route| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Decorator>>(
                "decorator",
                |m: &Route| { &m.decorator },
                |m: &mut Route| { &mut m.decorator },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "per_filter_config",
                |m: &Route| { &m.per_filter_config },
                |m: &mut Route| { &mut m.per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_per_filter_config",
                |m: &Route| { &m.typed_per_filter_config },
                |m: &mut Route| { &mut m.typed_per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &Route| { &m.request_headers_to_add },
                |m: &mut Route| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &Route| { &m.request_headers_to_remove },
                |m: &mut Route| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "response_headers_to_add",
                |m: &Route| { &m.response_headers_to_add },
                |m: &mut Route| { &mut m.response_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_headers_to_remove",
                |m: &Route| { &m.response_headers_to_remove },
                |m: &mut Route| { &mut m.response_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tracing>>(
                "tracing",
                |m: &Route| { &m.tracing },
                |m: &mut Route| { &mut m.tracing },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "per_request_buffer_limit_bytes",
                |m: &Route| { &m.per_request_buffer_limit_bytes },
                |m: &mut Route| { &mut m.per_request_buffer_limit_bytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Route>(
                "Route",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Route {
        static instance: ::protobuf::rt::LazyV2<Route> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Route::new)
    }
}

impl ::protobuf::Clear for Route {
    fn clear(&mut self) {
        self.name.clear();
        self.field_match.clear();
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.action = ::std::option::Option::None;
        self.metadata.clear();
        self.decorator.clear();
        self.per_filter_config.clear();
        self.typed_per_filter_config.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.response_headers_to_add.clear();
        self.response_headers_to_remove.clear();
        self.tracing.clear();
        self.per_request_buffer_limit_bytes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Route {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Route {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeightedCluster {
    // message fields
    pub clusters: ::protobuf::RepeatedField<WeightedCluster_ClusterWeight>,
    pub total_weight: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub runtime_key_prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeightedCluster {
    fn default() -> &'a WeightedCluster {
        <WeightedCluster as ::protobuf::Message>::default_instance()
    }
}

impl WeightedCluster {
    pub fn new() -> WeightedCluster {
        ::std::default::Default::default()
    }

    // repeated .envoy.api.v2.route.WeightedCluster.ClusterWeight clusters = 1;


    pub fn get_clusters(&self) -> &[WeightedCluster_ClusterWeight] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<WeightedCluster_ClusterWeight>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<WeightedCluster_ClusterWeight> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<WeightedCluster_ClusterWeight> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.UInt32Value total_weight = 3;


    pub fn get_total_weight(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.total_weight.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_total_weight(&mut self) {
        self.total_weight.clear();
    }

    pub fn has_total_weight(&self) -> bool {
        self.total_weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_weight(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.total_weight = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_total_weight(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.total_weight.is_none() {
            self.total_weight.set_default();
        }
        self.total_weight.as_mut().unwrap()
    }

    // Take field
    pub fn take_total_weight(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.total_weight.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // string runtime_key_prefix = 2;


    pub fn get_runtime_key_prefix(&self) -> &str {
        &self.runtime_key_prefix
    }
    pub fn clear_runtime_key_prefix(&mut self) {
        self.runtime_key_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key_prefix(&mut self, v: ::std::string::String) {
        self.runtime_key_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key_prefix
    }

    // Take field
    pub fn take_runtime_key_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WeightedCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.total_weight {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.total_weight)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.total_weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.runtime_key_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.total_weight.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.runtime_key_prefix.is_empty() {
            os.write_string(2, &self.runtime_key_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeightedCluster {
        WeightedCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WeightedCluster_ClusterWeight>>(
                "clusters",
                |m: &WeightedCluster| { &m.clusters },
                |m: &mut WeightedCluster| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "total_weight",
                |m: &WeightedCluster| { &m.total_weight },
                |m: &mut WeightedCluster| { &mut m.total_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key_prefix",
                |m: &WeightedCluster| { &m.runtime_key_prefix },
                |m: &mut WeightedCluster| { &mut m.runtime_key_prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeightedCluster>(
                "WeightedCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeightedCluster {
        static instance: ::protobuf::rt::LazyV2<WeightedCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeightedCluster::new)
    }
}

impl ::protobuf::Clear for WeightedCluster {
    fn clear(&mut self) {
        self.clusters.clear();
        self.total_weight.clear();
        self.runtime_key_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightedCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeightedCluster_ClusterWeight {
    // message fields
    pub name: ::std::string::String,
    pub weight: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub metadata_match: ::protobuf::SingularPtrField<super::base::Metadata>,
    pub request_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub request_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub response_headers_to_add: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub response_headers_to_remove: ::protobuf::RepeatedField<::std::string::String>,
    pub per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>,
    pub typed_per_filter_config: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeightedCluster_ClusterWeight {
    fn default() -> &'a WeightedCluster_ClusterWeight {
        <WeightedCluster_ClusterWeight as ::protobuf::Message>::default_instance()
    }
}

impl WeightedCluster_ClusterWeight {
    pub fn new() -> WeightedCluster_ClusterWeight {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.UInt32Value weight = 2;


    pub fn get_weight(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.weight.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_weight(&mut self) {
        self.weight.clear();
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.weight = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_weight(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.weight.is_none() {
            self.weight.set_default();
        }
        self.weight.as_mut().unwrap()
    }

    // Take field
    pub fn take_weight(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.weight.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .envoy.api.v2.core.Metadata metadata_match = 3;


    pub fn get_metadata_match(&self) -> &super::base::Metadata {
        self.metadata_match.as_ref().unwrap_or_else(|| <super::base::Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_match(&mut self) {
        self.metadata_match.clear();
    }

    pub fn has_metadata_match(&self) -> bool {
        self.metadata_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_match(&mut self, v: super::base::Metadata) {
        self.metadata_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_match(&mut self) -> &mut super::base::Metadata {
        if self.metadata_match.is_none() {
            self.metadata_match.set_default();
        }
        self.metadata_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_match(&mut self) -> super::base::Metadata {
        self.metadata_match.take().unwrap_or_else(|| super::base::Metadata::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption request_headers_to_add = 4;


    pub fn get_request_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.request_headers_to_add
    }
    pub fn clear_request_headers_to_add(&mut self) {
        self.request_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.request_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.request_headers_to_add
    }

    // Take field
    pub fn take_request_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.request_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string request_headers_to_remove = 9;


    pub fn get_request_headers_to_remove(&self) -> &[::std::string::String] {
        &self.request_headers_to_remove
    }
    pub fn clear_request_headers_to_remove(&mut self) {
        self.request_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.request_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.request_headers_to_remove
    }

    // Take field
    pub fn take_request_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.request_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.core.HeaderValueOption response_headers_to_add = 5;


    pub fn get_response_headers_to_add(&self) -> &[super::base::HeaderValueOption] {
        &self.response_headers_to_add
    }
    pub fn clear_response_headers_to_add(&mut self) {
        self.response_headers_to_add.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_add(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.response_headers_to_add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_add(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.response_headers_to_add
    }

    // Take field
    pub fn take_response_headers_to_add(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.response_headers_to_add, ::protobuf::RepeatedField::new())
    }

    // repeated string response_headers_to_remove = 6;


    pub fn get_response_headers_to_remove(&self) -> &[::std::string::String] {
        &self.response_headers_to_remove
    }
    pub fn clear_response_headers_to_remove(&mut self) {
        self.response_headers_to_remove.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_headers_to_remove(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.response_headers_to_remove = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers_to_remove(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.response_headers_to_remove
    }

    // Take field
    pub fn take_response_headers_to_remove(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.response_headers_to_remove, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.route.WeightedCluster.ClusterWeight.PerFilterConfigEntry per_filter_config = 8;


    pub fn get_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &self.per_filter_config
    }
    pub fn clear_per_filter_config(&mut self) {
        self.per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>) {
        self.per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &mut self.per_filter_config
    }

    // Take field
    pub fn take_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        ::std::mem::replace(&mut self.per_filter_config, ::std::collections::HashMap::new())
    }

    // repeated .envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterConfigEntry typed_per_filter_config = 10;


    pub fn get_typed_per_filter_config(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &self.typed_per_filter_config
    }
    pub fn clear_typed_per_filter_config(&mut self) {
        self.typed_per_filter_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_typed_per_filter_config(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any>) {
        self.typed_per_filter_config = v;
    }

    // Mutable pointer to the field.
    pub fn mut_typed_per_filter_config(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        &mut self.typed_per_filter_config
    }

    // Take field
    pub fn take_typed_per_filter_config(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.typed_per_filter_config, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for WeightedCluster_ClusterWeight {
    fn is_initialized(&self) -> bool {
        for v in &self.weight {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response_headers_to_add {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.weight)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_match)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_headers_to_add)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.request_headers_to_remove)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.response_headers_to_add)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.response_headers_to_remove)?;
                },
                8 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(wire_type, is, &mut self.per_filter_config)?;
                },
                10 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(wire_type, is, &mut self.typed_per_filter_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.weight.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.request_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.request_headers_to_remove {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.response_headers_to_add {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response_headers_to_remove {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(8, &self.per_filter_config);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(10, &self.typed_per_filter_config);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.weight.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.request_headers_to_add {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.request_headers_to_remove {
            os.write_string(9, &v)?;
        };
        for v in &self.response_headers_to_add {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response_headers_to_remove {
            os.write_string(6, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(8, &self.per_filter_config, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(10, &self.typed_per_filter_config, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeightedCluster_ClusterWeight {
        WeightedCluster_ClusterWeight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &WeightedCluster_ClusterWeight| { &m.name },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "weight",
                |m: &WeightedCluster_ClusterWeight| { &m.weight },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Metadata>>(
                "metadata_match",
                |m: &WeightedCluster_ClusterWeight| { &m.metadata_match },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.metadata_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "request_headers_to_add",
                |m: &WeightedCluster_ClusterWeight| { &m.request_headers_to_add },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.request_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "request_headers_to_remove",
                |m: &WeightedCluster_ClusterWeight| { &m.request_headers_to_remove },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.request_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "response_headers_to_add",
                |m: &WeightedCluster_ClusterWeight| { &m.response_headers_to_add },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.response_headers_to_add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "response_headers_to_remove",
                |m: &WeightedCluster_ClusterWeight| { &m.response_headers_to_remove },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.response_headers_to_remove },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "per_filter_config",
                |m: &WeightedCluster_ClusterWeight| { &m.per_filter_config },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.per_filter_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "typed_per_filter_config",
                |m: &WeightedCluster_ClusterWeight| { &m.typed_per_filter_config },
                |m: &mut WeightedCluster_ClusterWeight| { &mut m.typed_per_filter_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeightedCluster_ClusterWeight>(
                "WeightedCluster.ClusterWeight",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeightedCluster_ClusterWeight {
        static instance: ::protobuf::rt::LazyV2<WeightedCluster_ClusterWeight> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeightedCluster_ClusterWeight::new)
    }
}

impl ::protobuf::Clear for WeightedCluster_ClusterWeight {
    fn clear(&mut self) {
        self.name.clear();
        self.weight.clear();
        self.metadata_match.clear();
        self.request_headers_to_add.clear();
        self.request_headers_to_remove.clear();
        self.response_headers_to_add.clear();
        self.response_headers_to_remove.clear();
        self.per_filter_config.clear();
        self.typed_per_filter_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightedCluster_ClusterWeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedCluster_ClusterWeight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteMatch {
    // message fields
    pub case_sensitive: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub runtime_fraction: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    pub headers: ::protobuf::RepeatedField<HeaderMatcher>,
    pub query_parameters: ::protobuf::RepeatedField<QueryParameterMatcher>,
    pub grpc: ::protobuf::SingularPtrField<RouteMatch_GrpcRouteMatchOptions>,
    pub tls_context: ::protobuf::SingularPtrField<RouteMatch_TlsContextMatchOptions>,
    // message oneof groups
    pub path_specifier: ::std::option::Option<RouteMatch_oneof_path_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch {
    fn default() -> &'a RouteMatch {
        <RouteMatch as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RouteMatch_oneof_path_specifier {
    prefix(::std::string::String),
    path(::std::string::String),
    regex(::std::string::String),
    safe_regex(super::regex::RegexMatcher),
}

impl RouteMatch {
    pub fn new() -> RouteMatch {
        ::std::default::Default::default()
    }

    // string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_prefix(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(::std::string::String::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        if self.has_prefix() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_path(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(::std::string::String::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        if self.has_path() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string regex = 3;


    pub fn get_regex(&self) -> &str {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_regex(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_regex(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_regex(&mut self, v: ::std::string::String) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(v))
    }

    // Mutable pointer to the field.
    pub fn mut_regex(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(::std::string::String::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_regex(&mut self) -> ::std::string::String {
        if self.has_regex() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.RegexMatcher safe_regex = 10;


    pub fn get_safe_regex(&self) -> &super::regex::RegexMatcher {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(ref v)) => v,
            _ => <super::regex::RegexMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_safe_regex(&mut self) {
        self.path_specifier = ::std::option::Option::None;
    }

    pub fn has_safe_regex(&self) -> bool {
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_safe_regex(&mut self, v: super::regex::RegexMatcher) {
        self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(v))
    }

    // Mutable pointer to the field.
    pub fn mut_safe_regex(&mut self) -> &mut super::regex::RegexMatcher {
        if let ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(_)) = self.path_specifier {
        } else {
            self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(super::regex::RegexMatcher::new()));
        }
        match self.path_specifier {
            ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_safe_regex(&mut self) -> super::regex::RegexMatcher {
        if self.has_safe_regex() {
            match self.path_specifier.take() {
                ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(v)) => v,
                _ => panic!(),
            }
        } else {
            super::regex::RegexMatcher::new()
        }
    }

    // .google.protobuf.BoolValue case_sensitive = 4;


    pub fn get_case_sensitive(&self) -> &::protobuf::well_known_types::BoolValue {
        self.case_sensitive.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_case_sensitive(&mut self) {
        self.case_sensitive.clear();
    }

    pub fn has_case_sensitive(&self) -> bool {
        self.case_sensitive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_case_sensitive(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.case_sensitive = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_case_sensitive(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.case_sensitive.is_none() {
            self.case_sensitive.set_default();
        }
        self.case_sensitive.as_mut().unwrap()
    }

    // Take field
    pub fn take_case_sensitive(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.case_sensitive.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 9;


    pub fn get_runtime_fraction(&self) -> &super::base::RuntimeFractionalPercent {
        self.runtime_fraction.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime_fraction(&mut self) {
        self.runtime_fraction.clear();
    }

    pub fn has_runtime_fraction(&self) -> bool {
        self.runtime_fraction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_fraction(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.runtime_fraction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_fraction(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.runtime_fraction.is_none() {
            self.runtime_fraction.set_default();
        }
        self.runtime_fraction.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime_fraction(&mut self) -> super::base::RuntimeFractionalPercent {
        self.runtime_fraction.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }

    // repeated .envoy.api.v2.route.HeaderMatcher headers = 6;


    pub fn get_headers(&self) -> &[HeaderMatcher] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.route.QueryParameterMatcher query_parameters = 7;


    pub fn get_query_parameters(&self) -> &[QueryParameterMatcher] {
        &self.query_parameters
    }
    pub fn clear_query_parameters(&mut self) {
        self.query_parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_query_parameters(&mut self, v: ::protobuf::RepeatedField<QueryParameterMatcher>) {
        self.query_parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_query_parameters(&mut self) -> &mut ::protobuf::RepeatedField<QueryParameterMatcher> {
        &mut self.query_parameters
    }

    // Take field
    pub fn take_query_parameters(&mut self) -> ::protobuf::RepeatedField<QueryParameterMatcher> {
        ::std::mem::replace(&mut self.query_parameters, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.route.RouteMatch.GrpcRouteMatchOptions grpc = 8;


    pub fn get_grpc(&self) -> &RouteMatch_GrpcRouteMatchOptions {
        self.grpc.as_ref().unwrap_or_else(|| <RouteMatch_GrpcRouteMatchOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc(&mut self) {
        self.grpc.clear();
    }

    pub fn has_grpc(&self) -> bool {
        self.grpc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc(&mut self, v: RouteMatch_GrpcRouteMatchOptions) {
        self.grpc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc(&mut self) -> &mut RouteMatch_GrpcRouteMatchOptions {
        if self.grpc.is_none() {
            self.grpc.set_default();
        }
        self.grpc.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc(&mut self) -> RouteMatch_GrpcRouteMatchOptions {
        self.grpc.take().unwrap_or_else(|| RouteMatch_GrpcRouteMatchOptions::new())
    }

    // .envoy.api.v2.route.RouteMatch.TlsContextMatchOptions tls_context = 11;


    pub fn get_tls_context(&self) -> &RouteMatch_TlsContextMatchOptions {
        self.tls_context.as_ref().unwrap_or_else(|| <RouteMatch_TlsContextMatchOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tls_context(&mut self) {
        self.tls_context.clear();
    }

    pub fn has_tls_context(&self) -> bool {
        self.tls_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tls_context(&mut self, v: RouteMatch_TlsContextMatchOptions) {
        self.tls_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tls_context(&mut self) -> &mut RouteMatch_TlsContextMatchOptions {
        if self.tls_context.is_none() {
            self.tls_context.set_default();
        }
        self.tls_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_tls_context(&mut self) -> RouteMatch_TlsContextMatchOptions {
        self.tls_context.take().unwrap_or_else(|| RouteMatch_TlsContextMatchOptions::new())
    }
}

impl ::protobuf::Message for RouteMatch {
    fn is_initialized(&self) -> bool {
        if let Some(RouteMatch_oneof_path_specifier::safe_regex(ref v)) = self.path_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.case_sensitive {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtime_fraction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.query_parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tls_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::prefix(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::path(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::regex(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_specifier = ::std::option::Option::Some(RouteMatch_oneof_path_specifier::safe_regex(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.case_sensitive)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime_fraction)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.query_parameters)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tls_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.case_sensitive.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.query_parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.grpc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tls_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.path_specifier {
            match v {
                &RouteMatch_oneof_path_specifier::prefix(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &RouteMatch_oneof_path_specifier::path(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &RouteMatch_oneof_path_specifier::regex(ref v) => {
                    my_size += ::protobuf::rt::string_size(3, &v);
                },
                &RouteMatch_oneof_path_specifier::safe_regex(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.case_sensitive.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.headers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.query_parameters {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.grpc.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tls_context.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.path_specifier {
            match v {
                &RouteMatch_oneof_path_specifier::prefix(ref v) => {
                    os.write_string(1, v)?;
                },
                &RouteMatch_oneof_path_specifier::path(ref v) => {
                    os.write_string(2, v)?;
                },
                &RouteMatch_oneof_path_specifier::regex(ref v) => {
                    os.write_string(3, v)?;
                },
                &RouteMatch_oneof_path_specifier::safe_regex(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch {
        RouteMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix",
                RouteMatch::has_prefix,
                RouteMatch::get_prefix,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "path",
                RouteMatch::has_path,
                RouteMatch::get_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "regex",
                RouteMatch::has_regex,
                RouteMatch::get_regex,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::regex::RegexMatcher>(
                "safe_regex",
                RouteMatch::has_safe_regex,
                RouteMatch::get_safe_regex,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "case_sensitive",
                |m: &RouteMatch| { &m.case_sensitive },
                |m: &mut RouteMatch| { &mut m.case_sensitive },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "runtime_fraction",
                |m: &RouteMatch| { &m.runtime_fraction },
                |m: &mut RouteMatch| { &mut m.runtime_fraction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "headers",
                |m: &RouteMatch| { &m.headers },
                |m: &mut RouteMatch| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueryParameterMatcher>>(
                "query_parameters",
                |m: &RouteMatch| { &m.query_parameters },
                |m: &mut RouteMatch| { &mut m.query_parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteMatch_GrpcRouteMatchOptions>>(
                "grpc",
                |m: &RouteMatch| { &m.grpc },
                |m: &mut RouteMatch| { &mut m.grpc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteMatch_TlsContextMatchOptions>>(
                "tls_context",
                |m: &RouteMatch| { &m.tls_context },
                |m: &mut RouteMatch| { &mut m.tls_context },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch>(
                "RouteMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch {
        static instance: ::protobuf::rt::LazyV2<RouteMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch::new)
    }
}

impl ::protobuf::Clear for RouteMatch {
    fn clear(&mut self) {
        self.path_specifier = ::std::option::Option::None;
        self.path_specifier = ::std::option::Option::None;
        self.path_specifier = ::std::option::Option::None;
        self.path_specifier = ::std::option::Option::None;
        self.case_sensitive.clear();
        self.runtime_fraction.clear();
        self.headers.clear();
        self.query_parameters.clear();
        self.grpc.clear();
        self.tls_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteMatch_GrpcRouteMatchOptions {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch_GrpcRouteMatchOptions {
    fn default() -> &'a RouteMatch_GrpcRouteMatchOptions {
        <RouteMatch_GrpcRouteMatchOptions as ::protobuf::Message>::default_instance()
    }
}

impl RouteMatch_GrpcRouteMatchOptions {
    pub fn new() -> RouteMatch_GrpcRouteMatchOptions {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RouteMatch_GrpcRouteMatchOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch_GrpcRouteMatchOptions {
        RouteMatch_GrpcRouteMatchOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch_GrpcRouteMatchOptions>(
                "RouteMatch.GrpcRouteMatchOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch_GrpcRouteMatchOptions {
        static instance: ::protobuf::rt::LazyV2<RouteMatch_GrpcRouteMatchOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch_GrpcRouteMatchOptions::new)
    }
}

impl ::protobuf::Clear for RouteMatch_GrpcRouteMatchOptions {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch_GrpcRouteMatchOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch_GrpcRouteMatchOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteMatch_TlsContextMatchOptions {
    // message fields
    pub presented: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub validated: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteMatch_TlsContextMatchOptions {
    fn default() -> &'a RouteMatch_TlsContextMatchOptions {
        <RouteMatch_TlsContextMatchOptions as ::protobuf::Message>::default_instance()
    }
}

impl RouteMatch_TlsContextMatchOptions {
    pub fn new() -> RouteMatch_TlsContextMatchOptions {
        ::std::default::Default::default()
    }

    // .google.protobuf.BoolValue presented = 1;


    pub fn get_presented(&self) -> &::protobuf::well_known_types::BoolValue {
        self.presented.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_presented(&mut self) {
        self.presented.clear();
    }

    pub fn has_presented(&self) -> bool {
        self.presented.is_some()
    }

    // Param is passed by value, moved
    pub fn set_presented(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.presented = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_presented(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.presented.is_none() {
            self.presented.set_default();
        }
        self.presented.as_mut().unwrap()
    }

    // Take field
    pub fn take_presented(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.presented.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.BoolValue validated = 2;


    pub fn get_validated(&self) -> &::protobuf::well_known_types::BoolValue {
        self.validated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_validated(&mut self) {
        self.validated.clear();
    }

    pub fn has_validated(&self) -> bool {
        self.validated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validated(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.validated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_validated(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.validated.is_none() {
            self.validated.set_default();
        }
        self.validated.as_mut().unwrap()
    }

    // Take field
    pub fn take_validated(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.validated.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for RouteMatch_TlsContextMatchOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.presented {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.validated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.presented)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.validated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.presented.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.validated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.presented.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.validated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteMatch_TlsContextMatchOptions {
        RouteMatch_TlsContextMatchOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "presented",
                |m: &RouteMatch_TlsContextMatchOptions| { &m.presented },
                |m: &mut RouteMatch_TlsContextMatchOptions| { &mut m.presented },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "validated",
                |m: &RouteMatch_TlsContextMatchOptions| { &m.validated },
                |m: &mut RouteMatch_TlsContextMatchOptions| { &mut m.validated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteMatch_TlsContextMatchOptions>(
                "RouteMatch.TlsContextMatchOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteMatch_TlsContextMatchOptions {
        static instance: ::protobuf::rt::LazyV2<RouteMatch_TlsContextMatchOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteMatch_TlsContextMatchOptions::new)
    }
}

impl ::protobuf::Clear for RouteMatch_TlsContextMatchOptions {
    fn clear(&mut self) {
        self.presented.clear();
        self.validated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteMatch_TlsContextMatchOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteMatch_TlsContextMatchOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CorsPolicy {
    // message fields
    pub allow_origin: ::protobuf::RepeatedField<::std::string::String>,
    pub allow_origin_regex: ::protobuf::RepeatedField<::std::string::String>,
    pub allow_origin_string_match: ::protobuf::RepeatedField<super::string::StringMatcher>,
    pub allow_methods: ::std::string::String,
    pub allow_headers: ::std::string::String,
    pub expose_headers: ::std::string::String,
    pub max_age: ::std::string::String,
    pub allow_credentials: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub shadow_enabled: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    // message oneof groups
    pub enabled_specifier: ::std::option::Option<CorsPolicy_oneof_enabled_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CorsPolicy {
    fn default() -> &'a CorsPolicy {
        <CorsPolicy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum CorsPolicy_oneof_enabled_specifier {
    enabled(::protobuf::well_known_types::BoolValue),
    filter_enabled(super::base::RuntimeFractionalPercent),
}

impl CorsPolicy {
    pub fn new() -> CorsPolicy {
        ::std::default::Default::default()
    }

    // repeated string allow_origin = 1;


    pub fn get_allow_origin(&self) -> &[::std::string::String] {
        &self.allow_origin
    }
    pub fn clear_allow_origin(&mut self) {
        self.allow_origin.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_origin(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allow_origin = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_origin(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allow_origin
    }

    // Take field
    pub fn take_allow_origin(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allow_origin, ::protobuf::RepeatedField::new())
    }

    // repeated string allow_origin_regex = 8;


    pub fn get_allow_origin_regex(&self) -> &[::std::string::String] {
        &self.allow_origin_regex
    }
    pub fn clear_allow_origin_regex(&mut self) {
        self.allow_origin_regex.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_origin_regex(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.allow_origin_regex = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_origin_regex(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.allow_origin_regex
    }

    // Take field
    pub fn take_allow_origin_regex(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.allow_origin_regex, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.type.matcher.StringMatcher allow_origin_string_match = 11;


    pub fn get_allow_origin_string_match(&self) -> &[super::string::StringMatcher] {
        &self.allow_origin_string_match
    }
    pub fn clear_allow_origin_string_match(&mut self) {
        self.allow_origin_string_match.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_origin_string_match(&mut self, v: ::protobuf::RepeatedField<super::string::StringMatcher>) {
        self.allow_origin_string_match = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allow_origin_string_match(&mut self) -> &mut ::protobuf::RepeatedField<super::string::StringMatcher> {
        &mut self.allow_origin_string_match
    }

    // Take field
    pub fn take_allow_origin_string_match(&mut self) -> ::protobuf::RepeatedField<super::string::StringMatcher> {
        ::std::mem::replace(&mut self.allow_origin_string_match, ::protobuf::RepeatedField::new())
    }

    // string allow_methods = 2;


    pub fn get_allow_methods(&self) -> &str {
        &self.allow_methods
    }
    pub fn clear_allow_methods(&mut self) {
        self.allow_methods.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_methods(&mut self, v: ::std::string::String) {
        self.allow_methods = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_methods(&mut self) -> &mut ::std::string::String {
        &mut self.allow_methods
    }

    // Take field
    pub fn take_allow_methods(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.allow_methods, ::std::string::String::new())
    }

    // string allow_headers = 3;


    pub fn get_allow_headers(&self) -> &str {
        &self.allow_headers
    }
    pub fn clear_allow_headers(&mut self) {
        self.allow_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_allow_headers(&mut self, v: ::std::string::String) {
        self.allow_headers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_headers(&mut self) -> &mut ::std::string::String {
        &mut self.allow_headers
    }

    // Take field
    pub fn take_allow_headers(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.allow_headers, ::std::string::String::new())
    }

    // string expose_headers = 4;


    pub fn get_expose_headers(&self) -> &str {
        &self.expose_headers
    }
    pub fn clear_expose_headers(&mut self) {
        self.expose_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_expose_headers(&mut self, v: ::std::string::String) {
        self.expose_headers = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expose_headers(&mut self) -> &mut ::std::string::String {
        &mut self.expose_headers
    }

    // Take field
    pub fn take_expose_headers(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expose_headers, ::std::string::String::new())
    }

    // string max_age = 5;


    pub fn get_max_age(&self) -> &str {
        &self.max_age
    }
    pub fn clear_max_age(&mut self) {
        self.max_age.clear();
    }

    // Param is passed by value, moved
    pub fn set_max_age(&mut self, v: ::std::string::String) {
        self.max_age = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_age(&mut self) -> &mut ::std::string::String {
        &mut self.max_age
    }

    // Take field
    pub fn take_max_age(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.max_age, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue allow_credentials = 6;


    pub fn get_allow_credentials(&self) -> &::protobuf::well_known_types::BoolValue {
        self.allow_credentials.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allow_credentials(&mut self) {
        self.allow_credentials.clear();
    }

    pub fn has_allow_credentials(&self) -> bool {
        self.allow_credentials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_credentials(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.allow_credentials = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allow_credentials(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.allow_credentials.is_none() {
            self.allow_credentials.set_default();
        }
        self.allow_credentials.as_mut().unwrap()
    }

    // Take field
    pub fn take_allow_credentials(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.allow_credentials.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.BoolValue enabled = 7;


    pub fn get_enabled(&self) -> &::protobuf::well_known_types::BoolValue {
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(ref v)) => v,
            _ => <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_enabled(&mut self) {
        self.enabled_specifier = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(v))
    }

    // Mutable pointer to the field.
    pub fn mut_enabled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if let ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(_)) = self.enabled_specifier {
        } else {
            self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(::protobuf::well_known_types::BoolValue::new()));
        }
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_enabled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        if self.has_enabled() {
            match self.enabled_specifier.take() {
                ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::BoolValue::new()
        }
    }

    // .envoy.api.v2.core.RuntimeFractionalPercent filter_enabled = 9;


    pub fn get_filter_enabled(&self) -> &super::base::RuntimeFractionalPercent {
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v)) => v,
            _ => <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_enabled(&mut self) {
        self.enabled_specifier = ::std::option::Option::None;
    }

    pub fn has_filter_enabled(&self) -> bool {
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_enabled(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_enabled(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if let ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(_)) = self.enabled_specifier {
        } else {
            self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(super::base::RuntimeFractionalPercent::new()));
        }
        match self.enabled_specifier {
            ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_enabled(&mut self) -> super::base::RuntimeFractionalPercent {
        if self.has_filter_enabled() {
            match self.enabled_specifier.take() {
                ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(v)) => v,
                _ => panic!(),
            }
        } else {
            super::base::RuntimeFractionalPercent::new()
        }
    }

    // .envoy.api.v2.core.RuntimeFractionalPercent shadow_enabled = 10;


    pub fn get_shadow_enabled(&self) -> &super::base::RuntimeFractionalPercent {
        self.shadow_enabled.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shadow_enabled(&mut self) {
        self.shadow_enabled.clear();
    }

    pub fn has_shadow_enabled(&self) -> bool {
        self.shadow_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shadow_enabled(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.shadow_enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shadow_enabled(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.shadow_enabled.is_none() {
            self.shadow_enabled.set_default();
        }
        self.shadow_enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_shadow_enabled(&mut self) -> super::base::RuntimeFractionalPercent {
        self.shadow_enabled.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }
}

impl ::protobuf::Message for CorsPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.allow_origin_string_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allow_credentials {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(CorsPolicy_oneof_enabled_specifier::enabled(ref v)) = self.enabled_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v)) = self.enabled_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.shadow_enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allow_origin)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.allow_origin_regex)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allow_origin_string_match)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.allow_methods)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.allow_headers)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expose_headers)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.max_age)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allow_credentials)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::enabled(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.enabled_specifier = ::std::option::Option::Some(CorsPolicy_oneof_enabled_specifier::filter_enabled(is.read_message()?));
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shadow_enabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allow_origin {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.allow_origin_regex {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        for value in &self.allow_origin_string_match {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.allow_methods.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.allow_methods);
        }
        if !self.allow_headers.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.allow_headers);
        }
        if !self.expose_headers.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.expose_headers);
        }
        if !self.max_age.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.max_age);
        }
        if let Some(ref v) = self.allow_credentials.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shadow_enabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.enabled_specifier {
            match v {
                &CorsPolicy_oneof_enabled_specifier::enabled(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allow_origin {
            os.write_string(1, &v)?;
        };
        for v in &self.allow_origin_regex {
            os.write_string(8, &v)?;
        };
        for v in &self.allow_origin_string_match {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.allow_methods.is_empty() {
            os.write_string(2, &self.allow_methods)?;
        }
        if !self.allow_headers.is_empty() {
            os.write_string(3, &self.allow_headers)?;
        }
        if !self.expose_headers.is_empty() {
            os.write_string(4, &self.expose_headers)?;
        }
        if !self.max_age.is_empty() {
            os.write_string(5, &self.max_age)?;
        }
        if let Some(ref v) = self.allow_credentials.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shadow_enabled.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.enabled_specifier {
            match v {
                &CorsPolicy_oneof_enabled_specifier::enabled(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &CorsPolicy_oneof_enabled_specifier::filter_enabled(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CorsPolicy {
        CorsPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_origin",
                |m: &CorsPolicy| { &m.allow_origin },
                |m: &mut CorsPolicy| { &mut m.allow_origin },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_origin_regex",
                |m: &CorsPolicy| { &m.allow_origin_regex },
                |m: &mut CorsPolicy| { &mut m.allow_origin_regex },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::StringMatcher>>(
                "allow_origin_string_match",
                |m: &CorsPolicy| { &m.allow_origin_string_match },
                |m: &mut CorsPolicy| { &mut m.allow_origin_string_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_methods",
                |m: &CorsPolicy| { &m.allow_methods },
                |m: &mut CorsPolicy| { &mut m.allow_methods },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allow_headers",
                |m: &CorsPolicy| { &m.allow_headers },
                |m: &mut CorsPolicy| { &mut m.allow_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expose_headers",
                |m: &CorsPolicy| { &m.expose_headers },
                |m: &mut CorsPolicy| { &mut m.expose_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "max_age",
                |m: &CorsPolicy| { &m.max_age },
                |m: &mut CorsPolicy| { &mut m.max_age },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "allow_credentials",
                |m: &CorsPolicy| { &m.allow_credentials },
                |m: &mut CorsPolicy| { &mut m.allow_credentials },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::BoolValue>(
                "enabled",
                CorsPolicy::has_enabled,
                CorsPolicy::get_enabled,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::base::RuntimeFractionalPercent>(
                "filter_enabled",
                CorsPolicy::has_filter_enabled,
                CorsPolicy::get_filter_enabled,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "shadow_enabled",
                |m: &CorsPolicy| { &m.shadow_enabled },
                |m: &mut CorsPolicy| { &mut m.shadow_enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CorsPolicy>(
                "CorsPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CorsPolicy {
        static instance: ::protobuf::rt::LazyV2<CorsPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CorsPolicy::new)
    }
}

impl ::protobuf::Clear for CorsPolicy {
    fn clear(&mut self) {
        self.allow_origin.clear();
        self.allow_origin_regex.clear();
        self.allow_origin_string_match.clear();
        self.allow_methods.clear();
        self.allow_headers.clear();
        self.expose_headers.clear();
        self.max_age.clear();
        self.allow_credentials.clear();
        self.enabled_specifier = ::std::option::Option::None;
        self.enabled_specifier = ::std::option::Option::None;
        self.shadow_enabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CorsPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CorsPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction {
    // message fields
    pub cluster_not_found_response_code: RouteAction_ClusterNotFoundResponseCode,
    pub metadata_match: ::protobuf::SingularPtrField<super::base::Metadata>,
    pub prefix_rewrite: ::std::string::String,
    pub regex_rewrite: ::protobuf::SingularPtrField<super::regex::RegexMatchAndSubstitute>,
    pub timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub idle_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub retry_policy: ::protobuf::SingularPtrField<RetryPolicy>,
    pub retry_policy_typed_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub request_mirror_policy: ::protobuf::SingularPtrField<RouteAction_RequestMirrorPolicy>,
    pub request_mirror_policies: ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy>,
    pub priority: super::base::RoutingPriority,
    pub rate_limits: ::protobuf::RepeatedField<RateLimit>,
    pub include_vh_rate_limits: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub hash_policy: ::protobuf::RepeatedField<RouteAction_HashPolicy>,
    pub cors: ::protobuf::SingularPtrField<CorsPolicy>,
    pub max_grpc_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub grpc_timeout_offset: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub upgrade_configs: ::protobuf::RepeatedField<RouteAction_UpgradeConfig>,
    pub internal_redirect_action: RouteAction_InternalRedirectAction,
    pub max_internal_redirects: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub hedge_policy: ::protobuf::SingularPtrField<HedgePolicy>,
    // message oneof groups
    pub cluster_specifier: ::std::option::Option<RouteAction_oneof_cluster_specifier>,
    pub host_rewrite_specifier: ::std::option::Option<RouteAction_oneof_host_rewrite_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction {
    fn default() -> &'a RouteAction {
        <RouteAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RouteAction_oneof_cluster_specifier {
    cluster(::std::string::String),
    cluster_header(::std::string::String),
    weighted_clusters(WeightedCluster),
}

#[derive(Clone,PartialEq,Debug)]
pub enum RouteAction_oneof_host_rewrite_specifier {
    host_rewrite(::std::string::String),
    auto_host_rewrite(::protobuf::well_known_types::BoolValue),
    auto_host_rewrite_header(::std::string::String),
}

impl RouteAction {
    pub fn new() -> RouteAction {
        ::std::default::Default::default()
    }

    // string cluster = 1;


    pub fn get_cluster(&self) -> &str {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::std::string::String) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(::std::string::String::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::std::string::String {
        if self.has_cluster() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string cluster_header = 2;


    pub fn get_cluster_header(&self) -> &str {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_cluster_header(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_cluster_header(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cluster_header(&mut self, v: ::std::string::String) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_header(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(::std::string::String::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cluster_header(&mut self) -> ::std::string::String {
        if self.has_cluster_header() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.api.v2.route.WeightedCluster weighted_clusters = 3;


    pub fn get_weighted_clusters(&self) -> &WeightedCluster {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(ref v)) => v,
            _ => <WeightedCluster as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_weighted_clusters(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
    }

    pub fn has_weighted_clusters(&self) -> bool {
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_weighted_clusters(&mut self, v: WeightedCluster) {
        self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(v))
    }

    // Mutable pointer to the field.
    pub fn mut_weighted_clusters(&mut self) -> &mut WeightedCluster {
        if let ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(_)) = self.cluster_specifier {
        } else {
            self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(WeightedCluster::new()));
        }
        match self.cluster_specifier {
            ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_weighted_clusters(&mut self) -> WeightedCluster {
        if self.has_weighted_clusters() {
            match self.cluster_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(v)) => v,
                _ => panic!(),
            }
        } else {
            WeightedCluster::new()
        }
    }

    // .envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCode cluster_not_found_response_code = 20;


    pub fn get_cluster_not_found_response_code(&self) -> RouteAction_ClusterNotFoundResponseCode {
        self.cluster_not_found_response_code
    }
    pub fn clear_cluster_not_found_response_code(&mut self) {
        self.cluster_not_found_response_code = RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE;
    }

    // Param is passed by value, moved
    pub fn set_cluster_not_found_response_code(&mut self, v: RouteAction_ClusterNotFoundResponseCode) {
        self.cluster_not_found_response_code = v;
    }

    // .envoy.api.v2.core.Metadata metadata_match = 4;


    pub fn get_metadata_match(&self) -> &super::base::Metadata {
        self.metadata_match.as_ref().unwrap_or_else(|| <super::base::Metadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata_match(&mut self) {
        self.metadata_match.clear();
    }

    pub fn has_metadata_match(&self) -> bool {
        self.metadata_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_match(&mut self, v: super::base::Metadata) {
        self.metadata_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata_match(&mut self) -> &mut super::base::Metadata {
        if self.metadata_match.is_none() {
            self.metadata_match.set_default();
        }
        self.metadata_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata_match(&mut self) -> super::base::Metadata {
        self.metadata_match.take().unwrap_or_else(|| super::base::Metadata::new())
    }

    // string prefix_rewrite = 5;


    pub fn get_prefix_rewrite(&self) -> &str {
        &self.prefix_rewrite
    }
    pub fn clear_prefix_rewrite(&mut self) {
        self.prefix_rewrite.clear();
    }

    // Param is passed by value, moved
    pub fn set_prefix_rewrite(&mut self, v: ::std::string::String) {
        self.prefix_rewrite = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix_rewrite(&mut self) -> &mut ::std::string::String {
        &mut self.prefix_rewrite
    }

    // Take field
    pub fn take_prefix_rewrite(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prefix_rewrite, ::std::string::String::new())
    }

    // .envoy.type.matcher.RegexMatchAndSubstitute regex_rewrite = 32;


    pub fn get_regex_rewrite(&self) -> &super::regex::RegexMatchAndSubstitute {
        self.regex_rewrite.as_ref().unwrap_or_else(|| <super::regex::RegexMatchAndSubstitute as ::protobuf::Message>::default_instance())
    }
    pub fn clear_regex_rewrite(&mut self) {
        self.regex_rewrite.clear();
    }

    pub fn has_regex_rewrite(&self) -> bool {
        self.regex_rewrite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_regex_rewrite(&mut self, v: super::regex::RegexMatchAndSubstitute) {
        self.regex_rewrite = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regex_rewrite(&mut self) -> &mut super::regex::RegexMatchAndSubstitute {
        if self.regex_rewrite.is_none() {
            self.regex_rewrite.set_default();
        }
        self.regex_rewrite.as_mut().unwrap()
    }

    // Take field
    pub fn take_regex_rewrite(&mut self) -> super::regex::RegexMatchAndSubstitute {
        self.regex_rewrite.take().unwrap_or_else(|| super::regex::RegexMatchAndSubstitute::new())
    }

    // string host_rewrite = 6;


    pub fn get_host_rewrite(&self) -> &str {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_host_rewrite(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_host_rewrite(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_host_rewrite(&mut self, v: ::std::string::String) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_host_rewrite(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(::std::string::String::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_host_rewrite(&mut self) -> ::std::string::String {
        if self.has_host_rewrite() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.protobuf.BoolValue auto_host_rewrite = 7;


    pub fn get_auto_host_rewrite(&self) -> &::protobuf::well_known_types::BoolValue {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v)) => v,
            _ => <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_auto_host_rewrite(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_auto_host_rewrite(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_auto_host_rewrite(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_auto_host_rewrite(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(::protobuf::well_known_types::BoolValue::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_auto_host_rewrite(&mut self) -> ::protobuf::well_known_types::BoolValue {
        if self.has_auto_host_rewrite() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::BoolValue::new()
        }
    }

    // string auto_host_rewrite_header = 29;


    pub fn get_auto_host_rewrite_header(&self) -> &str {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_auto_host_rewrite_header(&mut self) {
        self.host_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_auto_host_rewrite_header(&self) -> bool {
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_auto_host_rewrite_header(&mut self, v: ::std::string::String) {
        self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_auto_host_rewrite_header(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(_)) = self.host_rewrite_specifier {
        } else {
            self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(::std::string::String::new()));
        }
        match self.host_rewrite_specifier {
            ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_auto_host_rewrite_header(&mut self) -> ::std::string::String {
        if self.has_auto_host_rewrite_header() {
            match self.host_rewrite_specifier.take() {
                ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .google.protobuf.Duration timeout = 8;


    pub fn get_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeout(&mut self) {
        self.timeout.clear();
    }

    pub fn has_timeout(&self) -> bool {
        self.timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.timeout.is_none() {
            self.timeout.set_default();
        }
        self.timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration idle_timeout = 24;


    pub fn get_idle_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.idle_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_idle_timeout(&mut self) {
        self.idle_timeout.clear();
    }

    pub fn has_idle_timeout(&self) -> bool {
        self.idle_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idle_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.idle_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idle_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.idle_timeout.is_none() {
            self.idle_timeout.set_default();
        }
        self.idle_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_idle_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.idle_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.api.v2.route.RetryPolicy retry_policy = 9;


    pub fn get_retry_policy(&self) -> &RetryPolicy {
        self.retry_policy.as_ref().unwrap_or_else(|| <RetryPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy(&mut self) {
        self.retry_policy.clear();
    }

    pub fn has_retry_policy(&self) -> bool {
        self.retry_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy(&mut self, v: RetryPolicy) {
        self.retry_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy(&mut self) -> &mut RetryPolicy {
        if self.retry_policy.is_none() {
            self.retry_policy.set_default();
        }
        self.retry_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy(&mut self) -> RetryPolicy {
        self.retry_policy.take().unwrap_or_else(|| RetryPolicy::new())
    }

    // .google.protobuf.Any retry_policy_typed_config = 33;


    pub fn get_retry_policy_typed_config(&self) -> &::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_policy_typed_config(&mut self) {
        self.retry_policy_typed_config.clear();
    }

    pub fn has_retry_policy_typed_config(&self) -> bool {
        self.retry_policy_typed_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_policy_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.retry_policy_typed_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_policy_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.retry_policy_typed_config.is_none() {
            self.retry_policy_typed_config.set_default();
        }
        self.retry_policy_typed_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_policy_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.retry_policy_typed_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policy = 10;


    pub fn get_request_mirror_policy(&self) -> &RouteAction_RequestMirrorPolicy {
        self.request_mirror_policy.as_ref().unwrap_or_else(|| <RouteAction_RequestMirrorPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_request_mirror_policy(&mut self) {
        self.request_mirror_policy.clear();
    }

    pub fn has_request_mirror_policy(&self) -> bool {
        self.request_mirror_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_mirror_policy(&mut self, v: RouteAction_RequestMirrorPolicy) {
        self.request_mirror_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request_mirror_policy(&mut self) -> &mut RouteAction_RequestMirrorPolicy {
        if self.request_mirror_policy.is_none() {
            self.request_mirror_policy.set_default();
        }
        self.request_mirror_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_request_mirror_policy(&mut self) -> RouteAction_RequestMirrorPolicy {
        self.request_mirror_policy.take().unwrap_or_else(|| RouteAction_RequestMirrorPolicy::new())
    }

    // repeated .envoy.api.v2.route.RouteAction.RequestMirrorPolicy request_mirror_policies = 30;


    pub fn get_request_mirror_policies(&self) -> &[RouteAction_RequestMirrorPolicy] {
        &self.request_mirror_policies
    }
    pub fn clear_request_mirror_policies(&mut self) {
        self.request_mirror_policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_request_mirror_policies(&mut self, v: ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy>) {
        self.request_mirror_policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_request_mirror_policies(&mut self) -> &mut ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy> {
        &mut self.request_mirror_policies
    }

    // Take field
    pub fn take_request_mirror_policies(&mut self) -> ::protobuf::RepeatedField<RouteAction_RequestMirrorPolicy> {
        ::std::mem::replace(&mut self.request_mirror_policies, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.core.RoutingPriority priority = 11;


    pub fn get_priority(&self) -> super::base::RoutingPriority {
        self.priority
    }
    pub fn clear_priority(&mut self) {
        self.priority = super::base::RoutingPriority::DEFAULT;
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: super::base::RoutingPriority) {
        self.priority = v;
    }

    // repeated .envoy.api.v2.route.RateLimit rate_limits = 13;


    pub fn get_rate_limits(&self) -> &[RateLimit] {
        &self.rate_limits
    }
    pub fn clear_rate_limits(&mut self) {
        self.rate_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate_limits(&mut self, v: ::protobuf::RepeatedField<RateLimit>) {
        self.rate_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rate_limits(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit> {
        &mut self.rate_limits
    }

    // Take field
    pub fn take_rate_limits(&mut self) -> ::protobuf::RepeatedField<RateLimit> {
        ::std::mem::replace(&mut self.rate_limits, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.BoolValue include_vh_rate_limits = 14;


    pub fn get_include_vh_rate_limits(&self) -> &::protobuf::well_known_types::BoolValue {
        self.include_vh_rate_limits.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_include_vh_rate_limits(&mut self) {
        self.include_vh_rate_limits.clear();
    }

    pub fn has_include_vh_rate_limits(&self) -> bool {
        self.include_vh_rate_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_vh_rate_limits(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.include_vh_rate_limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_include_vh_rate_limits(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.include_vh_rate_limits.is_none() {
            self.include_vh_rate_limits.set_default();
        }
        self.include_vh_rate_limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_include_vh_rate_limits(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.include_vh_rate_limits.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // repeated .envoy.api.v2.route.RouteAction.HashPolicy hash_policy = 15;


    pub fn get_hash_policy(&self) -> &[RouteAction_HashPolicy] {
        &self.hash_policy
    }
    pub fn clear_hash_policy(&mut self) {
        self.hash_policy.clear();
    }

    // Param is passed by value, moved
    pub fn set_hash_policy(&mut self, v: ::protobuf::RepeatedField<RouteAction_HashPolicy>) {
        self.hash_policy = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hash_policy(&mut self) -> &mut ::protobuf::RepeatedField<RouteAction_HashPolicy> {
        &mut self.hash_policy
    }

    // Take field
    pub fn take_hash_policy(&mut self) -> ::protobuf::RepeatedField<RouteAction_HashPolicy> {
        ::std::mem::replace(&mut self.hash_policy, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.route.CorsPolicy cors = 17;


    pub fn get_cors(&self) -> &CorsPolicy {
        self.cors.as_ref().unwrap_or_else(|| <CorsPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cors(&mut self) {
        self.cors.clear();
    }

    pub fn has_cors(&self) -> bool {
        self.cors.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cors(&mut self, v: CorsPolicy) {
        self.cors = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cors(&mut self) -> &mut CorsPolicy {
        if self.cors.is_none() {
            self.cors.set_default();
        }
        self.cors.as_mut().unwrap()
    }

    // Take field
    pub fn take_cors(&mut self) -> CorsPolicy {
        self.cors.take().unwrap_or_else(|| CorsPolicy::new())
    }

    // .google.protobuf.Duration max_grpc_timeout = 23;


    pub fn get_max_grpc_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.max_grpc_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_grpc_timeout(&mut self) {
        self.max_grpc_timeout.clear();
    }

    pub fn has_max_grpc_timeout(&self) -> bool {
        self.max_grpc_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_grpc_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_grpc_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_grpc_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_grpc_timeout.is_none() {
            self.max_grpc_timeout.set_default();
        }
        self.max_grpc_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_grpc_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_grpc_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration grpc_timeout_offset = 28;


    pub fn get_grpc_timeout_offset(&self) -> &::protobuf::well_known_types::Duration {
        self.grpc_timeout_offset.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc_timeout_offset(&mut self) {
        self.grpc_timeout_offset.clear();
    }

    pub fn has_grpc_timeout_offset(&self) -> bool {
        self.grpc_timeout_offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc_timeout_offset(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.grpc_timeout_offset = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc_timeout_offset(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.grpc_timeout_offset.is_none() {
            self.grpc_timeout_offset.set_default();
        }
        self.grpc_timeout_offset.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc_timeout_offset(&mut self) -> ::protobuf::well_known_types::Duration {
        self.grpc_timeout_offset.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // repeated .envoy.api.v2.route.RouteAction.UpgradeConfig upgrade_configs = 25;


    pub fn get_upgrade_configs(&self) -> &[RouteAction_UpgradeConfig] {
        &self.upgrade_configs
    }
    pub fn clear_upgrade_configs(&mut self) {
        self.upgrade_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_upgrade_configs(&mut self, v: ::protobuf::RepeatedField<RouteAction_UpgradeConfig>) {
        self.upgrade_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_upgrade_configs(&mut self) -> &mut ::protobuf::RepeatedField<RouteAction_UpgradeConfig> {
        &mut self.upgrade_configs
    }

    // Take field
    pub fn take_upgrade_configs(&mut self) -> ::protobuf::RepeatedField<RouteAction_UpgradeConfig> {
        ::std::mem::replace(&mut self.upgrade_configs, ::protobuf::RepeatedField::new())
    }

    // .envoy.api.v2.route.RouteAction.InternalRedirectAction internal_redirect_action = 26;


    pub fn get_internal_redirect_action(&self) -> RouteAction_InternalRedirectAction {
        self.internal_redirect_action
    }
    pub fn clear_internal_redirect_action(&mut self) {
        self.internal_redirect_action = RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT;
    }

    // Param is passed by value, moved
    pub fn set_internal_redirect_action(&mut self, v: RouteAction_InternalRedirectAction) {
        self.internal_redirect_action = v;
    }

    // .google.protobuf.UInt32Value max_internal_redirects = 31;


    pub fn get_max_internal_redirects(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.max_internal_redirects.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_internal_redirects(&mut self) {
        self.max_internal_redirects.clear();
    }

    pub fn has_max_internal_redirects(&self) -> bool {
        self.max_internal_redirects.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_internal_redirects(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.max_internal_redirects = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_internal_redirects(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.max_internal_redirects.is_none() {
            self.max_internal_redirects.set_default();
        }
        self.max_internal_redirects.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_internal_redirects(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.max_internal_redirects.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .envoy.api.v2.route.HedgePolicy hedge_policy = 27;


    pub fn get_hedge_policy(&self) -> &HedgePolicy {
        self.hedge_policy.as_ref().unwrap_or_else(|| <HedgePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hedge_policy(&mut self) {
        self.hedge_policy.clear();
    }

    pub fn has_hedge_policy(&self) -> bool {
        self.hedge_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hedge_policy(&mut self, v: HedgePolicy) {
        self.hedge_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hedge_policy(&mut self) -> &mut HedgePolicy {
        if self.hedge_policy.is_none() {
            self.hedge_policy.set_default();
        }
        self.hedge_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_hedge_policy(&mut self) -> HedgePolicy {
        self.hedge_policy.take().unwrap_or_else(|| HedgePolicy::new())
    }
}

impl ::protobuf::Message for RouteAction {
    fn is_initialized(&self) -> bool {
        if let Some(RouteAction_oneof_cluster_specifier::weighted_clusters(ref v)) = self.cluster_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.metadata_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.regex_rewrite {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v)) = self.host_rewrite_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.idle_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_policy_typed_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_mirror_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request_mirror_policies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rate_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.include_vh_rate_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hash_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cors {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_grpc_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc_timeout_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upgrade_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_internal_redirects {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hedge_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::cluster_header(is.read_string()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.cluster_specifier = ::std::option::Option::Some(RouteAction_oneof_cluster_specifier::weighted_clusters(is.read_message()?));
                },
                20 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.cluster_not_found_response_code, 20, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata_match)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prefix_rewrite)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.regex_rewrite)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::host_rewrite(is.read_string()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(is.read_message()?));
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.host_rewrite_specifier = ::std::option::Option::Some(RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(is.read_string()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeout)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.idle_timeout)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_policy_typed_config)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request_mirror_policy)?;
                },
                30 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.request_mirror_policies)?;
                },
                11 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.priority, 11, &mut self.unknown_fields)?
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rate_limits)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.include_vh_rate_limits)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hash_policy)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cors)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_grpc_timeout)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc_timeout_offset)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.upgrade_configs)?;
                },
                26 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.internal_redirect_action, 26, &mut self.unknown_fields)?
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_internal_redirects)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hedge_policy)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cluster_not_found_response_code != RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE {
            my_size += ::protobuf::rt::enum_size(20, self.cluster_not_found_response_code);
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.prefix_rewrite.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.prefix_rewrite);
        }
        if let Some(ref v) = self.regex_rewrite.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.request_mirror_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.request_mirror_policies {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.priority != super::base::RoutingPriority::DEFAULT {
            my_size += ::protobuf::rt::enum_size(11, self.priority);
        }
        for value in &self.rate_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.include_vh_rate_limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.hash_policy {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.cors.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_grpc_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.grpc_timeout_offset.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.upgrade_configs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.internal_redirect_action != RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT {
            my_size += ::protobuf::rt::enum_size(26, self.internal_redirect_action);
        }
        if let Some(ref v) = self.max_internal_redirects.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.cluster_specifier {
            match v {
                &RouteAction_oneof_cluster_specifier::cluster(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &RouteAction_oneof_cluster_specifier::cluster_header(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &RouteAction_oneof_cluster_specifier::weighted_clusters(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.host_rewrite_specifier {
            match v {
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite(ref v) => {
                    my_size += ::protobuf::rt::string_size(6, &v);
                },
                &RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(ref v) => {
                    my_size += ::protobuf::rt::string_size(29, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cluster_not_found_response_code != RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE {
            os.write_enum(20, ::protobuf::ProtobufEnum::value(&self.cluster_not_found_response_code))?;
        }
        if let Some(ref v) = self.metadata_match.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.prefix_rewrite.is_empty() {
            os.write_string(5, &self.prefix_rewrite)?;
        }
        if let Some(ref v) = self.regex_rewrite.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.timeout.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.idle_timeout.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_policy_typed_config.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.request_mirror_policy.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.request_mirror_policies {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.priority != super::base::RoutingPriority::DEFAULT {
            os.write_enum(11, ::protobuf::ProtobufEnum::value(&self.priority))?;
        }
        for v in &self.rate_limits {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.include_vh_rate_limits.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.hash_policy {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.cors.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_grpc_timeout.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.grpc_timeout_offset.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.upgrade_configs {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.internal_redirect_action != RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT {
            os.write_enum(26, ::protobuf::ProtobufEnum::value(&self.internal_redirect_action))?;
        }
        if let Some(ref v) = self.max_internal_redirects.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hedge_policy.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.cluster_specifier {
            match v {
                &RouteAction_oneof_cluster_specifier::cluster(ref v) => {
                    os.write_string(1, v)?;
                },
                &RouteAction_oneof_cluster_specifier::cluster_header(ref v) => {
                    os.write_string(2, v)?;
                },
                &RouteAction_oneof_cluster_specifier::weighted_clusters(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.host_rewrite_specifier {
            match v {
                &RouteAction_oneof_host_rewrite_specifier::host_rewrite(ref v) => {
                    os.write_string(6, v)?;
                },
                &RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_oneof_host_rewrite_specifier::auto_host_rewrite_header(ref v) => {
                    os.write_string(29, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction {
        RouteAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster",
                RouteAction::has_cluster,
                RouteAction::get_cluster,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "cluster_header",
                RouteAction::has_cluster_header,
                RouteAction::get_cluster_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, WeightedCluster>(
                "weighted_clusters",
                RouteAction::has_weighted_clusters,
                RouteAction::get_weighted_clusters,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RouteAction_ClusterNotFoundResponseCode>>(
                "cluster_not_found_response_code",
                |m: &RouteAction| { &m.cluster_not_found_response_code },
                |m: &mut RouteAction| { &mut m.cluster_not_found_response_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Metadata>>(
                "metadata_match",
                |m: &RouteAction| { &m.metadata_match },
                |m: &mut RouteAction| { &mut m.metadata_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix_rewrite",
                |m: &RouteAction| { &m.prefix_rewrite },
                |m: &mut RouteAction| { &mut m.prefix_rewrite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::regex::RegexMatchAndSubstitute>>(
                "regex_rewrite",
                |m: &RouteAction| { &m.regex_rewrite },
                |m: &mut RouteAction| { &mut m.regex_rewrite },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "host_rewrite",
                RouteAction::has_host_rewrite,
                RouteAction::get_host_rewrite,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::BoolValue>(
                "auto_host_rewrite",
                RouteAction::has_auto_host_rewrite,
                RouteAction::get_auto_host_rewrite,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "auto_host_rewrite_header",
                RouteAction::has_auto_host_rewrite_header,
                RouteAction::get_auto_host_rewrite_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "timeout",
                |m: &RouteAction| { &m.timeout },
                |m: &mut RouteAction| { &mut m.timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "idle_timeout",
                |m: &RouteAction| { &m.idle_timeout },
                |m: &mut RouteAction| { &mut m.idle_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy>>(
                "retry_policy",
                |m: &RouteAction| { &m.retry_policy },
                |m: &mut RouteAction| { &mut m.retry_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "retry_policy_typed_config",
                |m: &RouteAction| { &m.retry_policy_typed_config },
                |m: &mut RouteAction| { &mut m.retry_policy_typed_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_RequestMirrorPolicy>>(
                "request_mirror_policy",
                |m: &RouteAction| { &m.request_mirror_policy },
                |m: &mut RouteAction| { &mut m.request_mirror_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_RequestMirrorPolicy>>(
                "request_mirror_policies",
                |m: &RouteAction| { &m.request_mirror_policies },
                |m: &mut RouteAction| { &mut m.request_mirror_policies },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::base::RoutingPriority>>(
                "priority",
                |m: &RouteAction| { &m.priority },
                |m: &mut RouteAction| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit>>(
                "rate_limits",
                |m: &RouteAction| { &m.rate_limits },
                |m: &mut RouteAction| { &mut m.rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "include_vh_rate_limits",
                |m: &RouteAction| { &m.include_vh_rate_limits },
                |m: &mut RouteAction| { &mut m.include_vh_rate_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_HashPolicy>>(
                "hash_policy",
                |m: &RouteAction| { &m.hash_policy },
                |m: &mut RouteAction| { &mut m.hash_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CorsPolicy>>(
                "cors",
                |m: &RouteAction| { &m.cors },
                |m: &mut RouteAction| { &mut m.cors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_grpc_timeout",
                |m: &RouteAction| { &m.max_grpc_timeout },
                |m: &mut RouteAction| { &mut m.max_grpc_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "grpc_timeout_offset",
                |m: &RouteAction| { &m.grpc_timeout_offset },
                |m: &mut RouteAction| { &mut m.grpc_timeout_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteAction_UpgradeConfig>>(
                "upgrade_configs",
                |m: &RouteAction| { &m.upgrade_configs },
                |m: &mut RouteAction| { &mut m.upgrade_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RouteAction_InternalRedirectAction>>(
                "internal_redirect_action",
                |m: &RouteAction| { &m.internal_redirect_action },
                |m: &mut RouteAction| { &mut m.internal_redirect_action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "max_internal_redirects",
                |m: &RouteAction| { &m.max_internal_redirects },
                |m: &mut RouteAction| { &mut m.max_internal_redirects },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HedgePolicy>>(
                "hedge_policy",
                |m: &RouteAction| { &m.hedge_policy },
                |m: &mut RouteAction| { &mut m.hedge_policy },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction>(
                "RouteAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction {
        static instance: ::protobuf::rt::LazyV2<RouteAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction::new)
    }
}

impl ::protobuf::Clear for RouteAction {
    fn clear(&mut self) {
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_specifier = ::std::option::Option::None;
        self.cluster_not_found_response_code = RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE;
        self.metadata_match.clear();
        self.prefix_rewrite.clear();
        self.regex_rewrite.clear();
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.host_rewrite_specifier = ::std::option::Option::None;
        self.timeout.clear();
        self.idle_timeout.clear();
        self.retry_policy.clear();
        self.retry_policy_typed_config.clear();
        self.request_mirror_policy.clear();
        self.request_mirror_policies.clear();
        self.priority = super::base::RoutingPriority::DEFAULT;
        self.rate_limits.clear();
        self.include_vh_rate_limits.clear();
        self.hash_policy.clear();
        self.cors.clear();
        self.max_grpc_timeout.clear();
        self.grpc_timeout_offset.clear();
        self.upgrade_configs.clear();
        self.internal_redirect_action = RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT;
        self.max_internal_redirects.clear();
        self.hedge_policy.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_RequestMirrorPolicy {
    // message fields
    pub cluster: ::std::string::String,
    pub runtime_key: ::std::string::String,
    pub runtime_fraction: ::protobuf::SingularPtrField<super::base::RuntimeFractionalPercent>,
    pub trace_sampled: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_RequestMirrorPolicy {
    fn default() -> &'a RouteAction_RequestMirrorPolicy {
        <RouteAction_RequestMirrorPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_RequestMirrorPolicy {
    pub fn new() -> RouteAction_RequestMirrorPolicy {
        ::std::default::Default::default()
    }

    // string cluster = 1;


    pub fn get_cluster(&self) -> &str {
        &self.cluster
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::std::string::String) {
        self.cluster = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut ::std::string::String {
        &mut self.cluster
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster, ::std::string::String::new())
    }

    // string runtime_key = 2;


    pub fn get_runtime_key(&self) -> &str {
        &self.runtime_key
    }
    pub fn clear_runtime_key(&mut self) {
        self.runtime_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime_key(&mut self, v: ::std::string::String) {
        self.runtime_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_key(&mut self) -> &mut ::std::string::String {
        &mut self.runtime_key
    }

    // Take field
    pub fn take_runtime_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime_key, ::std::string::String::new())
    }

    // .envoy.api.v2.core.RuntimeFractionalPercent runtime_fraction = 3;


    pub fn get_runtime_fraction(&self) -> &super::base::RuntimeFractionalPercent {
        self.runtime_fraction.as_ref().unwrap_or_else(|| <super::base::RuntimeFractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime_fraction(&mut self) {
        self.runtime_fraction.clear();
    }

    pub fn has_runtime_fraction(&self) -> bool {
        self.runtime_fraction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime_fraction(&mut self, v: super::base::RuntimeFractionalPercent) {
        self.runtime_fraction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime_fraction(&mut self) -> &mut super::base::RuntimeFractionalPercent {
        if self.runtime_fraction.is_none() {
            self.runtime_fraction.set_default();
        }
        self.runtime_fraction.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime_fraction(&mut self) -> super::base::RuntimeFractionalPercent {
        self.runtime_fraction.take().unwrap_or_else(|| super::base::RuntimeFractionalPercent::new())
    }

    // .google.protobuf.BoolValue trace_sampled = 4;


    pub fn get_trace_sampled(&self) -> &::protobuf::well_known_types::BoolValue {
        self.trace_sampled.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trace_sampled(&mut self) {
        self.trace_sampled.clear();
    }

    pub fn has_trace_sampled(&self) -> bool {
        self.trace_sampled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_sampled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.trace_sampled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_sampled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.trace_sampled.is_none() {
            self.trace_sampled.set_default();
        }
        self.trace_sampled.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace_sampled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.trace_sampled.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for RouteAction_RequestMirrorPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.runtime_fraction {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trace_sampled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime_fraction)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace_sampled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cluster.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cluster);
        }
        if !self.runtime_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.runtime_key);
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trace_sampled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cluster.is_empty() {
            os.write_string(1, &self.cluster)?;
        }
        if !self.runtime_key.is_empty() {
            os.write_string(2, &self.runtime_key)?;
        }
        if let Some(ref v) = self.runtime_fraction.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trace_sampled.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_RequestMirrorPolicy {
        RouteAction_RequestMirrorPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster",
                |m: &RouteAction_RequestMirrorPolicy| { &m.cluster },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtime_key",
                |m: &RouteAction_RequestMirrorPolicy| { &m.runtime_key },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.runtime_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::RuntimeFractionalPercent>>(
                "runtime_fraction",
                |m: &RouteAction_RequestMirrorPolicy| { &m.runtime_fraction },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.runtime_fraction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "trace_sampled",
                |m: &RouteAction_RequestMirrorPolicy| { &m.trace_sampled },
                |m: &mut RouteAction_RequestMirrorPolicy| { &mut m.trace_sampled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_RequestMirrorPolicy>(
                "RouteAction.RequestMirrorPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_RequestMirrorPolicy {
        static instance: ::protobuf::rt::LazyV2<RouteAction_RequestMirrorPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_RequestMirrorPolicy::new)
    }
}

impl ::protobuf::Clear for RouteAction_RequestMirrorPolicy {
    fn clear(&mut self) {
        self.cluster.clear();
        self.runtime_key.clear();
        self.runtime_fraction.clear();
        self.trace_sampled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_RequestMirrorPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_RequestMirrorPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_HashPolicy {
    // message fields
    pub terminal: bool,
    // message oneof groups
    pub policy_specifier: ::std::option::Option<RouteAction_HashPolicy_oneof_policy_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy {
    fn default() -> &'a RouteAction_HashPolicy {
        <RouteAction_HashPolicy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RouteAction_HashPolicy_oneof_policy_specifier {
    header(RouteAction_HashPolicy_Header),
    cookie(RouteAction_HashPolicy_Cookie),
    connection_properties(RouteAction_HashPolicy_ConnectionProperties),
    query_parameter(RouteAction_HashPolicy_QueryParameter),
    filter_state(RouteAction_HashPolicy_FilterState),
}

impl RouteAction_HashPolicy {
    pub fn new() -> RouteAction_HashPolicy {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.route.RouteAction.HashPolicy.Header header = 1;


    pub fn get_header(&self) -> &RouteAction_HashPolicy_Header {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(ref v)) => v,
            _ => <RouteAction_HashPolicy_Header as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: RouteAction_HashPolicy_Header) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut RouteAction_HashPolicy_Header {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(RouteAction_HashPolicy_Header::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> RouteAction_HashPolicy_Header {
        if self.has_header() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_Header::new()
        }
    }

    // .envoy.api.v2.route.RouteAction.HashPolicy.Cookie cookie = 2;


    pub fn get_cookie(&self) -> &RouteAction_HashPolicy_Cookie {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v)) => v,
            _ => <RouteAction_HashPolicy_Cookie as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_cookie(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_cookie(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cookie(&mut self, v: RouteAction_HashPolicy_Cookie) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cookie(&mut self) -> &mut RouteAction_HashPolicy_Cookie {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(RouteAction_HashPolicy_Cookie::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cookie(&mut self) -> RouteAction_HashPolicy_Cookie {
        if self.has_cookie() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_Cookie::new()
        }
    }

    // .envoy.api.v2.route.RouteAction.HashPolicy.ConnectionProperties connection_properties = 3;


    pub fn get_connection_properties(&self) -> &RouteAction_HashPolicy_ConnectionProperties {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v)) => v,
            _ => <RouteAction_HashPolicy_ConnectionProperties as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_connection_properties(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_connection_properties(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_connection_properties(&mut self, v: RouteAction_HashPolicy_ConnectionProperties) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(v))
    }

    // Mutable pointer to the field.
    pub fn mut_connection_properties(&mut self) -> &mut RouteAction_HashPolicy_ConnectionProperties {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(RouteAction_HashPolicy_ConnectionProperties::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_connection_properties(&mut self) -> RouteAction_HashPolicy_ConnectionProperties {
        if self.has_connection_properties() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_ConnectionProperties::new()
        }
    }

    // .envoy.api.v2.route.RouteAction.HashPolicy.QueryParameter query_parameter = 5;


    pub fn get_query_parameter(&self) -> &RouteAction_HashPolicy_QueryParameter {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v)) => v,
            _ => <RouteAction_HashPolicy_QueryParameter as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_query_parameter(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_query_parameter(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_query_parameter(&mut self, v: RouteAction_HashPolicy_QueryParameter) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(v))
    }

    // Mutable pointer to the field.
    pub fn mut_query_parameter(&mut self) -> &mut RouteAction_HashPolicy_QueryParameter {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(RouteAction_HashPolicy_QueryParameter::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_query_parameter(&mut self) -> RouteAction_HashPolicy_QueryParameter {
        if self.has_query_parameter() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_QueryParameter::new()
        }
    }

    // .envoy.api.v2.route.RouteAction.HashPolicy.FilterState filter_state = 6;


    pub fn get_filter_state(&self) -> &RouteAction_HashPolicy_FilterState {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v)) => v,
            _ => <RouteAction_HashPolicy_FilterState as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_filter_state(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
    }

    pub fn has_filter_state(&self) -> bool {
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_filter_state(&mut self, v: RouteAction_HashPolicy_FilterState) {
        self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(v))
    }

    // Mutable pointer to the field.
    pub fn mut_filter_state(&mut self) -> &mut RouteAction_HashPolicy_FilterState {
        if let ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(_)) = self.policy_specifier {
        } else {
            self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(RouteAction_HashPolicy_FilterState::new()));
        }
        match self.policy_specifier {
            ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_filter_state(&mut self) -> RouteAction_HashPolicy_FilterState {
        if self.has_filter_state() {
            match self.policy_specifier.take() {
                ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(v)) => v,
                _ => panic!(),
            }
        } else {
            RouteAction_HashPolicy_FilterState::new()
        }
    }

    // bool terminal = 4;


    pub fn get_terminal(&self) -> bool {
        self.terminal
    }
    pub fn clear_terminal(&mut self) {
        self.terminal = false;
    }

    // Param is passed by value, moved
    pub fn set_terminal(&mut self, v: bool) {
        self.terminal = v;
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy {
    fn is_initialized(&self) -> bool {
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::header(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v)) = self.policy_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::header(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::cookie(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy_specifier = ::std::option::Option::Some(RouteAction_HashPolicy_oneof_policy_specifier::filter_state(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.terminal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.terminal != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.policy_specifier {
            match v {
                &RouteAction_HashPolicy_oneof_policy_specifier::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.terminal != false {
            os.write_bool(4, self.terminal)?;
        }
        if let ::std::option::Option::Some(ref v) = self.policy_specifier {
            match v {
                &RouteAction_HashPolicy_oneof_policy_specifier::header(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::cookie(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::connection_properties(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::query_parameter(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RouteAction_HashPolicy_oneof_policy_specifier::filter_state(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy {
        RouteAction_HashPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_Header>(
                "header",
                RouteAction_HashPolicy::has_header,
                RouteAction_HashPolicy::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_Cookie>(
                "cookie",
                RouteAction_HashPolicy::has_cookie,
                RouteAction_HashPolicy::get_cookie,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_ConnectionProperties>(
                "connection_properties",
                RouteAction_HashPolicy::has_connection_properties,
                RouteAction_HashPolicy::get_connection_properties,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_QueryParameter>(
                "query_parameter",
                RouteAction_HashPolicy::has_query_parameter,
                RouteAction_HashPolicy::get_query_parameter,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RouteAction_HashPolicy_FilterState>(
                "filter_state",
                RouteAction_HashPolicy::has_filter_state,
                RouteAction_HashPolicy::get_filter_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "terminal",
                |m: &RouteAction_HashPolicy| { &m.terminal },
                |m: &mut RouteAction_HashPolicy| { &mut m.terminal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy>(
                "RouteAction.HashPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy {
    fn clear(&mut self) {
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.policy_specifier = ::std::option::Option::None;
        self.terminal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_HashPolicy_Header {
    // message fields
    pub header_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_Header {
    fn default() -> &'a RouteAction_HashPolicy_Header {
        <RouteAction_HashPolicy_Header as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_Header {
    pub fn new() -> RouteAction_HashPolicy_Header {
        ::std::default::Default::default()
    }

    // string header_name = 1;


    pub fn get_header_name(&self) -> &str {
        &self.header_name
    }
    pub fn clear_header_name(&mut self) {
        self.header_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_name(&mut self, v: ::std::string::String) {
        self.header_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_name(&mut self) -> &mut ::std::string::String {
        &mut self.header_name
    }

    // Take field
    pub fn take_header_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.header_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_Header {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.header_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.header_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.header_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.header_name.is_empty() {
            os.write_string(1, &self.header_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_Header {
        RouteAction_HashPolicy_Header::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header_name",
                |m: &RouteAction_HashPolicy_Header| { &m.header_name },
                |m: &mut RouteAction_HashPolicy_Header| { &mut m.header_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_Header>(
                "RouteAction.HashPolicy.Header",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_Header {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_Header> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_Header::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_Header {
    fn clear(&mut self) {
        self.header_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_Header {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_HashPolicy_Cookie {
    // message fields
    pub name: ::std::string::String,
    pub ttl: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub path: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_Cookie {
    fn default() -> &'a RouteAction_HashPolicy_Cookie {
        <RouteAction_HashPolicy_Cookie as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_Cookie {
    pub fn new() -> RouteAction_HashPolicy_Cookie {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Duration ttl = 2;


    pub fn get_ttl(&self) -> &::protobuf::well_known_types::Duration {
        self.ttl.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ttl(&mut self) {
        self.ttl.clear();
    }

    pub fn has_ttl(&self) -> bool {
        self.ttl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ttl(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.ttl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ttl(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.ttl.is_none() {
            self.ttl.set_default();
        }
        self.ttl.as_mut().unwrap()
    }

    // Take field
    pub fn take_ttl(&mut self) -> ::protobuf::well_known_types::Duration {
        self.ttl.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // string path = 3;


    pub fn get_path(&self) -> &str {
        &self.path
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        &mut self.path
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.path, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_Cookie {
    fn is_initialized(&self) -> bool {
        for v in &self.ttl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ttl)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.ttl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.path);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.ttl.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.path.is_empty() {
            os.write_string(3, &self.path)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_Cookie {
        RouteAction_HashPolicy_Cookie::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RouteAction_HashPolicy_Cookie| { &m.name },
                |m: &mut RouteAction_HashPolicy_Cookie| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "ttl",
                |m: &RouteAction_HashPolicy_Cookie| { &m.ttl },
                |m: &mut RouteAction_HashPolicy_Cookie| { &mut m.ttl },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &RouteAction_HashPolicy_Cookie| { &m.path },
                |m: &mut RouteAction_HashPolicy_Cookie| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_Cookie>(
                "RouteAction.HashPolicy.Cookie",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_Cookie {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_Cookie> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_Cookie::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_Cookie {
    fn clear(&mut self) {
        self.name.clear();
        self.ttl.clear();
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_Cookie {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_Cookie {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_HashPolicy_ConnectionProperties {
    // message fields
    pub source_ip: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_ConnectionProperties {
    fn default() -> &'a RouteAction_HashPolicy_ConnectionProperties {
        <RouteAction_HashPolicy_ConnectionProperties as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_ConnectionProperties {
    pub fn new() -> RouteAction_HashPolicy_ConnectionProperties {
        ::std::default::Default::default()
    }

    // bool source_ip = 1;


    pub fn get_source_ip(&self) -> bool {
        self.source_ip
    }
    pub fn clear_source_ip(&mut self) {
        self.source_ip = false;
    }

    // Param is passed by value, moved
    pub fn set_source_ip(&mut self, v: bool) {
        self.source_ip = v;
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_ConnectionProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.source_ip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.source_ip != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.source_ip != false {
            os.write_bool(1, self.source_ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_ConnectionProperties {
        RouteAction_HashPolicy_ConnectionProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "source_ip",
                |m: &RouteAction_HashPolicy_ConnectionProperties| { &m.source_ip },
                |m: &mut RouteAction_HashPolicy_ConnectionProperties| { &mut m.source_ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_ConnectionProperties>(
                "RouteAction.HashPolicy.ConnectionProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_ConnectionProperties {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_ConnectionProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_ConnectionProperties::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_ConnectionProperties {
    fn clear(&mut self) {
        self.source_ip = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_ConnectionProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_ConnectionProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_HashPolicy_QueryParameter {
    // message fields
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_QueryParameter {
    fn default() -> &'a RouteAction_HashPolicy_QueryParameter {
        <RouteAction_HashPolicy_QueryParameter as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_QueryParameter {
    pub fn new() -> RouteAction_HashPolicy_QueryParameter {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_QueryParameter {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_QueryParameter {
        RouteAction_HashPolicy_QueryParameter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RouteAction_HashPolicy_QueryParameter| { &m.name },
                |m: &mut RouteAction_HashPolicy_QueryParameter| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_QueryParameter>(
                "RouteAction.HashPolicy.QueryParameter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_QueryParameter {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_QueryParameter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_QueryParameter::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_QueryParameter {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_QueryParameter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_QueryParameter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_HashPolicy_FilterState {
    // message fields
    pub key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_HashPolicy_FilterState {
    fn default() -> &'a RouteAction_HashPolicy_FilterState {
        <RouteAction_HashPolicy_FilterState as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_HashPolicy_FilterState {
    pub fn new() -> RouteAction_HashPolicy_FilterState {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteAction_HashPolicy_FilterState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_HashPolicy_FilterState {
        RouteAction_HashPolicy_FilterState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &RouteAction_HashPolicy_FilterState| { &m.key },
                |m: &mut RouteAction_HashPolicy_FilterState| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_HashPolicy_FilterState>(
                "RouteAction.HashPolicy.FilterState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_HashPolicy_FilterState {
        static instance: ::protobuf::rt::LazyV2<RouteAction_HashPolicy_FilterState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_HashPolicy_FilterState::new)
    }
}

impl ::protobuf::Clear for RouteAction_HashPolicy_FilterState {
    fn clear(&mut self) {
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_HashPolicy_FilterState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_HashPolicy_FilterState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteAction_UpgradeConfig {
    // message fields
    pub upgrade_type: ::std::string::String,
    pub enabled: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteAction_UpgradeConfig {
    fn default() -> &'a RouteAction_UpgradeConfig {
        <RouteAction_UpgradeConfig as ::protobuf::Message>::default_instance()
    }
}

impl RouteAction_UpgradeConfig {
    pub fn new() -> RouteAction_UpgradeConfig {
        ::std::default::Default::default()
    }

    // string upgrade_type = 1;


    pub fn get_upgrade_type(&self) -> &str {
        &self.upgrade_type
    }
    pub fn clear_upgrade_type(&mut self) {
        self.upgrade_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_upgrade_type(&mut self, v: ::std::string::String) {
        self.upgrade_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upgrade_type(&mut self) -> &mut ::std::string::String {
        &mut self.upgrade_type
    }

    // Take field
    pub fn take_upgrade_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.upgrade_type, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue enabled = 2;


    pub fn get_enabled(&self) -> &::protobuf::well_known_types::BoolValue {
        self.enabled.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_enabled(&mut self) {
        self.enabled.clear();
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.enabled = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_enabled(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.enabled.is_none() {
            self.enabled.set_default();
        }
        self.enabled.as_mut().unwrap()
    }

    // Take field
    pub fn take_enabled(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.enabled.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for RouteAction_UpgradeConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.enabled {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.upgrade_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.enabled)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.upgrade_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.upgrade_type);
        }
        if let Some(ref v) = self.enabled.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.upgrade_type.is_empty() {
            os.write_string(1, &self.upgrade_type)?;
        }
        if let Some(ref v) = self.enabled.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteAction_UpgradeConfig {
        RouteAction_UpgradeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "upgrade_type",
                |m: &RouteAction_UpgradeConfig| { &m.upgrade_type },
                |m: &mut RouteAction_UpgradeConfig| { &mut m.upgrade_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "enabled",
                |m: &RouteAction_UpgradeConfig| { &m.enabled },
                |m: &mut RouteAction_UpgradeConfig| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteAction_UpgradeConfig>(
                "RouteAction.UpgradeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteAction_UpgradeConfig {
        static instance: ::protobuf::rt::LazyV2<RouteAction_UpgradeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteAction_UpgradeConfig::new)
    }
}

impl ::protobuf::Clear for RouteAction_UpgradeConfig {
    fn clear(&mut self) {
        self.upgrade_type.clear();
        self.enabled.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteAction_UpgradeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_UpgradeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RouteAction_ClusterNotFoundResponseCode {
    SERVICE_UNAVAILABLE = 0,
    NOT_FOUND = 1,
}

impl ::protobuf::ProtobufEnum for RouteAction_ClusterNotFoundResponseCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RouteAction_ClusterNotFoundResponseCode> {
        match value {
            0 => ::std::option::Option::Some(RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE),
            1 => ::std::option::Option::Some(RouteAction_ClusterNotFoundResponseCode::NOT_FOUND),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RouteAction_ClusterNotFoundResponseCode] = &[
            RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE,
            RouteAction_ClusterNotFoundResponseCode::NOT_FOUND,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RouteAction_ClusterNotFoundResponseCode>("RouteAction.ClusterNotFoundResponseCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RouteAction_ClusterNotFoundResponseCode {
}

impl ::std::default::Default for RouteAction_ClusterNotFoundResponseCode {
    fn default() -> Self {
        RouteAction_ClusterNotFoundResponseCode::SERVICE_UNAVAILABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_ClusterNotFoundResponseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RouteAction_InternalRedirectAction {
    PASS_THROUGH_INTERNAL_REDIRECT = 0,
    HANDLE_INTERNAL_REDIRECT = 1,
}

impl ::protobuf::ProtobufEnum for RouteAction_InternalRedirectAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RouteAction_InternalRedirectAction> {
        match value {
            0 => ::std::option::Option::Some(RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT),
            1 => ::std::option::Option::Some(RouteAction_InternalRedirectAction::HANDLE_INTERNAL_REDIRECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RouteAction_InternalRedirectAction] = &[
            RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT,
            RouteAction_InternalRedirectAction::HANDLE_INTERNAL_REDIRECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RouteAction_InternalRedirectAction>("RouteAction.InternalRedirectAction", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RouteAction_InternalRedirectAction {
}

impl ::std::default::Default for RouteAction_InternalRedirectAction {
    fn default() -> Self {
        RouteAction_InternalRedirectAction::PASS_THROUGH_INTERNAL_REDIRECT
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteAction_InternalRedirectAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryPolicy {
    // message fields
    pub retry_on: ::std::string::String,
    pub num_retries: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub per_try_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub retry_priority: ::protobuf::SingularPtrField<RetryPolicy_RetryPriority>,
    pub retry_host_predicate: ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate>,
    pub host_selection_retry_max_attempts: i64,
    pub retriable_status_codes: ::std::vec::Vec<u32>,
    pub retry_back_off: ::protobuf::SingularPtrField<RetryPolicy_RetryBackOff>,
    pub retriable_headers: ::protobuf::RepeatedField<HeaderMatcher>,
    pub retriable_request_headers: ::protobuf::RepeatedField<HeaderMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy {
    fn default() -> &'a RetryPolicy {
        <RetryPolicy as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy {
    pub fn new() -> RetryPolicy {
        ::std::default::Default::default()
    }

    // string retry_on = 1;


    pub fn get_retry_on(&self) -> &str {
        &self.retry_on
    }
    pub fn clear_retry_on(&mut self) {
        self.retry_on.clear();
    }

    // Param is passed by value, moved
    pub fn set_retry_on(&mut self, v: ::std::string::String) {
        self.retry_on = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_on(&mut self) -> &mut ::std::string::String {
        &mut self.retry_on
    }

    // Take field
    pub fn take_retry_on(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.retry_on, ::std::string::String::new())
    }

    // .google.protobuf.UInt32Value num_retries = 2;


    pub fn get_num_retries(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.num_retries.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_num_retries(&mut self) {
        self.num_retries.clear();
    }

    pub fn has_num_retries(&self) -> bool {
        self.num_retries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_retries(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.num_retries = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_num_retries(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.num_retries.is_none() {
            self.num_retries.set_default();
        }
        self.num_retries.as_mut().unwrap()
    }

    // Take field
    pub fn take_num_retries(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.num_retries.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .google.protobuf.Duration per_try_timeout = 3;


    pub fn get_per_try_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.per_try_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_per_try_timeout(&mut self) {
        self.per_try_timeout.clear();
    }

    pub fn has_per_try_timeout(&self) -> bool {
        self.per_try_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_per_try_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.per_try_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_per_try_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.per_try_timeout.is_none() {
            self.per_try_timeout.set_default();
        }
        self.per_try_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_per_try_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.per_try_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.api.v2.route.RetryPolicy.RetryPriority retry_priority = 4;


    pub fn get_retry_priority(&self) -> &RetryPolicy_RetryPriority {
        self.retry_priority.as_ref().unwrap_or_else(|| <RetryPolicy_RetryPriority as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_priority(&mut self) {
        self.retry_priority.clear();
    }

    pub fn has_retry_priority(&self) -> bool {
        self.retry_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_priority(&mut self, v: RetryPolicy_RetryPriority) {
        self.retry_priority = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_priority(&mut self) -> &mut RetryPolicy_RetryPriority {
        if self.retry_priority.is_none() {
            self.retry_priority.set_default();
        }
        self.retry_priority.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_priority(&mut self) -> RetryPolicy_RetryPriority {
        self.retry_priority.take().unwrap_or_else(|| RetryPolicy_RetryPriority::new())
    }

    // repeated .envoy.api.v2.route.RetryPolicy.RetryHostPredicate retry_host_predicate = 5;


    pub fn get_retry_host_predicate(&self) -> &[RetryPolicy_RetryHostPredicate] {
        &self.retry_host_predicate
    }
    pub fn clear_retry_host_predicate(&mut self) {
        self.retry_host_predicate.clear();
    }

    // Param is passed by value, moved
    pub fn set_retry_host_predicate(&mut self, v: ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate>) {
        self.retry_host_predicate = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retry_host_predicate(&mut self) -> &mut ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate> {
        &mut self.retry_host_predicate
    }

    // Take field
    pub fn take_retry_host_predicate(&mut self) -> ::protobuf::RepeatedField<RetryPolicy_RetryHostPredicate> {
        ::std::mem::replace(&mut self.retry_host_predicate, ::protobuf::RepeatedField::new())
    }

    // int64 host_selection_retry_max_attempts = 6;


    pub fn get_host_selection_retry_max_attempts(&self) -> i64 {
        self.host_selection_retry_max_attempts
    }
    pub fn clear_host_selection_retry_max_attempts(&mut self) {
        self.host_selection_retry_max_attempts = 0;
    }

    // Param is passed by value, moved
    pub fn set_host_selection_retry_max_attempts(&mut self, v: i64) {
        self.host_selection_retry_max_attempts = v;
    }

    // repeated uint32 retriable_status_codes = 7;


    pub fn get_retriable_status_codes(&self) -> &[u32] {
        &self.retriable_status_codes
    }
    pub fn clear_retriable_status_codes(&mut self) {
        self.retriable_status_codes.clear();
    }

    // Param is passed by value, moved
    pub fn set_retriable_status_codes(&mut self, v: ::std::vec::Vec<u32>) {
        self.retriable_status_codes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retriable_status_codes(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.retriable_status_codes
    }

    // Take field
    pub fn take_retriable_status_codes(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.retriable_status_codes, ::std::vec::Vec::new())
    }

    // .envoy.api.v2.route.RetryPolicy.RetryBackOff retry_back_off = 8;


    pub fn get_retry_back_off(&self) -> &RetryPolicy_RetryBackOff {
        self.retry_back_off.as_ref().unwrap_or_else(|| <RetryPolicy_RetryBackOff as ::protobuf::Message>::default_instance())
    }
    pub fn clear_retry_back_off(&mut self) {
        self.retry_back_off.clear();
    }

    pub fn has_retry_back_off(&self) -> bool {
        self.retry_back_off.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_back_off(&mut self, v: RetryPolicy_RetryBackOff) {
        self.retry_back_off = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_retry_back_off(&mut self) -> &mut RetryPolicy_RetryBackOff {
        if self.retry_back_off.is_none() {
            self.retry_back_off.set_default();
        }
        self.retry_back_off.as_mut().unwrap()
    }

    // Take field
    pub fn take_retry_back_off(&mut self) -> RetryPolicy_RetryBackOff {
        self.retry_back_off.take().unwrap_or_else(|| RetryPolicy_RetryBackOff::new())
    }

    // repeated .envoy.api.v2.route.HeaderMatcher retriable_headers = 9;


    pub fn get_retriable_headers(&self) -> &[HeaderMatcher] {
        &self.retriable_headers
    }
    pub fn clear_retriable_headers(&mut self) {
        self.retriable_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_retriable_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.retriable_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retriable_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.retriable_headers
    }

    // Take field
    pub fn take_retriable_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.retriable_headers, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.route.HeaderMatcher retriable_request_headers = 10;


    pub fn get_retriable_request_headers(&self) -> &[HeaderMatcher] {
        &self.retriable_request_headers
    }
    pub fn clear_retriable_request_headers(&mut self) {
        self.retriable_request_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_retriable_request_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.retriable_request_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_retriable_request_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.retriable_request_headers
    }

    // Take field
    pub fn take_retriable_request_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.retriable_request_headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RetryPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.num_retries {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.per_try_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_priority {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_host_predicate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retry_back_off {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retriable_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.retriable_request_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.retry_on)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.num_retries)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.per_try_timeout)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_priority)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retry_host_predicate)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.host_selection_retry_max_attempts = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.retriable_status_codes)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.retry_back_off)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retriable_headers)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.retriable_request_headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.retry_on.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.retry_on);
        }
        if let Some(ref v) = self.num_retries.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.per_try_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.retry_priority.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.retry_host_predicate {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.host_selection_retry_max_attempts != 0 {
            my_size += ::protobuf::rt::value_size(6, self.host_selection_retry_max_attempts, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.retriable_status_codes {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.retry_back_off.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.retriable_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.retriable_request_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.retry_on.is_empty() {
            os.write_string(1, &self.retry_on)?;
        }
        if let Some(ref v) = self.num_retries.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.per_try_timeout.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.retry_priority.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.retry_host_predicate {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.host_selection_retry_max_attempts != 0 {
            os.write_int64(6, self.host_selection_retry_max_attempts)?;
        }
        for v in &self.retriable_status_codes {
            os.write_uint32(7, *v)?;
        };
        if let Some(ref v) = self.retry_back_off.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.retriable_headers {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.retriable_request_headers {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy {
        RetryPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "retry_on",
                |m: &RetryPolicy| { &m.retry_on },
                |m: &mut RetryPolicy| { &mut m.retry_on },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "num_retries",
                |m: &RetryPolicy| { &m.num_retries },
                |m: &mut RetryPolicy| { &mut m.num_retries },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "per_try_timeout",
                |m: &RetryPolicy| { &m.per_try_timeout },
                |m: &mut RetryPolicy| { &mut m.per_try_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RetryPriority>>(
                "retry_priority",
                |m: &RetryPolicy| { &m.retry_priority },
                |m: &mut RetryPolicy| { &mut m.retry_priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RetryHostPredicate>>(
                "retry_host_predicate",
                |m: &RetryPolicy| { &m.retry_host_predicate },
                |m: &mut RetryPolicy| { &mut m.retry_host_predicate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "host_selection_retry_max_attempts",
                |m: &RetryPolicy| { &m.host_selection_retry_max_attempts },
                |m: &mut RetryPolicy| { &mut m.host_selection_retry_max_attempts },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "retriable_status_codes",
                |m: &RetryPolicy| { &m.retriable_status_codes },
                |m: &mut RetryPolicy| { &mut m.retriable_status_codes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RetryPolicy_RetryBackOff>>(
                "retry_back_off",
                |m: &RetryPolicy| { &m.retry_back_off },
                |m: &mut RetryPolicy| { &mut m.retry_back_off },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "retriable_headers",
                |m: &RetryPolicy| { &m.retriable_headers },
                |m: &mut RetryPolicy| { &mut m.retriable_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "retriable_request_headers",
                |m: &RetryPolicy| { &m.retriable_request_headers },
                |m: &mut RetryPolicy| { &mut m.retriable_request_headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy>(
                "RetryPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy::new)
    }
}

impl ::protobuf::Clear for RetryPolicy {
    fn clear(&mut self) {
        self.retry_on.clear();
        self.num_retries.clear();
        self.per_try_timeout.clear();
        self.retry_priority.clear();
        self.retry_host_predicate.clear();
        self.host_selection_retry_max_attempts = 0;
        self.retriable_status_codes.clear();
        self.retry_back_off.clear();
        self.retriable_headers.clear();
        self.retriable_request_headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryPolicy_RetryPriority {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub config_type: ::std::option::Option<RetryPolicy_RetryPriority_oneof_config_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RetryPriority {
    fn default() -> &'a RetryPolicy_RetryPriority {
        <RetryPolicy_RetryPriority as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RetryPolicy_RetryPriority_oneof_config_type {
    config(::protobuf::well_known_types::Struct),
    typed_config(::protobuf::well_known_types::Any),
}

impl RetryPolicy_RetryPriority {
    pub fn new() -> RetryPolicy_RetryPriority {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct config = 2;


    pub fn get_config(&self) -> &::protobuf::well_known_types::Struct {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(ref v)) => v,
            _ => <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if let ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(::protobuf::well_known_types::Struct::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> ::protobuf::well_known_types::Struct {
        if self.has_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Struct::new()
        }
    }

    // .google.protobuf.Any typed_config = 3;


    pub fn get_typed_config(&self) -> &::protobuf::well_known_types::Any {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_typed_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_typed_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(::protobuf::well_known_types::Any::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_typed_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for RetryPolicy_RetryPriority {
    fn is_initialized(&self) -> bool {
        if let Some(RetryPolicy_RetryPriority_oneof_config_type::config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::config(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(RetryPolicy_RetryPriority_oneof_config_type::typed_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryPriority_oneof_config_type::config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryPriority_oneof_config_type::config(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RetryPolicy_RetryPriority_oneof_config_type::typed_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RetryPriority {
        RetryPolicy_RetryPriority::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RetryPolicy_RetryPriority| { &m.name },
                |m: &mut RetryPolicy_RetryPriority| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Struct>(
                "config",
                RetryPolicy_RetryPriority::has_config,
                RetryPolicy_RetryPriority::get_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "typed_config",
                RetryPolicy_RetryPriority::has_typed_config,
                RetryPolicy_RetryPriority::get_typed_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RetryPriority>(
                "RetryPolicy.RetryPriority",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RetryPriority {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RetryPriority> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RetryPriority::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RetryPriority {
    fn clear(&mut self) {
        self.name.clear();
        self.config_type = ::std::option::Option::None;
        self.config_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RetryPriority {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RetryPriority {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryPolicy_RetryHostPredicate {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub config_type: ::std::option::Option<RetryPolicy_RetryHostPredicate_oneof_config_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RetryHostPredicate {
    fn default() -> &'a RetryPolicy_RetryHostPredicate {
        <RetryPolicy_RetryHostPredicate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RetryPolicy_RetryHostPredicate_oneof_config_type {
    config(::protobuf::well_known_types::Struct),
    typed_config(::protobuf::well_known_types::Any),
}

impl RetryPolicy_RetryHostPredicate {
    pub fn new() -> RetryPolicy_RetryHostPredicate {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct config = 2;


    pub fn get_config(&self) -> &::protobuf::well_known_types::Struct {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(ref v)) => v,
            _ => <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_config(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if let ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(::protobuf::well_known_types::Struct::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_config(&mut self) -> ::protobuf::well_known_types::Struct {
        if self.has_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Struct::new()
        }
    }

    // .google.protobuf.Any typed_config = 3;


    pub fn get_typed_config(&self) -> &::protobuf::well_known_types::Any {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v)) => v,
            _ => <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_typed_config(&mut self) {
        self.config_type = ::std::option::Option::None;
    }

    pub fn has_typed_config(&self) -> bool {
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_typed_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(v))
    }

    // Mutable pointer to the field.
    pub fn mut_typed_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if let ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(_)) = self.config_type {
        } else {
            self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(::protobuf::well_known_types::Any::new()));
        }
        match self.config_type {
            ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_typed_config(&mut self) -> ::protobuf::well_known_types::Any {
        if self.has_typed_config() {
            match self.config_type.take() {
                ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Any::new()
        }
    }
}

impl ::protobuf::Message for RetryPolicy_RetryHostPredicate {
    fn is_initialized(&self) -> bool {
        if let Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v)) = self.config_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::config(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.config_type = ::std::option::Option::Some(RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryHostPredicate_oneof_config_type::config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.config_type {
            match v {
                &RetryPolicy_RetryHostPredicate_oneof_config_type::config(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RetryPolicy_RetryHostPredicate_oneof_config_type::typed_config(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RetryHostPredicate {
        RetryPolicy_RetryHostPredicate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RetryPolicy_RetryHostPredicate| { &m.name },
                |m: &mut RetryPolicy_RetryHostPredicate| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Struct>(
                "config",
                RetryPolicy_RetryHostPredicate::has_config,
                RetryPolicy_RetryHostPredicate::get_config,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Any>(
                "typed_config",
                RetryPolicy_RetryHostPredicate::has_typed_config,
                RetryPolicy_RetryHostPredicate::get_typed_config,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RetryHostPredicate>(
                "RetryPolicy.RetryHostPredicate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RetryHostPredicate {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RetryHostPredicate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RetryHostPredicate::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RetryHostPredicate {
    fn clear(&mut self) {
        self.name.clear();
        self.config_type = ::std::option::Option::None;
        self.config_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RetryHostPredicate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RetryHostPredicate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RetryPolicy_RetryBackOff {
    // message fields
    pub base_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub max_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RetryPolicy_RetryBackOff {
    fn default() -> &'a RetryPolicy_RetryBackOff {
        <RetryPolicy_RetryBackOff as ::protobuf::Message>::default_instance()
    }
}

impl RetryPolicy_RetryBackOff {
    pub fn new() -> RetryPolicy_RetryBackOff {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration base_interval = 1;


    pub fn get_base_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.base_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base_interval(&mut self) {
        self.base_interval.clear();
    }

    pub fn has_base_interval(&self) -> bool {
        self.base_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.base_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.base_interval.is_none() {
            self.base_interval.set_default();
        }
        self.base_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_base_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.base_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration max_interval = 2;


    pub fn get_max_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.max_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_interval(&mut self) {
        self.max_interval.clear();
    }

    pub fn has_max_interval(&self) -> bool {
        self.max_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.max_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.max_interval.is_none() {
            self.max_interval.set_default();
        }
        self.max_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.max_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RetryPolicy_RetryBackOff {
    fn is_initialized(&self) -> bool {
        for v in &self.base_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base_interval)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_interval)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.base_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.base_interval.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_interval.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RetryPolicy_RetryBackOff {
        RetryPolicy_RetryBackOff::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "base_interval",
                |m: &RetryPolicy_RetryBackOff| { &m.base_interval },
                |m: &mut RetryPolicy_RetryBackOff| { &mut m.base_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "max_interval",
                |m: &RetryPolicy_RetryBackOff| { &m.max_interval },
                |m: &mut RetryPolicy_RetryBackOff| { &mut m.max_interval },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RetryPolicy_RetryBackOff>(
                "RetryPolicy.RetryBackOff",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RetryPolicy_RetryBackOff {
        static instance: ::protobuf::rt::LazyV2<RetryPolicy_RetryBackOff> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RetryPolicy_RetryBackOff::new)
    }
}

impl ::protobuf::Clear for RetryPolicy_RetryBackOff {
    fn clear(&mut self) {
        self.base_interval.clear();
        self.max_interval.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RetryPolicy_RetryBackOff {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RetryPolicy_RetryBackOff {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HedgePolicy {
    // message fields
    pub initial_requests: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub additional_request_chance: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub hedge_on_per_try_timeout: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HedgePolicy {
    fn default() -> &'a HedgePolicy {
        <HedgePolicy as ::protobuf::Message>::default_instance()
    }
}

impl HedgePolicy {
    pub fn new() -> HedgePolicy {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value initial_requests = 1;


    pub fn get_initial_requests(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.initial_requests.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_initial_requests(&mut self) {
        self.initial_requests.clear();
    }

    pub fn has_initial_requests(&self) -> bool {
        self.initial_requests.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_requests(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.initial_requests = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_requests(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.initial_requests.is_none() {
            self.initial_requests.set_default();
        }
        self.initial_requests.as_mut().unwrap()
    }

    // Take field
    pub fn take_initial_requests(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.initial_requests.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // .envoy.type.FractionalPercent additional_request_chance = 2;


    pub fn get_additional_request_chance(&self) -> &super::percent::FractionalPercent {
        self.additional_request_chance.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_additional_request_chance(&mut self) {
        self.additional_request_chance.clear();
    }

    pub fn has_additional_request_chance(&self) -> bool {
        self.additional_request_chance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_request_chance(&mut self, v: super::percent::FractionalPercent) {
        self.additional_request_chance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_additional_request_chance(&mut self) -> &mut super::percent::FractionalPercent {
        if self.additional_request_chance.is_none() {
            self.additional_request_chance.set_default();
        }
        self.additional_request_chance.as_mut().unwrap()
    }

    // Take field
    pub fn take_additional_request_chance(&mut self) -> super::percent::FractionalPercent {
        self.additional_request_chance.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // bool hedge_on_per_try_timeout = 3;


    pub fn get_hedge_on_per_try_timeout(&self) -> bool {
        self.hedge_on_per_try_timeout
    }
    pub fn clear_hedge_on_per_try_timeout(&mut self) {
        self.hedge_on_per_try_timeout = false;
    }

    // Param is passed by value, moved
    pub fn set_hedge_on_per_try_timeout(&mut self, v: bool) {
        self.hedge_on_per_try_timeout = v;
    }
}

impl ::protobuf::Message for HedgePolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.initial_requests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.additional_request_chance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.initial_requests)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.additional_request_chance)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hedge_on_per_try_timeout = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.initial_requests.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.additional_request_chance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.hedge_on_per_try_timeout != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.initial_requests.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.additional_request_chance.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.hedge_on_per_try_timeout != false {
            os.write_bool(3, self.hedge_on_per_try_timeout)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HedgePolicy {
        HedgePolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "initial_requests",
                |m: &HedgePolicy| { &m.initial_requests },
                |m: &mut HedgePolicy| { &mut m.initial_requests },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "additional_request_chance",
                |m: &HedgePolicy| { &m.additional_request_chance },
                |m: &mut HedgePolicy| { &mut m.additional_request_chance },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hedge_on_per_try_timeout",
                |m: &HedgePolicy| { &m.hedge_on_per_try_timeout },
                |m: &mut HedgePolicy| { &mut m.hedge_on_per_try_timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HedgePolicy>(
                "HedgePolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HedgePolicy {
        static instance: ::protobuf::rt::LazyV2<HedgePolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HedgePolicy::new)
    }
}

impl ::protobuf::Clear for HedgePolicy {
    fn clear(&mut self) {
        self.initial_requests.clear();
        self.additional_request_chance.clear();
        self.hedge_on_per_try_timeout = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HedgePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HedgePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RedirectAction {
    // message fields
    pub host_redirect: ::std::string::String,
    pub port_redirect: u32,
    pub response_code: RedirectAction_RedirectResponseCode,
    pub strip_query: bool,
    // message oneof groups
    pub scheme_rewrite_specifier: ::std::option::Option<RedirectAction_oneof_scheme_rewrite_specifier>,
    pub path_rewrite_specifier: ::std::option::Option<RedirectAction_oneof_path_rewrite_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RedirectAction {
    fn default() -> &'a RedirectAction {
        <RedirectAction as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RedirectAction_oneof_scheme_rewrite_specifier {
    https_redirect(bool),
    scheme_redirect(::std::string::String),
}

#[derive(Clone,PartialEq,Debug)]
pub enum RedirectAction_oneof_path_rewrite_specifier {
    path_redirect(::std::string::String),
    prefix_rewrite(::std::string::String),
}

impl RedirectAction {
    pub fn new() -> RedirectAction {
        ::std::default::Default::default()
    }

    // bool https_redirect = 4;


    pub fn get_https_redirect(&self) -> bool {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v)) => v,
            _ => false,
        }
    }
    pub fn clear_https_redirect(&mut self) {
        self.scheme_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_https_redirect(&self) -> bool {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_https_redirect(&mut self, v: bool) {
        self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v))
    }

    // string scheme_redirect = 7;


    pub fn get_scheme_redirect(&self) -> &str {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_scheme_redirect(&mut self) {
        self.scheme_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_scheme_redirect(&self) -> bool {
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_scheme_redirect(&mut self, v: ::std::string::String) {
        self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_scheme_redirect(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(_)) = self.scheme_rewrite_specifier {
        } else {
            self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(::std::string::String::new()));
        }
        match self.scheme_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_scheme_redirect(&mut self) -> ::std::string::String {
        if self.has_scheme_redirect() {
            match self.scheme_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string host_redirect = 1;


    pub fn get_host_redirect(&self) -> &str {
        &self.host_redirect
    }
    pub fn clear_host_redirect(&mut self) {
        self.host_redirect.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_redirect(&mut self, v: ::std::string::String) {
        self.host_redirect = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_redirect(&mut self) -> &mut ::std::string::String {
        &mut self.host_redirect
    }

    // Take field
    pub fn take_host_redirect(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_redirect, ::std::string::String::new())
    }

    // uint32 port_redirect = 8;


    pub fn get_port_redirect(&self) -> u32 {
        self.port_redirect
    }
    pub fn clear_port_redirect(&mut self) {
        self.port_redirect = 0;
    }

    // Param is passed by value, moved
    pub fn set_port_redirect(&mut self, v: u32) {
        self.port_redirect = v;
    }

    // string path_redirect = 2;


    pub fn get_path_redirect(&self) -> &str {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_path_redirect(&mut self) {
        self.path_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_path_redirect(&self) -> bool {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_path_redirect(&mut self, v: ::std::string::String) {
        self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(v))
    }

    // Mutable pointer to the field.
    pub fn mut_path_redirect(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(_)) = self.path_rewrite_specifier {
        } else {
            self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(::std::string::String::new()));
        }
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_path_redirect(&mut self) -> ::std::string::String {
        if self.has_path_redirect() {
            match self.path_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string prefix_rewrite = 5;


    pub fn get_prefix_rewrite(&self) -> &str {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix_rewrite(&mut self) {
        self.path_rewrite_specifier = ::std::option::Option::None;
    }

    pub fn has_prefix_rewrite(&self) -> bool {
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix_rewrite(&mut self, v: ::std::string::String) {
        self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix_rewrite(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(_)) = self.path_rewrite_specifier {
        } else {
            self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(::std::string::String::new()));
        }
        match self.path_rewrite_specifier {
            ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix_rewrite(&mut self) -> ::std::string::String {
        if self.has_prefix_rewrite() {
            match self.path_rewrite_specifier.take() {
                ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.api.v2.route.RedirectAction.RedirectResponseCode response_code = 3;


    pub fn get_response_code(&self) -> RedirectAction_RedirectResponseCode {
        self.response_code
    }
    pub fn clear_response_code(&mut self) {
        self.response_code = RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY;
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: RedirectAction_RedirectResponseCode) {
        self.response_code = v;
    }

    // bool strip_query = 6;


    pub fn get_strip_query(&self) -> bool {
        self.strip_query
    }
    pub fn clear_strip_query(&mut self) {
        self.strip_query = false;
    }

    // Param is passed by value, moved
    pub fn set_strip_query(&mut self, v: bool) {
        self.strip_query = v;
    }
}

impl ::protobuf::Message for RedirectAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(is.read_bool()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.scheme_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(is.read_string()?));
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_redirect)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.port_redirect = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::path_redirect(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.path_rewrite_specifier = ::std::option::Option::Some(RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(is.read_string()?));
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.response_code, 3, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.strip_query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.host_redirect.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.host_redirect);
        }
        if self.port_redirect != 0 {
            my_size += ::protobuf::rt::value_size(8, self.port_redirect, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.response_code != RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY {
            my_size += ::protobuf::rt::enum_size(3, self.response_code);
        }
        if self.strip_query != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.scheme_rewrite_specifier {
            match v {
                &RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v) => {
                    my_size += 2;
                },
                &RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref v) => {
                    my_size += ::protobuf::rt::string_size(7, &v);
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.path_rewrite_specifier {
            match v {
                &RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref v) => {
                    my_size += ::protobuf::rt::string_size(2, &v);
                },
                &RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.host_redirect.is_empty() {
            os.write_string(1, &self.host_redirect)?;
        }
        if self.port_redirect != 0 {
            os.write_uint32(8, self.port_redirect)?;
        }
        if self.response_code != RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.response_code))?;
        }
        if self.strip_query != false {
            os.write_bool(6, self.strip_query)?;
        }
        if let ::std::option::Option::Some(ref v) = self.scheme_rewrite_specifier {
            match v {
                &RedirectAction_oneof_scheme_rewrite_specifier::https_redirect(v) => {
                    os.write_bool(4, v)?;
                },
                &RedirectAction_oneof_scheme_rewrite_specifier::scheme_redirect(ref v) => {
                    os.write_string(7, v)?;
                },
            };
        }
        if let ::std::option::Option::Some(ref v) = self.path_rewrite_specifier {
            match v {
                &RedirectAction_oneof_path_rewrite_specifier::path_redirect(ref v) => {
                    os.write_string(2, v)?;
                },
                &RedirectAction_oneof_path_rewrite_specifier::prefix_rewrite(ref v) => {
                    os.write_string(5, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RedirectAction {
        RedirectAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "https_redirect",
                RedirectAction::has_https_redirect,
                RedirectAction::get_https_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "scheme_redirect",
                RedirectAction::has_scheme_redirect,
                RedirectAction::get_scheme_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_redirect",
                |m: &RedirectAction| { &m.host_redirect },
                |m: &mut RedirectAction| { &mut m.host_redirect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "port_redirect",
                |m: &RedirectAction| { &m.port_redirect },
                |m: &mut RedirectAction| { &mut m.port_redirect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "path_redirect",
                RedirectAction::has_path_redirect,
                RedirectAction::get_path_redirect,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix_rewrite",
                RedirectAction::has_prefix_rewrite,
                RedirectAction::get_prefix_rewrite,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RedirectAction_RedirectResponseCode>>(
                "response_code",
                |m: &RedirectAction| { &m.response_code },
                |m: &mut RedirectAction| { &mut m.response_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "strip_query",
                |m: &RedirectAction| { &m.strip_query },
                |m: &mut RedirectAction| { &mut m.strip_query },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RedirectAction>(
                "RedirectAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RedirectAction {
        static instance: ::protobuf::rt::LazyV2<RedirectAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RedirectAction::new)
    }
}

impl ::protobuf::Clear for RedirectAction {
    fn clear(&mut self) {
        self.scheme_rewrite_specifier = ::std::option::Option::None;
        self.scheme_rewrite_specifier = ::std::option::Option::None;
        self.host_redirect.clear();
        self.port_redirect = 0;
        self.path_rewrite_specifier = ::std::option::Option::None;
        self.path_rewrite_specifier = ::std::option::Option::None;
        self.response_code = RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY;
        self.strip_query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RedirectAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RedirectAction_RedirectResponseCode {
    MOVED_PERMANENTLY = 0,
    FOUND = 1,
    SEE_OTHER = 2,
    TEMPORARY_REDIRECT = 3,
    PERMANENT_REDIRECT = 4,
}

impl ::protobuf::ProtobufEnum for RedirectAction_RedirectResponseCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RedirectAction_RedirectResponseCode> {
        match value {
            0 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY),
            1 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::FOUND),
            2 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::SEE_OTHER),
            3 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::TEMPORARY_REDIRECT),
            4 => ::std::option::Option::Some(RedirectAction_RedirectResponseCode::PERMANENT_REDIRECT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RedirectAction_RedirectResponseCode] = &[
            RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY,
            RedirectAction_RedirectResponseCode::FOUND,
            RedirectAction_RedirectResponseCode::SEE_OTHER,
            RedirectAction_RedirectResponseCode::TEMPORARY_REDIRECT,
            RedirectAction_RedirectResponseCode::PERMANENT_REDIRECT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RedirectAction_RedirectResponseCode>("RedirectAction.RedirectResponseCode", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RedirectAction_RedirectResponseCode {
}

impl ::std::default::Default for RedirectAction_RedirectResponseCode {
    fn default() -> Self {
        RedirectAction_RedirectResponseCode::MOVED_PERMANENTLY
    }
}

impl ::protobuf::reflect::ProtobufValue for RedirectAction_RedirectResponseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DirectResponseAction {
    // message fields
    pub status: u32,
    pub body: ::protobuf::SingularPtrField<super::base::DataSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DirectResponseAction {
    fn default() -> &'a DirectResponseAction {
        <DirectResponseAction as ::protobuf::Message>::default_instance()
    }
}

impl DirectResponseAction {
    pub fn new() -> DirectResponseAction {
        ::std::default::Default::default()
    }

    // uint32 status = 1;


    pub fn get_status(&self) -> u32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = v;
    }

    // .envoy.api.v2.core.DataSource body = 2;


    pub fn get_body(&self) -> &super::base::DataSource {
        self.body.as_ref().unwrap_or_else(|| <super::base::DataSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: super::base::DataSource) {
        self.body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut super::base::DataSource {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> super::base::DataSource {
        self.body.take().unwrap_or_else(|| super::base::DataSource::new())
    }
}

impl ::protobuf::Message for DirectResponseAction {
    fn is_initialized(&self) -> bool {
        for v in &self.body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_uint32(1, self.status)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DirectResponseAction {
        DirectResponseAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status",
                |m: &DirectResponseAction| { &m.status },
                |m: &mut DirectResponseAction| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::DataSource>>(
                "body",
                |m: &DirectResponseAction| { &m.body },
                |m: &mut DirectResponseAction| { &mut m.body },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DirectResponseAction>(
                "DirectResponseAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DirectResponseAction {
        static instance: ::protobuf::rt::LazyV2<DirectResponseAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DirectResponseAction::new)
    }
}

impl ::protobuf::Clear for DirectResponseAction {
    fn clear(&mut self) {
        self.status = 0;
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DirectResponseAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DirectResponseAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Decorator {
    // message fields
    pub operation: ::std::string::String,
    pub propagate: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Decorator {
    fn default() -> &'a Decorator {
        <Decorator as ::protobuf::Message>::default_instance()
    }
}

impl Decorator {
    pub fn new() -> Decorator {
        ::std::default::Default::default()
    }

    // string operation = 1;


    pub fn get_operation(&self) -> &str {
        &self.operation
    }
    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        &mut self.operation
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue propagate = 2;


    pub fn get_propagate(&self) -> &::protobuf::well_known_types::BoolValue {
        self.propagate.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_propagate(&mut self) {
        self.propagate.clear();
    }

    pub fn has_propagate(&self) -> bool {
        self.propagate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagate(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.propagate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagate(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.propagate.is_none() {
            self.propagate.set_default();
        }
        self.propagate.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagate(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.propagate.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }
}

impl ::protobuf::Message for Decorator {
    fn is_initialized(&self) -> bool {
        for v in &self.propagate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.propagate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.operation.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.operation);
        }
        if let Some(ref v) = self.propagate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.operation.is_empty() {
            os.write_string(1, &self.operation)?;
        }
        if let Some(ref v) = self.propagate.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Decorator {
        Decorator::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation",
                |m: &Decorator| { &m.operation },
                |m: &mut Decorator| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "propagate",
                |m: &Decorator| { &m.propagate },
                |m: &mut Decorator| { &mut m.propagate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Decorator>(
                "Decorator",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Decorator {
        static instance: ::protobuf::rt::LazyV2<Decorator> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Decorator::new)
    }
}

impl ::protobuf::Clear for Decorator {
    fn clear(&mut self) {
        self.operation.clear();
        self.propagate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Decorator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Decorator {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tracing {
    // message fields
    pub client_sampling: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub random_sampling: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub overall_sampling: ::protobuf::SingularPtrField<super::percent::FractionalPercent>,
    pub custom_tags: ::protobuf::RepeatedField<super::custom_tag::CustomTag>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tracing {
    fn default() -> &'a Tracing {
        <Tracing as ::protobuf::Message>::default_instance()
    }
}

impl Tracing {
    pub fn new() -> Tracing {
        ::std::default::Default::default()
    }

    // .envoy.type.FractionalPercent client_sampling = 1;


    pub fn get_client_sampling(&self) -> &super::percent::FractionalPercent {
        self.client_sampling.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_client_sampling(&mut self) {
        self.client_sampling.clear();
    }

    pub fn has_client_sampling(&self) -> bool {
        self.client_sampling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_sampling(&mut self, v: super::percent::FractionalPercent) {
        self.client_sampling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_sampling(&mut self) -> &mut super::percent::FractionalPercent {
        if self.client_sampling.is_none() {
            self.client_sampling.set_default();
        }
        self.client_sampling.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_sampling(&mut self) -> super::percent::FractionalPercent {
        self.client_sampling.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // .envoy.type.FractionalPercent random_sampling = 2;


    pub fn get_random_sampling(&self) -> &super::percent::FractionalPercent {
        self.random_sampling.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_random_sampling(&mut self) {
        self.random_sampling.clear();
    }

    pub fn has_random_sampling(&self) -> bool {
        self.random_sampling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_random_sampling(&mut self, v: super::percent::FractionalPercent) {
        self.random_sampling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_random_sampling(&mut self) -> &mut super::percent::FractionalPercent {
        if self.random_sampling.is_none() {
            self.random_sampling.set_default();
        }
        self.random_sampling.as_mut().unwrap()
    }

    // Take field
    pub fn take_random_sampling(&mut self) -> super::percent::FractionalPercent {
        self.random_sampling.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // .envoy.type.FractionalPercent overall_sampling = 3;


    pub fn get_overall_sampling(&self) -> &super::percent::FractionalPercent {
        self.overall_sampling.as_ref().unwrap_or_else(|| <super::percent::FractionalPercent as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overall_sampling(&mut self) {
        self.overall_sampling.clear();
    }

    pub fn has_overall_sampling(&self) -> bool {
        self.overall_sampling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overall_sampling(&mut self, v: super::percent::FractionalPercent) {
        self.overall_sampling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overall_sampling(&mut self) -> &mut super::percent::FractionalPercent {
        if self.overall_sampling.is_none() {
            self.overall_sampling.set_default();
        }
        self.overall_sampling.as_mut().unwrap()
    }

    // Take field
    pub fn take_overall_sampling(&mut self) -> super::percent::FractionalPercent {
        self.overall_sampling.take().unwrap_or_else(|| super::percent::FractionalPercent::new())
    }

    // repeated .envoy.type.tracing.v2.CustomTag custom_tags = 4;


    pub fn get_custom_tags(&self) -> &[super::custom_tag::CustomTag] {
        &self.custom_tags
    }
    pub fn clear_custom_tags(&mut self) {
        self.custom_tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_tags(&mut self, v: ::protobuf::RepeatedField<super::custom_tag::CustomTag>) {
        self.custom_tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_custom_tags(&mut self) -> &mut ::protobuf::RepeatedField<super::custom_tag::CustomTag> {
        &mut self.custom_tags
    }

    // Take field
    pub fn take_custom_tags(&mut self) -> ::protobuf::RepeatedField<super::custom_tag::CustomTag> {
        ::std::mem::replace(&mut self.custom_tags, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Tracing {
    fn is_initialized(&self) -> bool {
        for v in &self.client_sampling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.random_sampling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overall_sampling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.custom_tags {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_sampling)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.random_sampling)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overall_sampling)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.custom_tags)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.client_sampling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.random_sampling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.overall_sampling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.custom_tags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.client_sampling.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.random_sampling.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.overall_sampling.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.custom_tags {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tracing {
        Tracing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "client_sampling",
                |m: &Tracing| { &m.client_sampling },
                |m: &mut Tracing| { &mut m.client_sampling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "random_sampling",
                |m: &Tracing| { &m.random_sampling },
                |m: &mut Tracing| { &mut m.random_sampling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::percent::FractionalPercent>>(
                "overall_sampling",
                |m: &Tracing| { &m.overall_sampling },
                |m: &mut Tracing| { &mut m.overall_sampling },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::custom_tag::CustomTag>>(
                "custom_tags",
                |m: &Tracing| { &m.custom_tags },
                |m: &mut Tracing| { &mut m.custom_tags },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tracing>(
                "Tracing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tracing {
        static instance: ::protobuf::rt::LazyV2<Tracing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tracing::new)
    }
}

impl ::protobuf::Clear for Tracing {
    fn clear(&mut self) {
        self.client_sampling.clear();
        self.random_sampling.clear();
        self.overall_sampling.clear();
        self.custom_tags.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tracing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tracing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualCluster {
    // message fields
    pub pattern: ::std::string::String,
    pub headers: ::protobuf::RepeatedField<HeaderMatcher>,
    pub name: ::std::string::String,
    pub method: super::base::RequestMethod,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualCluster {
    fn default() -> &'a VirtualCluster {
        <VirtualCluster as ::protobuf::Message>::default_instance()
    }
}

impl VirtualCluster {
    pub fn new() -> VirtualCluster {
        ::std::default::Default::default()
    }

    // string pattern = 1;


    pub fn get_pattern(&self) -> &str {
        &self.pattern
    }
    pub fn clear_pattern(&mut self) {
        self.pattern.clear();
    }

    // Param is passed by value, moved
    pub fn set_pattern(&mut self, v: ::std::string::String) {
        self.pattern = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pattern(&mut self) -> &mut ::std::string::String {
        &mut self.pattern
    }

    // Take field
    pub fn take_pattern(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pattern, ::std::string::String::new())
    }

    // repeated .envoy.api.v2.route.HeaderMatcher headers = 4;


    pub fn get_headers(&self) -> &[HeaderMatcher] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.api.v2.core.RequestMethod method = 3;


    pub fn get_method(&self) -> super::base::RequestMethod {
        self.method
    }
    pub fn clear_method(&mut self) {
        self.method = super::base::RequestMethod::METHOD_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_method(&mut self, v: super::base::RequestMethod) {
        self.method = v;
    }
}

impl ::protobuf::Message for VirtualCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pattern)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.method, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.pattern.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.pattern);
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.method != super::base::RequestMethod::METHOD_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.method);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.pattern.is_empty() {
            os.write_string(1, &self.pattern)?;
        }
        for v in &self.headers {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.method != super::base::RequestMethod::METHOD_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.method))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualCluster {
        VirtualCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pattern",
                |m: &VirtualCluster| { &m.pattern },
                |m: &mut VirtualCluster| { &mut m.pattern },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "headers",
                |m: &VirtualCluster| { &m.headers },
                |m: &mut VirtualCluster| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VirtualCluster| { &m.name },
                |m: &mut VirtualCluster| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::base::RequestMethod>>(
                "method",
                |m: &VirtualCluster| { &m.method },
                |m: &mut VirtualCluster| { &mut m.method },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualCluster>(
                "VirtualCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualCluster {
        static instance: ::protobuf::rt::LazyV2<VirtualCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualCluster::new)
    }
}

impl ::protobuf::Clear for VirtualCluster {
    fn clear(&mut self) {
        self.pattern.clear();
        self.headers.clear();
        self.name.clear();
        self.method = super::base::RequestMethod::METHOD_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit {
    // message fields
    pub stage: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    pub disable_key: ::std::string::String,
    pub actions: ::protobuf::RepeatedField<RateLimit_Action>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit {
    fn default() -> &'a RateLimit {
        <RateLimit as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit {
    pub fn new() -> RateLimit {
        ::std::default::Default::default()
    }

    // .google.protobuf.UInt32Value stage = 1;


    pub fn get_stage(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.stage.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stage(&mut self) {
        self.stage.clear();
    }

    pub fn has_stage(&self) -> bool {
        self.stage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stage(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.stage = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stage(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.stage.is_none() {
            self.stage.set_default();
        }
        self.stage.as_mut().unwrap()
    }

    // Take field
    pub fn take_stage(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.stage.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }

    // string disable_key = 2;


    pub fn get_disable_key(&self) -> &str {
        &self.disable_key
    }
    pub fn clear_disable_key(&mut self) {
        self.disable_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_disable_key(&mut self, v: ::std::string::String) {
        self.disable_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disable_key(&mut self) -> &mut ::std::string::String {
        &mut self.disable_key
    }

    // Take field
    pub fn take_disable_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.disable_key, ::std::string::String::new())
    }

    // repeated .envoy.api.v2.route.RateLimit.Action actions = 3;


    pub fn get_actions(&self) -> &[RateLimit_Action] {
        &self.actions
    }
    pub fn clear_actions(&mut self) {
        self.actions.clear();
    }

    // Param is passed by value, moved
    pub fn set_actions(&mut self, v: ::protobuf::RepeatedField<RateLimit_Action>) {
        self.actions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actions(&mut self) -> &mut ::protobuf::RepeatedField<RateLimit_Action> {
        &mut self.actions
    }

    // Take field
    pub fn take_actions(&mut self) -> ::protobuf::RepeatedField<RateLimit_Action> {
        ::std::mem::replace(&mut self.actions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RateLimit {
    fn is_initialized(&self) -> bool {
        for v in &self.stage {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stage)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.disable_key)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.actions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stage.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.disable_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.disable_key);
        }
        for value in &self.actions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stage.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.disable_key.is_empty() {
            os.write_string(2, &self.disable_key)?;
        }
        for v in &self.actions {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit {
        RateLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "stage",
                |m: &RateLimit| { &m.stage },
                |m: &mut RateLimit| { &mut m.stage },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disable_key",
                |m: &RateLimit| { &m.disable_key },
                |m: &mut RateLimit| { &mut m.disable_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RateLimit_Action>>(
                "actions",
                |m: &RateLimit| { &m.actions },
                |m: &mut RateLimit| { &mut m.actions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit>(
                "RateLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit {
        static instance: ::protobuf::rt::LazyV2<RateLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit::new)
    }
}

impl ::protobuf::Clear for RateLimit {
    fn clear(&mut self) {
        self.stage.clear();
        self.disable_key.clear();
        self.actions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action {
    // message oneof groups
    pub action_specifier: ::std::option::Option<RateLimit_Action_oneof_action_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action {
    fn default() -> &'a RateLimit_Action {
        <RateLimit_Action as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RateLimit_Action_oneof_action_specifier {
    source_cluster(RateLimit_Action_SourceCluster),
    destination_cluster(RateLimit_Action_DestinationCluster),
    request_headers(RateLimit_Action_RequestHeaders),
    remote_address(RateLimit_Action_RemoteAddress),
    generic_key(RateLimit_Action_GenericKey),
    header_value_match(RateLimit_Action_HeaderValueMatch),
}

impl RateLimit_Action {
    pub fn new() -> RateLimit_Action {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.route.RateLimit.Action.SourceCluster source_cluster = 1;


    pub fn get_source_cluster(&self) -> &RateLimit_Action_SourceCluster {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(ref v)) => v,
            _ => <RateLimit_Action_SourceCluster as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_source_cluster(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_source_cluster(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_source_cluster(&mut self, v: RateLimit_Action_SourceCluster) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_source_cluster(&mut self) -> &mut RateLimit_Action_SourceCluster {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(RateLimit_Action_SourceCluster::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_source_cluster(&mut self) -> RateLimit_Action_SourceCluster {
        if self.has_source_cluster() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_SourceCluster::new()
        }
    }

    // .envoy.api.v2.route.RateLimit.Action.DestinationCluster destination_cluster = 2;


    pub fn get_destination_cluster(&self) -> &RateLimit_Action_DestinationCluster {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(ref v)) => v,
            _ => <RateLimit_Action_DestinationCluster as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_destination_cluster(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_destination_cluster(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination_cluster(&mut self, v: RateLimit_Action_DestinationCluster) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destination_cluster(&mut self) -> &mut RateLimit_Action_DestinationCluster {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(RateLimit_Action_DestinationCluster::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destination_cluster(&mut self) -> RateLimit_Action_DestinationCluster {
        if self.has_destination_cluster() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_DestinationCluster::new()
        }
    }

    // .envoy.api.v2.route.RateLimit.Action.RequestHeaders request_headers = 3;


    pub fn get_request_headers(&self) -> &RateLimit_Action_RequestHeaders {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(ref v)) => v,
            _ => <RateLimit_Action_RequestHeaders as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_headers(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_request_headers(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_headers(&mut self, v: RateLimit_Action_RequestHeaders) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers(&mut self) -> &mut RateLimit_Action_RequestHeaders {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(RateLimit_Action_RequestHeaders::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_headers(&mut self) -> RateLimit_Action_RequestHeaders {
        if self.has_request_headers() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_RequestHeaders::new()
        }
    }

    // .envoy.api.v2.route.RateLimit.Action.RemoteAddress remote_address = 4;


    pub fn get_remote_address(&self) -> &RateLimit_Action_RemoteAddress {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(ref v)) => v,
            _ => <RateLimit_Action_RemoteAddress as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote_address(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_remote_address(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote_address(&mut self, v: RateLimit_Action_RemoteAddress) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote_address(&mut self) -> &mut RateLimit_Action_RemoteAddress {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(RateLimit_Action_RemoteAddress::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote_address(&mut self) -> RateLimit_Action_RemoteAddress {
        if self.has_remote_address() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_RemoteAddress::new()
        }
    }

    // .envoy.api.v2.route.RateLimit.Action.GenericKey generic_key = 5;


    pub fn get_generic_key(&self) -> &RateLimit_Action_GenericKey {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(ref v)) => v,
            _ => <RateLimit_Action_GenericKey as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_generic_key(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_generic_key(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_generic_key(&mut self, v: RateLimit_Action_GenericKey) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(v))
    }

    // Mutable pointer to the field.
    pub fn mut_generic_key(&mut self) -> &mut RateLimit_Action_GenericKey {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(RateLimit_Action_GenericKey::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_generic_key(&mut self) -> RateLimit_Action_GenericKey {
        if self.has_generic_key() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_GenericKey::new()
        }
    }

    // .envoy.api.v2.route.RateLimit.Action.HeaderValueMatch header_value_match = 6;


    pub fn get_header_value_match(&self) -> &RateLimit_Action_HeaderValueMatch {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(ref v)) => v,
            _ => <RateLimit_Action_HeaderValueMatch as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header_value_match(&mut self) {
        self.action_specifier = ::std::option::Option::None;
    }

    pub fn has_header_value_match(&self) -> bool {
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header_value_match(&mut self, v: RateLimit_Action_HeaderValueMatch) {
        self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header_value_match(&mut self) -> &mut RateLimit_Action_HeaderValueMatch {
        if let ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(_)) = self.action_specifier {
        } else {
            self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(RateLimit_Action_HeaderValueMatch::new()));
        }
        match self.action_specifier {
            ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header_value_match(&mut self) -> RateLimit_Action_HeaderValueMatch {
        if self.has_header_value_match() {
            match self.action_specifier.take() {
                ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(v)) => v,
                _ => panic!(),
            }
        } else {
            RateLimit_Action_HeaderValueMatch::new()
        }
    }
}

impl ::protobuf::Message for RateLimit_Action {
    fn is_initialized(&self) -> bool {
        if let Some(RateLimit_Action_oneof_action_specifier::source_cluster(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::destination_cluster(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::request_headers(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::remote_address(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::generic_key(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RateLimit_Action_oneof_action_specifier::header_value_match(ref v)) = self.action_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::source_cluster(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::destination_cluster(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::request_headers(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::remote_address(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::generic_key(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.action_specifier = ::std::option::Option::Some(RateLimit_Action_oneof_action_specifier::header_value_match(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.action_specifier {
            match v {
                &RateLimit_Action_oneof_action_specifier::source_cluster(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::destination_cluster(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::request_headers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::remote_address(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::generic_key(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RateLimit_Action_oneof_action_specifier::header_value_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.action_specifier {
            match v {
                &RateLimit_Action_oneof_action_specifier::source_cluster(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::destination_cluster(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::request_headers(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::remote_address(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::generic_key(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RateLimit_Action_oneof_action_specifier::header_value_match(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action {
        RateLimit_Action::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_SourceCluster>(
                "source_cluster",
                RateLimit_Action::has_source_cluster,
                RateLimit_Action::get_source_cluster,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_DestinationCluster>(
                "destination_cluster",
                RateLimit_Action::has_destination_cluster,
                RateLimit_Action::get_destination_cluster,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_RequestHeaders>(
                "request_headers",
                RateLimit_Action::has_request_headers,
                RateLimit_Action::get_request_headers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_RemoteAddress>(
                "remote_address",
                RateLimit_Action::has_remote_address,
                RateLimit_Action::get_remote_address,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_GenericKey>(
                "generic_key",
                RateLimit_Action::has_generic_key,
                RateLimit_Action::get_generic_key,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RateLimit_Action_HeaderValueMatch>(
                "header_value_match",
                RateLimit_Action::has_header_value_match,
                RateLimit_Action::get_header_value_match,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action>(
                "RateLimit.Action",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action {
    fn clear(&mut self) {
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.action_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action_SourceCluster {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_SourceCluster {
    fn default() -> &'a RateLimit_Action_SourceCluster {
        <RateLimit_Action_SourceCluster as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_SourceCluster {
    pub fn new() -> RateLimit_Action_SourceCluster {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateLimit_Action_SourceCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_SourceCluster {
        RateLimit_Action_SourceCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_SourceCluster>(
                "RateLimit.Action.SourceCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_SourceCluster {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_SourceCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_SourceCluster::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_SourceCluster {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_SourceCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_SourceCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action_DestinationCluster {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_DestinationCluster {
    fn default() -> &'a RateLimit_Action_DestinationCluster {
        <RateLimit_Action_DestinationCluster as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_DestinationCluster {
    pub fn new() -> RateLimit_Action_DestinationCluster {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateLimit_Action_DestinationCluster {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_DestinationCluster {
        RateLimit_Action_DestinationCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_DestinationCluster>(
                "RateLimit.Action.DestinationCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_DestinationCluster {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_DestinationCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_DestinationCluster::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_DestinationCluster {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_DestinationCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_DestinationCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action_RequestHeaders {
    // message fields
    pub header_name: ::std::string::String,
    pub descriptor_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_RequestHeaders {
    fn default() -> &'a RateLimit_Action_RequestHeaders {
        <RateLimit_Action_RequestHeaders as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_RequestHeaders {
    pub fn new() -> RateLimit_Action_RequestHeaders {
        ::std::default::Default::default()
    }

    // string header_name = 1;


    pub fn get_header_name(&self) -> &str {
        &self.header_name
    }
    pub fn clear_header_name(&mut self) {
        self.header_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_name(&mut self, v: ::std::string::String) {
        self.header_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_name(&mut self) -> &mut ::std::string::String {
        &mut self.header_name
    }

    // Take field
    pub fn take_header_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.header_name, ::std::string::String::new())
    }

    // string descriptor_key = 2;


    pub fn get_descriptor_key(&self) -> &str {
        &self.descriptor_key
    }
    pub fn clear_descriptor_key(&mut self) {
        self.descriptor_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_key(&mut self, v: ::std::string::String) {
        self.descriptor_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_key(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_key
    }

    // Take field
    pub fn take_descriptor_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RateLimit_Action_RequestHeaders {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.header_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.header_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.header_name);
        }
        if !self.descriptor_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.descriptor_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.header_name.is_empty() {
            os.write_string(1, &self.header_name)?;
        }
        if !self.descriptor_key.is_empty() {
            os.write_string(2, &self.descriptor_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_RequestHeaders {
        RateLimit_Action_RequestHeaders::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header_name",
                |m: &RateLimit_Action_RequestHeaders| { &m.header_name },
                |m: &mut RateLimit_Action_RequestHeaders| { &mut m.header_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_key",
                |m: &RateLimit_Action_RequestHeaders| { &m.descriptor_key },
                |m: &mut RateLimit_Action_RequestHeaders| { &mut m.descriptor_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_RequestHeaders>(
                "RateLimit.Action.RequestHeaders",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_RequestHeaders {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_RequestHeaders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_RequestHeaders::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_RequestHeaders {
    fn clear(&mut self) {
        self.header_name.clear();
        self.descriptor_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_RequestHeaders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_RequestHeaders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action_RemoteAddress {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_RemoteAddress {
    fn default() -> &'a RateLimit_Action_RemoteAddress {
        <RateLimit_Action_RemoteAddress as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_RemoteAddress {
    pub fn new() -> RateLimit_Action_RemoteAddress {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RateLimit_Action_RemoteAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_RemoteAddress {
        RateLimit_Action_RemoteAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_RemoteAddress>(
                "RateLimit.Action.RemoteAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_RemoteAddress {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_RemoteAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_RemoteAddress::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_RemoteAddress {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_RemoteAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_RemoteAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action_GenericKey {
    // message fields
    pub descriptor_value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_GenericKey {
    fn default() -> &'a RateLimit_Action_GenericKey {
        <RateLimit_Action_GenericKey as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_GenericKey {
    pub fn new() -> RateLimit_Action_GenericKey {
        ::std::default::Default::default()
    }

    // string descriptor_value = 1;


    pub fn get_descriptor_value(&self) -> &str {
        &self.descriptor_value
    }
    pub fn clear_descriptor_value(&mut self) {
        self.descriptor_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_value(&mut self, v: ::std::string::String) {
        self.descriptor_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_value(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_value
    }

    // Take field
    pub fn take_descriptor_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RateLimit_Action_GenericKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.descriptor_value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.descriptor_value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.descriptor_value.is_empty() {
            os.write_string(1, &self.descriptor_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_GenericKey {
        RateLimit_Action_GenericKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_value",
                |m: &RateLimit_Action_GenericKey| { &m.descriptor_value },
                |m: &mut RateLimit_Action_GenericKey| { &mut m.descriptor_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_GenericKey>(
                "RateLimit.Action.GenericKey",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_GenericKey {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_GenericKey> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_GenericKey::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_GenericKey {
    fn clear(&mut self) {
        self.descriptor_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_GenericKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_GenericKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RateLimit_Action_HeaderValueMatch {
    // message fields
    pub descriptor_value: ::std::string::String,
    pub expect_match: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub headers: ::protobuf::RepeatedField<HeaderMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RateLimit_Action_HeaderValueMatch {
    fn default() -> &'a RateLimit_Action_HeaderValueMatch {
        <RateLimit_Action_HeaderValueMatch as ::protobuf::Message>::default_instance()
    }
}

impl RateLimit_Action_HeaderValueMatch {
    pub fn new() -> RateLimit_Action_HeaderValueMatch {
        ::std::default::Default::default()
    }

    // string descriptor_value = 1;


    pub fn get_descriptor_value(&self) -> &str {
        &self.descriptor_value
    }
    pub fn clear_descriptor_value(&mut self) {
        self.descriptor_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_descriptor_value(&mut self, v: ::std::string::String) {
        self.descriptor_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_descriptor_value(&mut self) -> &mut ::std::string::String {
        &mut self.descriptor_value
    }

    // Take field
    pub fn take_descriptor_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.descriptor_value, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue expect_match = 2;


    pub fn get_expect_match(&self) -> &::protobuf::well_known_types::BoolValue {
        self.expect_match.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_expect_match(&mut self) {
        self.expect_match.clear();
    }

    pub fn has_expect_match(&self) -> bool {
        self.expect_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expect_match(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.expect_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expect_match(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.expect_match.is_none() {
            self.expect_match.set_default();
        }
        self.expect_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_expect_match(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.expect_match.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // repeated .envoy.api.v2.route.HeaderMatcher headers = 3;


    pub fn get_headers(&self) -> &[HeaderMatcher] {
        &self.headers
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: ::protobuf::RepeatedField<HeaderMatcher>) {
        self.headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_headers(&mut self) -> &mut ::protobuf::RepeatedField<HeaderMatcher> {
        &mut self.headers
    }

    // Take field
    pub fn take_headers(&mut self) -> ::protobuf::RepeatedField<HeaderMatcher> {
        ::std::mem::replace(&mut self.headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RateLimit_Action_HeaderValueMatch {
    fn is_initialized(&self) -> bool {
        for v in &self.expect_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.descriptor_value)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.expect_match)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.descriptor_value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.descriptor_value);
        }
        if let Some(ref v) = self.expect_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.descriptor_value.is_empty() {
            os.write_string(1, &self.descriptor_value)?;
        }
        if let Some(ref v) = self.expect_match.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.headers {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RateLimit_Action_HeaderValueMatch {
        RateLimit_Action_HeaderValueMatch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "descriptor_value",
                |m: &RateLimit_Action_HeaderValueMatch| { &m.descriptor_value },
                |m: &mut RateLimit_Action_HeaderValueMatch| { &mut m.descriptor_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "expect_match",
                |m: &RateLimit_Action_HeaderValueMatch| { &m.expect_match },
                |m: &mut RateLimit_Action_HeaderValueMatch| { &mut m.expect_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMatcher>>(
                "headers",
                |m: &RateLimit_Action_HeaderValueMatch| { &m.headers },
                |m: &mut RateLimit_Action_HeaderValueMatch| { &mut m.headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RateLimit_Action_HeaderValueMatch>(
                "RateLimit.Action.HeaderValueMatch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RateLimit_Action_HeaderValueMatch {
        static instance: ::protobuf::rt::LazyV2<RateLimit_Action_HeaderValueMatch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RateLimit_Action_HeaderValueMatch::new)
    }
}

impl ::protobuf::Clear for RateLimit_Action_HeaderValueMatch {
    fn clear(&mut self) {
        self.descriptor_value.clear();
        self.expect_match.clear();
        self.headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RateLimit_Action_HeaderValueMatch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RateLimit_Action_HeaderValueMatch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeaderMatcher {
    // message fields
    pub name: ::std::string::String,
    pub invert_match: bool,
    // message oneof groups
    pub header_match_specifier: ::std::option::Option<HeaderMatcher_oneof_header_match_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderMatcher {
    fn default() -> &'a HeaderMatcher {
        <HeaderMatcher as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum HeaderMatcher_oneof_header_match_specifier {
    exact_match(::std::string::String),
    regex_match(::std::string::String),
    safe_regex_match(super::regex::RegexMatcher),
    range_match(super::range::Int64Range),
    present_match(bool),
    prefix_match(::std::string::String),
    suffix_match(::std::string::String),
}

impl HeaderMatcher {
    pub fn new() -> HeaderMatcher {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string exact_match = 4;


    pub fn get_exact_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_exact_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_exact_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_exact_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_exact_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_exact_match(&mut self) -> ::std::string::String {
        if self.has_exact_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string regex_match = 5;


    pub fn get_regex_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_regex_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_regex_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_regex_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_regex_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_regex_match(&mut self) -> ::std::string::String {
        if self.has_regex_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.type.matcher.RegexMatcher safe_regex_match = 11;


    pub fn get_safe_regex_match(&self) -> &super::regex::RegexMatcher {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v)) => v,
            _ => <super::regex::RegexMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_safe_regex_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_safe_regex_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_safe_regex_match(&mut self, v: super::regex::RegexMatcher) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_safe_regex_match(&mut self) -> &mut super::regex::RegexMatcher {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(super::regex::RegexMatcher::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_safe_regex_match(&mut self) -> super::regex::RegexMatcher {
        if self.has_safe_regex_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::regex::RegexMatcher::new()
        }
    }

    // .envoy.type.Int64Range range_match = 6;


    pub fn get_range_match(&self) -> &super::range::Int64Range {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(ref v)) => v,
            _ => <super::range::Int64Range as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_range_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_range_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_range_match(&mut self, v: super::range::Int64Range) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_range_match(&mut self) -> &mut super::range::Int64Range {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(super::range::Int64Range::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_range_match(&mut self) -> super::range::Int64Range {
        if self.has_range_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::range::Int64Range::new()
        }
    }

    // bool present_match = 7;


    pub fn get_present_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(v)) => v,
            _ => false,
        }
    }
    pub fn clear_present_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_present_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_present_match(&mut self, v: bool) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(v))
    }

    // string prefix_match = 9;


    pub fn get_prefix_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_prefix_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_prefix_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_prefix_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_prefix_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_prefix_match(&mut self) -> ::std::string::String {
        if self.has_prefix_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // string suffix_match = 10;


    pub fn get_suffix_match(&self) -> &str {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_suffix_match(&mut self) {
        self.header_match_specifier = ::std::option::Option::None;
    }

    pub fn has_suffix_match(&self) -> bool {
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_suffix_match(&mut self, v: ::std::string::String) {
        self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_suffix_match(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(_)) = self.header_match_specifier {
        } else {
            self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(::std::string::String::new()));
        }
        match self.header_match_specifier {
            ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_suffix_match(&mut self) -> ::std::string::String {
        if self.has_suffix_match() {
            match self.header_match_specifier.take() {
                ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // bool invert_match = 8;


    pub fn get_invert_match(&self) -> bool {
        self.invert_match
    }
    pub fn clear_invert_match(&mut self) {
        self.invert_match = false;
    }

    // Param is passed by value, moved
    pub fn set_invert_match(&mut self, v: bool) {
        self.invert_match = v;
    }
}

impl ::protobuf::Message for HeaderMatcher {
    fn is_initialized(&self) -> bool {
        if let Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v)) = self.header_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(HeaderMatcher_oneof_header_match_specifier::range_match(ref v)) = self.header_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::exact_match(is.read_string()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::regex_match(is.read_string()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::safe_regex_match(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::range_match(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::present_match(is.read_bool()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::prefix_match(is.read_string()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.header_match_specifier = ::std::option::Option::Some(HeaderMatcher_oneof_header_match_specifier::suffix_match(is.read_string()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.invert_match = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.invert_match != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.header_match_specifier {
            match v {
                &HeaderMatcher_oneof_header_match_specifier::exact_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(4, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::regex_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(5, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HeaderMatcher_oneof_header_match_specifier::range_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &HeaderMatcher_oneof_header_match_specifier::present_match(v) => {
                    my_size += 2;
                },
                &HeaderMatcher_oneof_header_match_specifier::prefix_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(9, &v);
                },
                &HeaderMatcher_oneof_header_match_specifier::suffix_match(ref v) => {
                    my_size += ::protobuf::rt::string_size(10, &v);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.invert_match != false {
            os.write_bool(8, self.invert_match)?;
        }
        if let ::std::option::Option::Some(ref v) = self.header_match_specifier {
            match v {
                &HeaderMatcher_oneof_header_match_specifier::exact_match(ref v) => {
                    os.write_string(4, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::regex_match(ref v) => {
                    os.write_string(5, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::safe_regex_match(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::range_match(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::present_match(v) => {
                    os.write_bool(7, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::prefix_match(ref v) => {
                    os.write_string(9, v)?;
                },
                &HeaderMatcher_oneof_header_match_specifier::suffix_match(ref v) => {
                    os.write_string(10, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderMatcher {
        HeaderMatcher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HeaderMatcher| { &m.name },
                |m: &mut HeaderMatcher| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "exact_match",
                HeaderMatcher::has_exact_match,
                HeaderMatcher::get_exact_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "regex_match",
                HeaderMatcher::has_regex_match,
                HeaderMatcher::get_regex_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::regex::RegexMatcher>(
                "safe_regex_match",
                HeaderMatcher::has_safe_regex_match,
                HeaderMatcher::get_safe_regex_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::range::Int64Range>(
                "range_match",
                HeaderMatcher::has_range_match,
                HeaderMatcher::get_range_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "present_match",
                HeaderMatcher::has_present_match,
                HeaderMatcher::get_present_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "prefix_match",
                HeaderMatcher::has_prefix_match,
                HeaderMatcher::get_prefix_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "suffix_match",
                HeaderMatcher::has_suffix_match,
                HeaderMatcher::get_suffix_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "invert_match",
                |m: &HeaderMatcher| { &m.invert_match },
                |m: &mut HeaderMatcher| { &mut m.invert_match },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderMatcher>(
                "HeaderMatcher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderMatcher {
        static instance: ::protobuf::rt::LazyV2<HeaderMatcher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderMatcher::new)
    }
}

impl ::protobuf::Clear for HeaderMatcher {
    fn clear(&mut self) {
        self.name.clear();
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.header_match_specifier = ::std::option::Option::None;
        self.invert_match = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderMatcher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueryParameterMatcher {
    // message fields
    pub name: ::std::string::String,
    pub value: ::std::string::String,
    pub regex: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    // message oneof groups
    pub query_parameter_match_specifier: ::std::option::Option<QueryParameterMatcher_oneof_query_parameter_match_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueryParameterMatcher {
    fn default() -> &'a QueryParameterMatcher {
        <QueryParameterMatcher as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueryParameterMatcher_oneof_query_parameter_match_specifier {
    string_match(super::string::StringMatcher),
    present_match(bool),
}

impl QueryParameterMatcher {
    pub fn new() -> QueryParameterMatcher {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value = 3;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // .google.protobuf.BoolValue regex = 4;


    pub fn get_regex(&self) -> &::protobuf::well_known_types::BoolValue {
        self.regex.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_regex(&mut self) {
        self.regex.clear();
    }

    pub fn has_regex(&self) -> bool {
        self.regex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_regex(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.regex = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_regex(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.regex.is_none() {
            self.regex.set_default();
        }
        self.regex.as_mut().unwrap()
    }

    // Take field
    pub fn take_regex(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.regex.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .envoy.type.matcher.StringMatcher string_match = 5;


    pub fn get_string_match(&self) -> &super::string::StringMatcher {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v)) => v,
            _ => <super::string::StringMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_string_match(&mut self) {
        self.query_parameter_match_specifier = ::std::option::Option::None;
    }

    pub fn has_string_match(&self) -> bool {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_match(&mut self, v: super::string::StringMatcher) {
        self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_match(&mut self) -> &mut super::string::StringMatcher {
        if let ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(_)) = self.query_parameter_match_specifier {
        } else {
            self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(super::string::StringMatcher::new()));
        }
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_match(&mut self) -> super::string::StringMatcher {
        if self.has_string_match() {
            match self.query_parameter_match_specifier.take() {
                ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(v)) => v,
                _ => panic!(),
            }
        } else {
            super::string::StringMatcher::new()
        }
    }

    // bool present_match = 6;


    pub fn get_present_match(&self) -> bool {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v)) => v,
            _ => false,
        }
    }
    pub fn clear_present_match(&mut self) {
        self.query_parameter_match_specifier = ::std::option::Option::None;
    }

    pub fn has_present_match(&self) -> bool {
        match self.query_parameter_match_specifier {
            ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_present_match(&mut self, v: bool) {
        self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v))
    }
}

impl ::protobuf::Message for QueryParameterMatcher {
    fn is_initialized(&self) -> bool {
        for v in &self.regex {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v)) = self.query_parameter_match_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.regex)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query_parameter_match_specifier = ::std::option::Option::Some(QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.value);
        }
        if let Some(ref v) = self.regex.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.query_parameter_match_specifier {
            match v {
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(3, &self.value)?;
        }
        if let Some(ref v) = self.regex.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.query_parameter_match_specifier {
            match v {
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::string_match(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueryParameterMatcher_oneof_query_parameter_match_specifier::present_match(v) => {
                    os.write_bool(6, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueryParameterMatcher {
        QueryParameterMatcher::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &QueryParameterMatcher| { &m.name },
                |m: &mut QueryParameterMatcher| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &QueryParameterMatcher| { &m.value },
                |m: &mut QueryParameterMatcher| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "regex",
                |m: &QueryParameterMatcher| { &m.regex },
                |m: &mut QueryParameterMatcher| { &mut m.regex },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::string::StringMatcher>(
                "string_match",
                QueryParameterMatcher::has_string_match,
                QueryParameterMatcher::get_string_match,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "present_match",
                QueryParameterMatcher::has_present_match,
                QueryParameterMatcher::get_present_match,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueryParameterMatcher>(
                "QueryParameterMatcher",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueryParameterMatcher {
        static instance: ::protobuf::rt::LazyV2<QueryParameterMatcher> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueryParameterMatcher::new)
    }
}

impl ::protobuf::Clear for QueryParameterMatcher {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.regex.clear();
        self.query_parameter_match_specifier = ::std::option::Option::None;
        self.query_parameter_match_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueryParameterMatcher {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueryParameterMatcher {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)envoy/api/v2/route/route_components.proto\x12\x12envoy.api.v2.route\
    \x1a\x1cenvoy/api/v2/core/base.proto\x1a\x1eenvoy/type/matcher/regex.pro\
    to\x1a\x1fenvoy/type/matcher/string.proto\x1a\x18envoy/type/percent.prot\
    o\x1a\x16envoy/type/range.proto\x1a&envoy/type/tracing/v2/custom_tag.pro\
    to\x1a\x19google/protobuf/any.proto\x1a\x1egoogle/protobuf/duration.prot\
    o\x1a\x1cgoogle/protobuf/struct.proto\x1a\x1egoogle/protobuf/wrappers.pr\
    oto\x1a#envoy/annotations/deprecation.proto\x1a\x1eudpa/annotations/migr\
    ate.proto\x1a\x1dudpa/annotations/status.proto\x1a\x17validate/validate.\
    proto\"\x91\r\n\x0bVirtualHost\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04\
    nameB\x07\xfaB\x04r\x02\x20\x01\x12,\n\x07domains\x18\x02\x20\x03(\tR\
    \x07domainsB\x12\xfaB\x0f\x92\x01\x0c\x08\x01\"\x08r\x06\xc0\x01\x02\xc8\
    \x01\0\x121\n\x06routes\x18\x03\x20\x03(\x0b2\x19.envoy.api.v2.route.Rou\
    teR\x06routes\x12]\n\x0brequire_tls\x18\x04\x20\x01(\x0e22.envoy.api.v2.\
    route.VirtualHost.TlsRequirementTypeR\nrequireTlsB\x08\xfaB\x05\x82\x01\
    \x02\x10\x01\x12M\n\x10virtual_clusters\x18\x05\x20\x03(\x0b2\".envoy.ap\
    i.v2.route.VirtualClusterR\x0fvirtualClusters\x12>\n\x0brate_limits\x18\
    \x06\x20\x03(\x0b2\x1d.envoy.api.v2.route.RateLimitR\nrateLimits\x12d\n\
    \x16request_headers_to_add\x18\x07\x20\x03(\x0b2$.envoy.api.v2.core.Head\
    erValueOptionR\x13requestHeadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\
    \x07\x129\n\x19request_headers_to_remove\x18\r\x20\x03(\tR\x16requestHea\
    dersToRemove\x12f\n\x17response_headers_to_add\x18\n\x20\x03(\x0b2$.envo\
    y.api.v2.core.HeaderValueOptionR\x14responseHeadersToAddB\t\xfaB\x06\x92\
    \x01\x03\x10\xe8\x07\x12;\n\x1aresponse_headers_to_remove\x18\x0b\x20\
    \x03(\tR\x17responseHeadersToRemove\x122\n\x04cors\x18\x08\x20\x01(\x0b2\
    \x1e.envoy.api.v2.route.CorsPolicyR\x04cors\x12d\n\x11per_filter_config\
    \x18\x0c\x20\x03(\x0b24.envoy.api.v2.route.VirtualHost.PerFilterConfigEn\
    tryR\x0fperFilterConfigB\x02\x18\x01\x12p\n\x17typed_per_filter_config\
    \x18\x0f\x20\x03(\x0b29.envoy.api.v2.route.VirtualHost.TypedPerFilterCon\
    figEntryR\x14typedPerFilterConfig\x12A\n\x1dinclude_request_attempt_coun\
    t\x18\x0e\x20\x01(\x08R\x1aincludeRequestAttemptCount\x12H\n!include_att\
    empt_count_in_response\x18\x13\x20\x01(\x08R\x1dincludeAttemptCountInRes\
    ponse\x12B\n\x0cretry_policy\x18\x10\x20\x01(\x0b2\x1f.envoy.api.v2.rout\
    e.RetryPolicyR\x0bretryPolicy\x12O\n\x19retry_policy_typed_config\x18\
    \x14\x20\x01(\x0b2\x14.google.protobuf.AnyR\x16retryPolicyTypedConfig\
    \x12B\n\x0chedge_policy\x18\x11\x20\x01(\x0b2\x1f.envoy.api.v2.route.Hed\
    gePolicyR\x0bhedgePolicy\x12`\n\x1eper_request_buffer_limit_bytes\x18\
    \x12\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x1aperRequestBufferL\
    imitBytes\x1a[\n\x14PerFilterConfigEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12-\n\x05value\x18\x02\x20\x01(\x0b2\x17.google.protobu\
    f.StructR\x05value:\x028\x01\x1a]\n\x19TypedPerFilterConfigEntry\x12\x10\
    \n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05value\x18\x02\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01\":\n\x12TlsRequirement\
    Type\x12\x08\n\x04NONE\x10\0\x12\x11\n\rEXTERNAL_ONLY\x10\x01\x12\x07\n\
    \x03ALL\x10\x02J\x04\x08\t\x10\n\"<\n\x0cFilterAction\x12,\n\x06action\
    \x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x06action\"\xe6\n\n\x05R\
    oute\x12\x12\n\x04name\x18\x0e\x20\x01(\tR\x04name\x12>\n\x05match\x18\
    \x01\x20\x01(\x0b2\x1e.envoy.api.v2.route.RouteMatchR\x05matchB\x08\xfaB\
    \x05\x8a\x01\x02\x10\x01\x127\n\x05route\x18\x02\x20\x01(\x0b2\x1f.envoy\
    .api.v2.route.RouteActionH\0R\x05route\x12@\n\x08redirect\x18\x03\x20\
    \x01(\x0b2\".envoy.api.v2.route.RedirectActionH\0R\x08redirect\x12S\n\
    \x0fdirect_response\x18\x07\x20\x01(\x0b2(.envoy.api.v2.route.DirectResp\
    onseActionH\0R\x0edirectResponse\x12G\n\rfilter_action\x18\x11\x20\x01(\
    \x0b2\x20.envoy.api.v2.route.FilterActionH\0R\x0cfilterAction\x127\n\x08\
    metadata\x18\x04\x20\x01(\x0b2\x1b.envoy.api.v2.core.MetadataR\x08metada\
    ta\x12;\n\tdecorator\x18\x05\x20\x01(\x0b2\x1d.envoy.api.v2.route.Decora\
    torR\tdecorator\x12^\n\x11per_filter_config\x18\x08\x20\x03(\x0b2..envoy\
    .api.v2.route.Route.PerFilterConfigEntryR\x0fperFilterConfigB\x02\x18\
    \x01\x12j\n\x17typed_per_filter_config\x18\r\x20\x03(\x0b23.envoy.api.v2\
    .route.Route.TypedPerFilterConfigEntryR\x14typedPerFilterConfig\x12d\n\
    \x16request_headers_to_add\x18\t\x20\x03(\x0b2$.envoy.api.v2.core.Header\
    ValueOptionR\x13requestHeadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\
    \x129\n\x19request_headers_to_remove\x18\x0c\x20\x03(\tR\x16requestHeade\
    rsToRemove\x12f\n\x17response_headers_to_add\x18\n\x20\x03(\x0b2$.envoy.\
    api.v2.core.HeaderValueOptionR\x14responseHeadersToAddB\t\xfaB\x06\x92\
    \x01\x03\x10\xe8\x07\x12;\n\x1aresponse_headers_to_remove\x18\x0b\x20\
    \x03(\tR\x17responseHeadersToRemove\x125\n\x07tracing\x18\x0f\x20\x01(\
    \x0b2\x1b.envoy.api.v2.route.TracingR\x07tracing\x12`\n\x1eper_request_b\
    uffer_limit_bytes\x18\x10\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\
    \x1aperRequestBufferLimitBytes\x1a[\n\x14PerFilterConfigEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12-\n\x05value\x18\x02\x20\x01(\x0b2\
    \x17.google.protobuf.StructR\x05value:\x028\x01\x1a]\n\x19TypedPerFilter\
    ConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05value\
    \x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01B\r\n\
    \x06action\x12\x03\xf8B\x01J\x04\x08\x06\x10\x07\"\x90\t\n\x0fWeightedCl\
    uster\x12W\n\x08clusters\x18\x01\x20\x03(\x0b21.envoy.api.v2.route.Weigh\
    tedCluster.ClusterWeightR\x08clustersB\x08\xfaB\x05\x92\x01\x02\x08\x01\
    \x12H\n\x0ctotal_weight\x18\x03\x20\x01(\x0b2\x1c.google.protobuf.UInt32\
    ValueR\x0btotalWeightB\x07\xfaB\x04*\x02(\x01\x12,\n\x12runtime_key_pref\
    ix\x18\x02\x20\x01(\tR\x10runtimeKeyPrefix\x1a\xab\x07\n\rClusterWeight\
    \x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\x20\
    \x01\x124\n\x06weight\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32Va\
    lueR\x06weight\x12B\n\x0emetadata_match\x18\x03\x20\x01(\x0b2\x1b.envoy.\
    api.v2.core.MetadataR\rmetadataMatch\x12d\n\x16request_headers_to_add\
    \x18\x04\x20\x03(\x0b2$.envoy.api.v2.core.HeaderValueOptionR\x13requestH\
    eadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x129\n\x19request_header\
    s_to_remove\x18\t\x20\x03(\tR\x16requestHeadersToRemove\x12f\n\x17respon\
    se_headers_to_add\x18\x05\x20\x03(\x0b2$.envoy.api.v2.core.HeaderValueOp\
    tionR\x14responseHeadersToAddB\t\xfaB\x06\x92\x01\x03\x10\xe8\x07\x12;\n\
    \x1aresponse_headers_to_remove\x18\x06\x20\x03(\tR\x17responseHeadersToR\
    emove\x12v\n\x11per_filter_config\x18\x08\x20\x03(\x0b2F.envoy.api.v2.ro\
    ute.WeightedCluster.ClusterWeight.PerFilterConfigEntryR\x0fperFilterConf\
    igB\x02\x18\x01\x12\x82\x01\n\x17typed_per_filter_config\x18\n\x20\x03(\
    \x0b2K.envoy.api.v2.route.WeightedCluster.ClusterWeight.TypedPerFilterCo\
    nfigEntryR\x14typedPerFilterConfig\x1a[\n\x14PerFilterConfigEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12-\n\x05value\x18\x02\x20\x01\
    (\x0b2\x17.google.protobuf.StructR\x05value:\x028\x01\x1a]\n\x19TypedPer\
    FilterConfigEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12*\n\x05\
    value\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x05value:\x028\x01J\
    \x04\x08\x07\x10\x08\"\xc8\x06\n\nRouteMatch\x12\x18\n\x06prefix\x18\x01\
    \x20\x01(\tH\0R\x06prefix\x12\x14\n\x04path\x18\x02\x20\x01(\tH\0R\x04pa\
    th\x12(\n\x05regex\x18\x03\x20\x01(\tH\0R\x05regexB\x10\x18\x01\xb8\xee\
    \xf2\xd2\x05\x01\xfaB\x05r\x03(\x80\x08\x12K\n\nsafe_regex\x18\n\x20\x01\
    (\x0b2\x20.envoy.type.matcher.RegexMatcherH\0R\tsafeRegexB\x08\xfaB\x05\
    \x8a\x01\x02\x10\x01\x12A\n\x0ecase_sensitive\x18\x04\x20\x01(\x0b2\x1a.\
    google.protobuf.BoolValueR\rcaseSensitive\x12V\n\x10runtime_fraction\x18\
    \t\x20\x01(\x0b2+.envoy.api.v2.core.RuntimeFractionalPercentR\x0fruntime\
    Fraction\x12;\n\x07headers\x18\x06\x20\x03(\x0b2!.envoy.api.v2.route.Hea\
    derMatcherR\x07headers\x12T\n\x10query_parameters\x18\x07\x20\x03(\x0b2)\
    .envoy.api.v2.route.QueryParameterMatcherR\x0fqueryParameters\x12H\n\x04\
    grpc\x18\x08\x20\x01(\x0b24.envoy.api.v2.route.RouteMatch.GrpcRouteMatch\
    OptionsR\x04grpc\x12V\n\x0btls_context\x18\x0b\x20\x01(\x0b25.envoy.api.\
    v2.route.RouteMatch.TlsContextMatchOptionsR\ntlsContext\x1a\x17\n\x15Grp\
    cRouteMatchOptions\x1a\x8c\x01\n\x16TlsContextMatchOptions\x128\n\tprese\
    nted\x18\x01\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\tpresented\x12\
    8\n\tvalidated\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\tval\
    idatedB\x15\n\x0epath_specifier\x12\x03\xf8B\x01J\x04\x08\x05\x10\x06\"\
    \xaa\x05\n\nCorsPolicy\x12+\n\x0callow_origin\x18\x01\x20\x03(\tR\x0ball\
    owOriginB\x08\x18\x01\xb8\xee\xf2\xd2\x05\x01\x12=\n\x12allow_origin_reg\
    ex\x18\x08\x20\x03(\tR\x10allowOriginRegexB\x0f\x18\x01\xfaB\n\x92\x01\
    \x07\"\x05r\x03(\x80\x08\x12\\\n\x19allow_origin_string_match\x18\x0b\
    \x20\x03(\x0b2!.envoy.type.matcher.StringMatcherR\x16allowOriginStringMa\
    tch\x12#\n\rallow_methods\x18\x02\x20\x01(\tR\x0callowMethods\x12#\n\ral\
    low_headers\x18\x03\x20\x01(\tR\x0callowHeaders\x12%\n\x0eexpose_headers\
    \x18\x04\x20\x01(\tR\rexposeHeaders\x12\x17\n\x07max_age\x18\x05\x20\x01\
    (\tR\x06maxAge\x12G\n\x11allow_credentials\x18\x06\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.BoolValueR\x10allowCredentials\x12@\n\x07enabled\x18\x07\
    \x20\x01(\x0b2\x1a.google.protobuf.BoolValueH\0R\x07enabledB\x08\x18\x01\
    \xb8\xee\xf2\xd2\x05\x01\x12T\n\x0efilter_enabled\x18\t\x20\x01(\x0b2+.e\
    nvoy.api.v2.core.RuntimeFractionalPercentH\0R\rfilterEnabled\x12R\n\x0es\
    hadow_enabled\x18\n\x20\x01(\x0b2+.envoy.api.v2.core.RuntimeFractionalPe\
    rcentR\rshadowEnabledB\x13\n\x11enabled_specifier\"\xfb\x1b\n\x0bRouteAc\
    tion\x12#\n\x07cluster\x18\x01\x20\x01(\tH\0R\x07clusterB\x07\xfaB\x04r\
    \x02\x20\x01\x126\n\x0ecluster_header\x18\x02\x20\x01(\tH\0R\rclusterHea\
    derB\r\xfaB\nr\x08\x20\x01\xc0\x01\x01\xc8\x01\0\x12R\n\x11weighted_clus\
    ters\x18\x03\x20\x01(\x0b2#.envoy.api.v2.route.WeightedClusterH\0R\x10we\
    ightedClusters\x12\x8b\x01\n\x1fcluster_not_found_response_code\x18\x14\
    \x20\x01(\x0e2;.envoy.api.v2.route.RouteAction.ClusterNotFoundResponseCo\
    deR\x1bclusterNotFoundResponseCodeB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12\
    B\n\x0emetadata_match\x18\x04\x20\x01(\x0b2\x1b.envoy.api.v2.core.Metada\
    taR\rmetadataMatch\x122\n\x0eprefix_rewrite\x18\x05\x20\x01(\tR\rprefixR\
    ewriteB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x12P\n\rregex_rewrite\
    \x18\x20\x20\x01(\x0b2+.envoy.type.matcher.RegexMatchAndSubstituteR\x0cr\
    egexRewrite\x12L\n\x0chost_rewrite\x18\x06\x20\x01(\tH\x01R\x0bhostRewri\
    teB'\xf2\x98\xfe\x8f\x05\x16\n\x14host_rewrite_literal\xfaB\x08r\x06\xc0\
    \x01\x02\xc8\x01\0\x12H\n\x11auto_host_rewrite\x18\x07\x20\x01(\x0b2\x1a\
    .google.protobuf.BoolValueH\x01R\x0fautoHostRewrite\x12a\n\x18auto_host_\
    rewrite_header\x18\x1d\x20\x01(\tH\x01R\x15autoHostRewriteHeaderB&\xfaB\
    \x08r\x06\xc0\x01\x01\xc8\x01\0\xf2\x98\xfe\x8f\x05\x15\n\x13host_rewrit\
    e_header\x123\n\x07timeout\x18\x08\x20\x01(\x0b2\x19.google.protobuf.Dur\
    ationR\x07timeout\x12<\n\x0cidle_timeout\x18\x18\x20\x01(\x0b2\x19.googl\
    e.protobuf.DurationR\x0bidleTimeout\x12B\n\x0cretry_policy\x18\t\x20\x01\
    (\x0b2\x1f.envoy.api.v2.route.RetryPolicyR\x0bretryPolicy\x12O\n\x19retr\
    y_policy_typed_config\x18!\x20\x01(\x0b2\x14.google.protobuf.AnyR\x16ret\
    ryPolicyTypedConfig\x12k\n\x15request_mirror_policy\x18\n\x20\x01(\x0b23\
    .envoy.api.v2.route.RouteAction.RequestMirrorPolicyR\x13requestMirrorPol\
    icyB\x02\x18\x01\x12k\n\x17request_mirror_policies\x18\x1e\x20\x03(\x0b2\
    3.envoy.api.v2.route.RouteAction.RequestMirrorPolicyR\x15requestMirrorPo\
    licies\x12H\n\x08priority\x18\x0b\x20\x01(\x0e2\".envoy.api.v2.core.Rout\
    ingPriorityR\x08priorityB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12>\n\x0brat\
    e_limits\x18\r\x20\x03(\x0b2\x1d.envoy.api.v2.route.RateLimitR\nrateLimi\
    ts\x12O\n\x16include_vh_rate_limits\x18\x0e\x20\x01(\x0b2\x1a.google.pro\
    tobuf.BoolValueR\x13includeVhRateLimits\x12K\n\x0bhash_policy\x18\x0f\
    \x20\x03(\x0b2*.envoy.api.v2.route.RouteAction.HashPolicyR\nhashPolicy\
    \x122\n\x04cors\x18\x11\x20\x01(\x0b2\x1e.envoy.api.v2.route.CorsPolicyR\
    \x04cors\x12C\n\x10max_grpc_timeout\x18\x17\x20\x01(\x0b2\x19.google.pro\
    tobuf.DurationR\x0emaxGrpcTimeout\x12I\n\x13grpc_timeout_offset\x18\x1c\
    \x20\x01(\x0b2\x19.google.protobuf.DurationR\x11grpcTimeoutOffset\x12V\n\
    \x0fupgrade_configs\x18\x19\x20\x03(\x0b2-.envoy.api.v2.route.RouteActio\
    n.UpgradeConfigR\x0eupgradeConfigs\x12p\n\x18internal_redirect_action\
    \x18\x1a\x20\x01(\x0e26.envoy.api.v2.route.RouteAction.InternalRedirectA\
    ctionR\x16internalRedirectAction\x12R\n\x16max_internal_redirects\x18\
    \x1f\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x14maxInternalRedire\
    cts\x12B\n\x0chedge_policy\x18\x1b\x20\x01(\x0b2\x1f.envoy.api.v2.route.\
    HedgePolicyR\x0bhedgePolicy\x1a\xfc\x01\n\x13RequestMirrorPolicy\x12!\n\
    \x07cluster\x18\x01\x20\x01(\tR\x07clusterB\x07\xfaB\x04r\x02\x20\x01\
    \x12)\n\x0bruntime_key\x18\x02\x20\x01(\tR\nruntimeKeyB\x08\x18\x01\xb8\
    \xee\xf2\xd2\x05\x01\x12V\n\x10runtime_fraction\x18\x03\x20\x01(\x0b2+.e\
    nvoy.api.v2.core.RuntimeFractionalPercentR\x0fruntimeFraction\x12?\n\rtr\
    ace_sampled\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x0ctrac\
    eSampled\x1a\xc6\x06\n\nHashPolicy\x12K\n\x06header\x18\x01\x20\x01(\x0b\
    21.envoy.api.v2.route.RouteAction.HashPolicy.HeaderH\0R\x06header\x12K\n\
    \x06cookie\x18\x02\x20\x01(\x0b21.envoy.api.v2.route.RouteAction.HashPol\
    icy.CookieH\0R\x06cookie\x12v\n\x15connection_properties\x18\x03\x20\x01\
    (\x0b2?.envoy.api.v2.route.RouteAction.HashPolicy.ConnectionPropertiesH\
    \0R\x14connectionProperties\x12d\n\x0fquery_parameter\x18\x05\x20\x01(\
    \x0b29.envoy.api.v2.route.RouteAction.HashPolicy.QueryParameterH\0R\x0eq\
    ueryParameter\x12[\n\x0cfilter_state\x18\x06\x20\x01(\x0b26.envoy.api.v2\
    .route.RouteAction.HashPolicy.FilterStateH\0R\x0bfilterState\x12\x1a\n\
    \x08terminal\x18\x04\x20\x01(\x08R\x08terminal\x1a8\n\x06Header\x12.\n\
    \x0bheader_name\x18\x01\x20\x01(\tR\nheaderNameB\r\xfaB\nr\x08\x20\x01\
    \xc0\x01\x01\xc8\x01\0\x1af\n\x06Cookie\x12\x1b\n\x04name\x18\x01\x20\
    \x01(\tR\x04nameB\x07\xfaB\x04r\x02\x20\x01\x12+\n\x03ttl\x18\x02\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x03ttl\x12\x12\n\x04path\x18\
    \x03\x20\x01(\tR\x04path\x1a3\n\x14ConnectionProperties\x12\x1b\n\tsourc\
    e_ip\x18\x01\x20\x01(\x08R\x08sourceIp\x1a-\n\x0eQueryParameter\x12\x1b\
    \n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\x20\x01\x1a(\n\
    \x0bFilterState\x12\x19\n\x03key\x18\x01\x20\x01(\tR\x03keyB\x07\xfaB\
    \x04r\x02\x20\x01B\x17\n\x10policy_specifier\x12\x03\xf8B\x01\x1au\n\rUp\
    gradeConfig\x12.\n\x0cupgrade_type\x18\x01\x20\x01(\tR\x0bupgradeTypeB\
    \x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x124\n\x07enabled\x18\x02\x20\
    \x01(\x0b2\x1a.google.protobuf.BoolValueR\x07enabled\"E\n\x1bClusterNotF\
    oundResponseCode\x12\x17\n\x13SERVICE_UNAVAILABLE\x10\0\x12\r\n\tNOT_FOU\
    ND\x10\x01\"Z\n\x16InternalRedirectAction\x12\"\n\x1ePASS_THROUGH_INTERN\
    AL_REDIRECT\x10\0\x12\x1c\n\x18HANDLE_INTERNAL_REDIRECT\x10\x01B\x18\n\
    \x11cluster_specifier\x12\x03\xf8B\x01B\x18\n\x16host_rewrite_specifierJ\
    \x04\x08\x0c\x10\rJ\x04\x08\x12\x10\x13J\x04\x08\x13\x10\x14J\x04\x08\
    \x10\x10\x11J\x04\x08\x16\x10\x17J\x04\x08\x15\x10\x16\"\xf3\t\n\x0bRetr\
    yPolicy\x12\x19\n\x08retry_on\x18\x01\x20\x01(\tR\x07retryOn\x12=\n\x0bn\
    um_retries\x18\x02\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\nnumRe\
    tries\x12A\n\x0fper_try_timeout\x18\x03\x20\x01(\x0b2\x19.google.protobu\
    f.DurationR\rperTryTimeout\x12T\n\x0eretry_priority\x18\x04\x20\x01(\x0b\
    2-.envoy.api.v2.route.RetryPolicy.RetryPriorityR\rretryPriority\x12d\n\
    \x14retry_host_predicate\x18\x05\x20\x03(\x0b22.envoy.api.v2.route.Retry\
    Policy.RetryHostPredicateR\x12retryHostPredicate\x12H\n!host_selection_r\
    etry_max_attempts\x18\x06\x20\x01(\x03R\x1dhostSelectionRetryMaxAttempts\
    \x124\n\x16retriable_status_codes\x18\x07\x20\x03(\rR\x14retriableStatus\
    Codes\x12R\n\x0eretry_back_off\x18\x08\x20\x01(\x0b2,.envoy.api.v2.route\
    .RetryPolicy.RetryBackOffR\x0cretryBackOff\x12N\n\x11retriable_headers\
    \x18\t\x20\x03(\x0b2!.envoy.api.v2.route.HeaderMatcherR\x10retriableHead\
    ers\x12]\n\x19retriable_request_headers\x18\n\x20\x03(\x0b2!.envoy.api.v\
    2.route.HeaderMatcherR\x17retriableRequestHeaders\x1a\xad\x01\n\rRetryPr\
    iority\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\
    \x20\x01\x125\n\x06config\x18\x02\x20\x01(\x0b2\x17.google.protobuf.Stru\
    ctH\0R\x06configB\x02\x18\x01\x129\n\x0ctyped_config\x18\x03\x20\x01(\
    \x0b2\x14.google.protobuf.AnyH\0R\x0btypedConfigB\r\n\x0bconfig_type\x1a\
    \xb2\x01\n\x12RetryHostPredicate\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\x07\xfaB\x04r\x02\x20\x01\x125\n\x06config\x18\x02\x20\x01(\
    \x0b2\x17.google.protobuf.StructH\0R\x06configB\x02\x18\x01\x129\n\x0cty\
    ped_config\x18\x03\x20\x01(\x0b2\x14.google.protobuf.AnyH\0R\x0btypedCon\
    figB\r\n\x0bconfig_type\x1a\xa2\x01\n\x0cRetryBackOff\x12J\n\rbase_inter\
    val\x18\x01\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0cbaseIntervalB\
    \n\xfaB\x07\xaa\x01\x04\x08\x01*\0\x12F\n\x0cmax_interval\x18\x02\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x0bmaxIntervalB\x08\xfaB\x05\
    \xaa\x01\x02*\0\"\xf2\x01\n\x0bHedgePolicy\x12P\n\x10initial_requests\
    \x18\x01\x20\x01(\x0b2\x1c.google.protobuf.UInt32ValueR\x0finitialReques\
    tsB\x07\xfaB\x04*\x02(\x01\x12Y\n\x19additional_request_chance\x18\x02\
    \x20\x01(\x0b2\x1d.envoy.type.FractionalPercentR\x17additionalRequestCha\
    nce\x126\n\x18hedge_on_per_try_timeout\x18\x03\x20\x01(\x08R\x14hedgeOnP\
    erTryTimeout\"\xdd\x04\n\x0eRedirectAction\x12'\n\x0ehttps_redirect\x18\
    \x04\x20\x01(\x08H\0R\rhttpsRedirect\x12)\n\x0fscheme_redirect\x18\x07\
    \x20\x01(\tH\0R\x0eschemeRedirect\x120\n\rhost_redirect\x18\x01\x20\x01(\
    \tR\x0chostRedirectB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x12#\n\rpor\
    t_redirect\x18\x08\x20\x01(\rR\x0cportRedirect\x122\n\rpath_redirect\x18\
    \x02\x20\x01(\tH\x01R\x0cpathRedirectB\x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\
    \x01\0\x124\n\x0eprefix_rewrite\x18\x05\x20\x01(\tH\x01R\rprefixRewriteB\
    \x0b\xfaB\x08r\x06\xc0\x01\x02\xc8\x01\0\x12f\n\rresponse_code\x18\x03\
    \x20\x01(\x0e27.envoy.api.v2.route.RedirectAction.RedirectResponseCodeR\
    \x0cresponseCodeB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12\x1f\n\x0bstrip_qu\
    ery\x18\x06\x20\x01(\x08R\nstripQuery\"w\n\x14RedirectResponseCode\x12\
    \x15\n\x11MOVED_PERMANENTLY\x10\0\x12\t\n\x05FOUND\x10\x01\x12\r\n\tSEE_\
    OTHER\x10\x02\x12\x16\n\x12TEMPORARY_REDIRECT\x10\x03\x12\x16\n\x12PERMA\
    NENT_REDIRECT\x10\x04B\x1a\n\x18scheme_rewrite_specifierB\x18\n\x16path_\
    rewrite_specifier\"m\n\x14DirectResponseAction\x12\"\n\x06status\x18\x01\
    \x20\x01(\rR\x06statusB\n\xfaB\x07*\x05\x10\xd8\x04(d\x121\n\x04body\x18\
    \x02\x20\x01(\x0b2\x1d.envoy.api.v2.core.DataSourceR\x04body\"l\n\tDecor\
    ator\x12%\n\toperation\x18\x01\x20\x01(\tR\toperationB\x07\xfaB\x04r\x02\
    \x20\x01\x128\n\tpropagate\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.Boo\
    lValueR\tpropagate\"\xa6\x02\n\x07Tracing\x12F\n\x0fclient_sampling\x18\
    \x01\x20\x01(\x0b2\x1d.envoy.type.FractionalPercentR\x0eclientSampling\
    \x12F\n\x0frandom_sampling\x18\x02\x20\x01(\x0b2\x1d.envoy.type.Fraction\
    alPercentR\x0erandomSampling\x12H\n\x10overall_sampling\x18\x03\x20\x01(\
    \x0b2\x1d.envoy.type.FractionalPercentR\x0foverallSampling\x12A\n\x0bcus\
    tom_tags\x18\x04\x20\x03(\x0b2\x20.envoy.type.tracing.v2.CustomTagR\ncus\
    tomTags\"\xda\x01\n\x0eVirtualCluster\x12*\n\x07pattern\x18\x01\x20\x01(\
    \tR\x07patternB\x10\x18\x01\xb8\xee\xf2\xd2\x05\x01\xfaB\x05r\x03(\x80\
    \x08\x12;\n\x07headers\x18\x04\x20\x03(\x0b2!.envoy.api.v2.route.HeaderM\
    atcherR\x07headers\x12\x1b\n\x04name\x18\x02\x20\x01(\tR\x04nameB\x07\
    \xfaB\x04r\x02\x20\x01\x12B\n\x06method\x18\x03\x20\x01(\x0e2\x20.envoy.\
    api.v2.core.RequestMethodR\x06methodB\x08\x18\x01\xb8\xee\xf2\xd2\x05\
    \x01\"\xd3\t\n\tRateLimit\x12;\n\x05stage\x18\x01\x20\x01(\x0b2\x1c.goog\
    le.protobuf.UInt32ValueR\x05stageB\x07\xfaB\x04*\x02\x18\n\x12\x1f\n\x0b\
    disable_key\x18\x02\x20\x01(\tR\ndisableKey\x12H\n\x07actions\x18\x03\
    \x20\x03(\x0b2$.envoy.api.v2.route.RateLimit.ActionR\x07actionsB\x08\xfa\
    B\x05\x92\x01\x02\x08\x01\x1a\x9d\x08\n\x06Action\x12[\n\x0esource_clust\
    er\x18\x01\x20\x01(\x0b22.envoy.api.v2.route.RateLimit.Action.SourceClus\
    terH\0R\rsourceCluster\x12j\n\x13destination_cluster\x18\x02\x20\x01(\
    \x0b27.envoy.api.v2.route.RateLimit.Action.DestinationClusterH\0R\x12des\
    tinationCluster\x12^\n\x0frequest_headers\x18\x03\x20\x01(\x0b23.envoy.a\
    pi.v2.route.RateLimit.Action.RequestHeadersH\0R\x0erequestHeaders\x12[\n\
    \x0eremote_address\x18\x04\x20\x01(\x0b22.envoy.api.v2.route.RateLimit.A\
    ction.RemoteAddressH\0R\rremoteAddress\x12R\n\x0bgeneric_key\x18\x05\x20\
    \x01(\x0b2/.envoy.api.v2.route.RateLimit.Action.GenericKeyH\0R\ngenericK\
    ey\x12e\n\x12header_value_match\x18\x06\x20\x01(\x0b25.envoy.api.v2.rout\
    e.RateLimit.Action.HeaderValueMatchH\0R\x10headerValueMatch\x1a\x0f\n\rS\
    ourceCluster\x1a\x14\n\x12DestinationCluster\x1ap\n\x0eRequestHeaders\
    \x12.\n\x0bheader_name\x18\x01\x20\x01(\tR\nheaderNameB\r\xfaB\nr\x08\
    \x20\x01\xc0\x01\x01\xc8\x01\0\x12.\n\x0edescriptor_key\x18\x02\x20\x01(\
    \tR\rdescriptorKeyB\x07\xfaB\x04r\x02\x20\x01\x1a\x0f\n\rRemoteAddress\
    \x1a@\n\nGenericKey\x122\n\x10descriptor_value\x18\x01\x20\x01(\tR\x0fde\
    scriptorValueB\x07\xfaB\x04r\x02\x20\x01\x1a\xcc\x01\n\x10HeaderValueMat\
    ch\x122\n\x10descriptor_value\x18\x01\x20\x01(\tR\x0fdescriptorValueB\
    \x07\xfaB\x04r\x02\x20\x01\x12=\n\x0cexpect_match\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.BoolValueR\x0bexpectMatch\x12E\n\x07headers\x18\x03\
    \x20\x03(\x0b2!.envoy.api.v2.route.HeaderMatcherR\x07headersB\x08\xfaB\
    \x05\x92\x01\x02\x08\x01B\x17\n\x10action_specifier\x12\x03\xf8B\x01\"\
    \xdf\x03\n\rHeaderMatcher\x12!\n\x04name\x18\x01\x20\x01(\tR\x04nameB\r\
    \xfaB\nr\x08\x20\x01\xc0\x01\x01\xc8\x01\0\x12!\n\x0bexact_match\x18\x04\
    \x20\x01(\tH\0R\nexactMatch\x123\n\x0bregex_match\x18\x05\x20\x01(\tH\0R\
    \nregexMatchB\x10\x18\x01\xb8\xee\xf2\xd2\x05\x01\xfaB\x05r\x03(\x80\x08\
    \x12L\n\x10safe_regex_match\x18\x0b\x20\x01(\x0b2\x20.envoy.type.matcher\
    .RegexMatcherH\0R\x0esafeRegexMatch\x129\n\x0brange_match\x18\x06\x20\
    \x01(\x0b2\x16.envoy.type.Int64RangeH\0R\nrangeMatch\x12%\n\rpresent_mat\
    ch\x18\x07\x20\x01(\x08H\0R\x0cpresentMatch\x12,\n\x0cprefix_match\x18\t\
    \x20\x01(\tH\0R\x0bprefixMatchB\x07\xfaB\x04r\x02\x20\x01\x12,\n\x0csuff\
    ix_match\x18\n\x20\x01(\tH\0R\x0bsuffixMatchB\x07\xfaB\x04r\x02\x20\x01\
    \x12!\n\x0cinvert_match\x18\x08\x20\x01(\x08R\x0binvertMatchB\x18\n\x16h\
    eader_match_specifierJ\x04\x08\x02\x10\x03J\x04\x08\x03\x10\x04\"\xaf\
    \x02\n\x15QueryParameterMatcher\x12\x1e\n\x04name\x18\x01\x20\x01(\tR\
    \x04nameB\n\xfaB\x07r\x05\x20\x01(\x80\x08\x12\x1e\n\x05value\x18\x03\
    \x20\x01(\tR\x05valueB\x08\x18\x01\xb8\xee\xf2\xd2\x05\x01\x12:\n\x05reg\
    ex\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x05regexB\x08\
    \x18\x01\xb8\xee\xf2\xd2\x05\x01\x12P\n\x0cstring_match\x18\x05\x20\x01(\
    \x0b2!.envoy.type.matcher.StringMatcherH\0R\x0bstringMatchB\x08\xfaB\x05\
    \x8a\x01\x02\x10\x01\x12%\n\rpresent_match\x18\x06\x20\x01(\x08H\0R\x0cp\
    resentMatchB!\n\x1fquery_parameter_match_specifierB_\n\x20io.envoyproxy.\
    envoy.api.v2.routeB\x14RouteComponentsProtoP\x01\xba\x80\xc8\xd1\x06\x02\
    \x10\x01\xf2\x98\xfe\x8f\x05\x17\x12\x15envoy.config.route.v3b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
