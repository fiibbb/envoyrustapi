// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/filter/http/jwt_authn/v2alpha/config.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct JwtProvider {
    // message fields
    pub issuer: ::std::string::String,
    pub audiences: ::protobuf::RepeatedField<::std::string::String>,
    pub forward: bool,
    pub from_headers: ::protobuf::RepeatedField<JwtHeader>,
    pub from_params: ::protobuf::RepeatedField<::std::string::String>,
    pub forward_payload_header: ::std::string::String,
    pub payload_in_metadata: ::std::string::String,
    // message oneof groups
    pub jwks_source_specifier: ::std::option::Option<JwtProvider_oneof_jwks_source_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JwtProvider {
    fn default() -> &'a JwtProvider {
        <JwtProvider as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum JwtProvider_oneof_jwks_source_specifier {
    remote_jwks(RemoteJwks),
    local_jwks(super::base::DataSource),
}

impl JwtProvider {
    pub fn new() -> JwtProvider {
        ::std::default::Default::default()
    }

    // string issuer = 1;


    pub fn get_issuer(&self) -> &str {
        &self.issuer
    }
    pub fn clear_issuer(&mut self) {
        self.issuer.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuer(&mut self, v: ::std::string::String) {
        self.issuer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer(&mut self) -> &mut ::std::string::String {
        &mut self.issuer
    }

    // Take field
    pub fn take_issuer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuer, ::std::string::String::new())
    }

    // repeated string audiences = 2;


    pub fn get_audiences(&self) -> &[::std::string::String] {
        &self.audiences
    }
    pub fn clear_audiences(&mut self) {
        self.audiences.clear();
    }

    // Param is passed by value, moved
    pub fn set_audiences(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.audiences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audiences(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.audiences
    }

    // Take field
    pub fn take_audiences(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.audiences, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.filter.http.jwt_authn.v2alpha.RemoteJwks remote_jwks = 3;


    pub fn get_remote_jwks(&self) -> &RemoteJwks {
        match self.jwks_source_specifier {
            ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(ref v)) => v,
            _ => <RemoteJwks as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote_jwks(&mut self) {
        self.jwks_source_specifier = ::std::option::Option::None;
    }

    pub fn has_remote_jwks(&self) -> bool {
        match self.jwks_source_specifier {
            ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote_jwks(&mut self, v: RemoteJwks) {
        self.jwks_source_specifier = ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote_jwks(&mut self) -> &mut RemoteJwks {
        if let ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(_)) = self.jwks_source_specifier {
        } else {
            self.jwks_source_specifier = ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(RemoteJwks::new()));
        }
        match self.jwks_source_specifier {
            ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote_jwks(&mut self) -> RemoteJwks {
        if self.has_remote_jwks() {
            match self.jwks_source_specifier.take() {
                ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoteJwks::new()
        }
    }

    // .envoy.api.v2.core.DataSource local_jwks = 4;


    pub fn get_local_jwks(&self) -> &super::base::DataSource {
        match self.jwks_source_specifier {
            ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(ref v)) => v,
            _ => <super::base::DataSource as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_local_jwks(&mut self) {
        self.jwks_source_specifier = ::std::option::Option::None;
    }

    pub fn has_local_jwks(&self) -> bool {
        match self.jwks_source_specifier {
            ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_local_jwks(&mut self, v: super::base::DataSource) {
        self.jwks_source_specifier = ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(v))
    }

    // Mutable pointer to the field.
    pub fn mut_local_jwks(&mut self) -> &mut super::base::DataSource {
        if let ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(_)) = self.jwks_source_specifier {
        } else {
            self.jwks_source_specifier = ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(super::base::DataSource::new()));
        }
        match self.jwks_source_specifier {
            ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_local_jwks(&mut self) -> super::base::DataSource {
        if self.has_local_jwks() {
            match self.jwks_source_specifier.take() {
                ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(v)) => v,
                _ => panic!(),
            }
        } else {
            super::base::DataSource::new()
        }
    }

    // bool forward = 5;


    pub fn get_forward(&self) -> bool {
        self.forward
    }
    pub fn clear_forward(&mut self) {
        self.forward = false;
    }

    // Param is passed by value, moved
    pub fn set_forward(&mut self, v: bool) {
        self.forward = v;
    }

    // repeated .envoy.config.filter.http.jwt_authn.v2alpha.JwtHeader from_headers = 6;


    pub fn get_from_headers(&self) -> &[JwtHeader] {
        &self.from_headers
    }
    pub fn clear_from_headers(&mut self) {
        self.from_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_headers(&mut self, v: ::protobuf::RepeatedField<JwtHeader>) {
        self.from_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_from_headers(&mut self) -> &mut ::protobuf::RepeatedField<JwtHeader> {
        &mut self.from_headers
    }

    // Take field
    pub fn take_from_headers(&mut self) -> ::protobuf::RepeatedField<JwtHeader> {
        ::std::mem::replace(&mut self.from_headers, ::protobuf::RepeatedField::new())
    }

    // repeated string from_params = 7;


    pub fn get_from_params(&self) -> &[::std::string::String] {
        &self.from_params
    }
    pub fn clear_from_params(&mut self) {
        self.from_params.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_params(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.from_params = v;
    }

    // Mutable pointer to the field.
    pub fn mut_from_params(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.from_params
    }

    // Take field
    pub fn take_from_params(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.from_params, ::protobuf::RepeatedField::new())
    }

    // string forward_payload_header = 8;


    pub fn get_forward_payload_header(&self) -> &str {
        &self.forward_payload_header
    }
    pub fn clear_forward_payload_header(&mut self) {
        self.forward_payload_header.clear();
    }

    // Param is passed by value, moved
    pub fn set_forward_payload_header(&mut self, v: ::std::string::String) {
        self.forward_payload_header = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forward_payload_header(&mut self) -> &mut ::std::string::String {
        &mut self.forward_payload_header
    }

    // Take field
    pub fn take_forward_payload_header(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.forward_payload_header, ::std::string::String::new())
    }

    // string payload_in_metadata = 9;


    pub fn get_payload_in_metadata(&self) -> &str {
        &self.payload_in_metadata
    }
    pub fn clear_payload_in_metadata(&mut self) {
        self.payload_in_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_payload_in_metadata(&mut self, v: ::std::string::String) {
        self.payload_in_metadata = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload_in_metadata(&mut self) -> &mut ::std::string::String {
        &mut self.payload_in_metadata
    }

    // Take field
    pub fn take_payload_in_metadata(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.payload_in_metadata, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JwtProvider {
    fn is_initialized(&self) -> bool {
        if let Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(ref v)) = self.jwks_source_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(ref v)) = self.jwks_source_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.from_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.issuer)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audiences)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.jwks_source_specifier = ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::remote_jwks(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.jwks_source_specifier = ::std::option::Option::Some(JwtProvider_oneof_jwks_source_specifier::local_jwks(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.forward = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.from_headers)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.from_params)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.forward_payload_header)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.payload_in_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.issuer.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.issuer);
        }
        for value in &self.audiences {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.forward != false {
            my_size += 2;
        }
        for value in &self.from_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.from_params {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if !self.forward_payload_header.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.forward_payload_header);
        }
        if !self.payload_in_metadata.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.payload_in_metadata);
        }
        if let ::std::option::Option::Some(ref v) = self.jwks_source_specifier {
            match v {
                &JwtProvider_oneof_jwks_source_specifier::remote_jwks(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JwtProvider_oneof_jwks_source_specifier::local_jwks(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.issuer.is_empty() {
            os.write_string(1, &self.issuer)?;
        }
        for v in &self.audiences {
            os.write_string(2, &v)?;
        };
        if self.forward != false {
            os.write_bool(5, self.forward)?;
        }
        for v in &self.from_headers {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.from_params {
            os.write_string(7, &v)?;
        };
        if !self.forward_payload_header.is_empty() {
            os.write_string(8, &self.forward_payload_header)?;
        }
        if !self.payload_in_metadata.is_empty() {
            os.write_string(9, &self.payload_in_metadata)?;
        }
        if let ::std::option::Option::Some(ref v) = self.jwks_source_specifier {
            match v {
                &JwtProvider_oneof_jwks_source_specifier::remote_jwks(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JwtProvider_oneof_jwks_source_specifier::local_jwks(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JwtProvider {
        JwtProvider::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "issuer",
                |m: &JwtProvider| { &m.issuer },
                |m: &mut JwtProvider| { &mut m.issuer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audiences",
                |m: &JwtProvider| { &m.audiences },
                |m: &mut JwtProvider| { &mut m.audiences },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoteJwks>(
                "remote_jwks",
                JwtProvider::has_remote_jwks,
                JwtProvider::get_remote_jwks,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::base::DataSource>(
                "local_jwks",
                JwtProvider::has_local_jwks,
                JwtProvider::get_local_jwks,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "forward",
                |m: &JwtProvider| { &m.forward },
                |m: &mut JwtProvider| { &mut m.forward },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JwtHeader>>(
                "from_headers",
                |m: &JwtProvider| { &m.from_headers },
                |m: &mut JwtProvider| { &mut m.from_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from_params",
                |m: &JwtProvider| { &m.from_params },
                |m: &mut JwtProvider| { &mut m.from_params },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forward_payload_header",
                |m: &JwtProvider| { &m.forward_payload_header },
                |m: &mut JwtProvider| { &mut m.forward_payload_header },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "payload_in_metadata",
                |m: &JwtProvider| { &m.payload_in_metadata },
                |m: &mut JwtProvider| { &mut m.payload_in_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JwtProvider>(
                "JwtProvider",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JwtProvider {
        static instance: ::protobuf::rt::LazyV2<JwtProvider> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JwtProvider::new)
    }
}

impl ::protobuf::Clear for JwtProvider {
    fn clear(&mut self) {
        self.issuer.clear();
        self.audiences.clear();
        self.jwks_source_specifier = ::std::option::Option::None;
        self.jwks_source_specifier = ::std::option::Option::None;
        self.forward = false;
        self.from_headers.clear();
        self.from_params.clear();
        self.forward_payload_header.clear();
        self.payload_in_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JwtProvider {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JwtProvider {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemoteJwks {
    // message fields
    pub http_uri: ::protobuf::SingularPtrField<super::http_uri::HttpUri>,
    pub cache_duration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteJwks {
    fn default() -> &'a RemoteJwks {
        <RemoteJwks as ::protobuf::Message>::default_instance()
    }
}

impl RemoteJwks {
    pub fn new() -> RemoteJwks {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.core.HttpUri http_uri = 1;


    pub fn get_http_uri(&self) -> &super::http_uri::HttpUri {
        self.http_uri.as_ref().unwrap_or_else(|| <super::http_uri::HttpUri as ::protobuf::Message>::default_instance())
    }
    pub fn clear_http_uri(&mut self) {
        self.http_uri.clear();
    }

    pub fn has_http_uri(&self) -> bool {
        self.http_uri.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_uri(&mut self, v: super::http_uri::HttpUri) {
        self.http_uri = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_uri(&mut self) -> &mut super::http_uri::HttpUri {
        if self.http_uri.is_none() {
            self.http_uri.set_default();
        }
        self.http_uri.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_uri(&mut self) -> super::http_uri::HttpUri {
        self.http_uri.take().unwrap_or_else(|| super::http_uri::HttpUri::new())
    }

    // .google.protobuf.Duration cache_duration = 2;


    pub fn get_cache_duration(&self) -> &::protobuf::well_known_types::Duration {
        self.cache_duration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cache_duration(&mut self) {
        self.cache_duration.clear();
    }

    pub fn has_cache_duration(&self) -> bool {
        self.cache_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cache_duration(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.cache_duration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cache_duration(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.cache_duration.is_none() {
            self.cache_duration.set_default();
        }
        self.cache_duration.as_mut().unwrap()
    }

    // Take field
    pub fn take_cache_duration(&mut self) -> ::protobuf::well_known_types::Duration {
        self.cache_duration.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for RemoteJwks {
    fn is_initialized(&self) -> bool {
        for v in &self.http_uri {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cache_duration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http_uri)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cache_duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.http_uri.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cache_duration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.http_uri.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cache_duration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteJwks {
        RemoteJwks::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http_uri::HttpUri>>(
                "http_uri",
                |m: &RemoteJwks| { &m.http_uri },
                |m: &mut RemoteJwks| { &mut m.http_uri },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "cache_duration",
                |m: &RemoteJwks| { &m.cache_duration },
                |m: &mut RemoteJwks| { &mut m.cache_duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoteJwks>(
                "RemoteJwks",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoteJwks {
        static instance: ::protobuf::rt::LazyV2<RemoteJwks> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoteJwks::new)
    }
}

impl ::protobuf::Clear for RemoteJwks {
    fn clear(&mut self) {
        self.http_uri.clear();
        self.cache_duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteJwks {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteJwks {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JwtHeader {
    // message fields
    pub name: ::std::string::String,
    pub value_prefix: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JwtHeader {
    fn default() -> &'a JwtHeader {
        <JwtHeader as ::protobuf::Message>::default_instance()
    }
}

impl JwtHeader {
    pub fn new() -> JwtHeader {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string value_prefix = 2;


    pub fn get_value_prefix(&self) -> &str {
        &self.value_prefix
    }
    pub fn clear_value_prefix(&mut self) {
        self.value_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_value_prefix(&mut self, v: ::std::string::String) {
        self.value_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.value_prefix
    }

    // Take field
    pub fn take_value_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value_prefix, ::std::string::String::new())
    }
}

impl ::protobuf::Message for JwtHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value_prefix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value_prefix);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value_prefix.is_empty() {
            os.write_string(2, &self.value_prefix)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JwtHeader {
        JwtHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &JwtHeader| { &m.name },
                |m: &mut JwtHeader| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value_prefix",
                |m: &JwtHeader| { &m.value_prefix },
                |m: &mut JwtHeader| { &mut m.value_prefix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JwtHeader>(
                "JwtHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JwtHeader {
        static instance: ::protobuf::rt::LazyV2<JwtHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JwtHeader::new)
    }
}

impl ::protobuf::Clear for JwtHeader {
    fn clear(&mut self) {
        self.name.clear();
        self.value_prefix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JwtHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JwtHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProviderWithAudiences {
    // message fields
    pub provider_name: ::std::string::String,
    pub audiences: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProviderWithAudiences {
    fn default() -> &'a ProviderWithAudiences {
        <ProviderWithAudiences as ::protobuf::Message>::default_instance()
    }
}

impl ProviderWithAudiences {
    pub fn new() -> ProviderWithAudiences {
        ::std::default::Default::default()
    }

    // string provider_name = 1;


    pub fn get_provider_name(&self) -> &str {
        &self.provider_name
    }
    pub fn clear_provider_name(&mut self) {
        self.provider_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_provider_name(&mut self, v: ::std::string::String) {
        self.provider_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_provider_name(&mut self) -> &mut ::std::string::String {
        &mut self.provider_name
    }

    // Take field
    pub fn take_provider_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.provider_name, ::std::string::String::new())
    }

    // repeated string audiences = 2;


    pub fn get_audiences(&self) -> &[::std::string::String] {
        &self.audiences
    }
    pub fn clear_audiences(&mut self) {
        self.audiences.clear();
    }

    // Param is passed by value, moved
    pub fn set_audiences(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.audiences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_audiences(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.audiences
    }

    // Take field
    pub fn take_audiences(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.audiences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProviderWithAudiences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.provider_name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.audiences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.provider_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.provider_name);
        }
        for value in &self.audiences {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.provider_name.is_empty() {
            os.write_string(1, &self.provider_name)?;
        }
        for v in &self.audiences {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProviderWithAudiences {
        ProviderWithAudiences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "provider_name",
                |m: &ProviderWithAudiences| { &m.provider_name },
                |m: &mut ProviderWithAudiences| { &mut m.provider_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audiences",
                |m: &ProviderWithAudiences| { &m.audiences },
                |m: &mut ProviderWithAudiences| { &mut m.audiences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProviderWithAudiences>(
                "ProviderWithAudiences",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProviderWithAudiences {
        static instance: ::protobuf::rt::LazyV2<ProviderWithAudiences> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProviderWithAudiences::new)
    }
}

impl ::protobuf::Clear for ProviderWithAudiences {
    fn clear(&mut self) {
        self.provider_name.clear();
        self.audiences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProviderWithAudiences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProviderWithAudiences {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JwtRequirement {
    // message oneof groups
    pub requires_type: ::std::option::Option<JwtRequirement_oneof_requires_type>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JwtRequirement {
    fn default() -> &'a JwtRequirement {
        <JwtRequirement as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum JwtRequirement_oneof_requires_type {
    provider_name(::std::string::String),
    provider_and_audiences(ProviderWithAudiences),
    requires_any(JwtRequirementOrList),
    requires_all(JwtRequirementAndList),
    allow_missing_or_failed(::protobuf::well_known_types::Empty),
    allow_missing(::protobuf::well_known_types::Empty),
}

impl JwtRequirement {
    pub fn new() -> JwtRequirement {
        ::std::default::Default::default()
    }

    // string provider_name = 1;


    pub fn get_provider_name(&self) -> &str {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(ref v)) => v,
            _ => "",
        }
    }
    pub fn clear_provider_name(&mut self) {
        self.requires_type = ::std::option::Option::None;
    }

    pub fn has_provider_name(&self) -> bool {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_provider_name(&mut self, v: ::std::string::String) {
        self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_provider_name(&mut self) -> &mut ::std::string::String {
        if let ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(_)) = self.requires_type {
        } else {
            self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(::std::string::String::new()));
        }
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_provider_name(&mut self) -> ::std::string::String {
        if self.has_provider_name() {
            match self.requires_type.take() {
                ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::string::String::new()
        }
    }

    // .envoy.config.filter.http.jwt_authn.v2alpha.ProviderWithAudiences provider_and_audiences = 2;


    pub fn get_provider_and_audiences(&self) -> &ProviderWithAudiences {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(ref v)) => v,
            _ => <ProviderWithAudiences as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_provider_and_audiences(&mut self) {
        self.requires_type = ::std::option::Option::None;
    }

    pub fn has_provider_and_audiences(&self) -> bool {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_provider_and_audiences(&mut self, v: ProviderWithAudiences) {
        self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(v))
    }

    // Mutable pointer to the field.
    pub fn mut_provider_and_audiences(&mut self) -> &mut ProviderWithAudiences {
        if let ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(_)) = self.requires_type {
        } else {
            self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(ProviderWithAudiences::new()));
        }
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_provider_and_audiences(&mut self) -> ProviderWithAudiences {
        if self.has_provider_and_audiences() {
            match self.requires_type.take() {
                ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(v)) => v,
                _ => panic!(),
            }
        } else {
            ProviderWithAudiences::new()
        }
    }

    // .envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementOrList requires_any = 3;


    pub fn get_requires_any(&self) -> &JwtRequirementOrList {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(ref v)) => v,
            _ => <JwtRequirementOrList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_requires_any(&mut self) {
        self.requires_type = ::std::option::Option::None;
    }

    pub fn has_requires_any(&self) -> bool {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_requires_any(&mut self, v: JwtRequirementOrList) {
        self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(v))
    }

    // Mutable pointer to the field.
    pub fn mut_requires_any(&mut self) -> &mut JwtRequirementOrList {
        if let ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(_)) = self.requires_type {
        } else {
            self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(JwtRequirementOrList::new()));
        }
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_requires_any(&mut self) -> JwtRequirementOrList {
        if self.has_requires_any() {
            match self.requires_type.take() {
                ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(v)) => v,
                _ => panic!(),
            }
        } else {
            JwtRequirementOrList::new()
        }
    }

    // .envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirementAndList requires_all = 4;


    pub fn get_requires_all(&self) -> &JwtRequirementAndList {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(ref v)) => v,
            _ => <JwtRequirementAndList as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_requires_all(&mut self) {
        self.requires_type = ::std::option::Option::None;
    }

    pub fn has_requires_all(&self) -> bool {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_requires_all(&mut self, v: JwtRequirementAndList) {
        self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(v))
    }

    // Mutable pointer to the field.
    pub fn mut_requires_all(&mut self) -> &mut JwtRequirementAndList {
        if let ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(_)) = self.requires_type {
        } else {
            self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(JwtRequirementAndList::new()));
        }
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_requires_all(&mut self) -> JwtRequirementAndList {
        if self.has_requires_all() {
            match self.requires_type.take() {
                ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(v)) => v,
                _ => panic!(),
            }
        } else {
            JwtRequirementAndList::new()
        }
    }

    // .google.protobuf.Empty allow_missing_or_failed = 5;


    pub fn get_allow_missing_or_failed(&self) -> &::protobuf::well_known_types::Empty {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_allow_missing_or_failed(&mut self) {
        self.requires_type = ::std::option::Option::None;
    }

    pub fn has_allow_missing_or_failed(&self) -> bool {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_allow_missing_or_failed(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(v))
    }

    // Mutable pointer to the field.
    pub fn mut_allow_missing_or_failed(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(_)) = self.requires_type {
        } else {
            self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(::protobuf::well_known_types::Empty::new()));
        }
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_allow_missing_or_failed(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_allow_missing_or_failed() {
            match self.requires_type.take() {
                ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }

    // .google.protobuf.Empty allow_missing = 6;


    pub fn get_allow_missing(&self) -> &::protobuf::well_known_types::Empty {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(ref v)) => v,
            _ => <::protobuf::well_known_types::Empty as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_allow_missing(&mut self) {
        self.requires_type = ::std::option::Option::None;
    }

    pub fn has_allow_missing(&self) -> bool {
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_allow_missing(&mut self, v: ::protobuf::well_known_types::Empty) {
        self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(v))
    }

    // Mutable pointer to the field.
    pub fn mut_allow_missing(&mut self) -> &mut ::protobuf::well_known_types::Empty {
        if let ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(_)) = self.requires_type {
        } else {
            self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(::protobuf::well_known_types::Empty::new()));
        }
        match self.requires_type {
            ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_allow_missing(&mut self) -> ::protobuf::well_known_types::Empty {
        if self.has_allow_missing() {
            match self.requires_type.take() {
                ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Empty::new()
        }
    }
}

impl ::protobuf::Message for JwtRequirement {
    fn is_initialized(&self) -> bool {
        if let Some(JwtRequirement_oneof_requires_type::provider_and_audiences(ref v)) = self.requires_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JwtRequirement_oneof_requires_type::requires_any(ref v)) = self.requires_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JwtRequirement_oneof_requires_type::requires_all(ref v)) = self.requires_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(ref v)) = self.requires_type {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(JwtRequirement_oneof_requires_type::allow_missing(ref v)) = self.requires_type {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_name(is.read_string()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::provider_and_audiences(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_any(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::requires_all(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing_or_failed(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.requires_type = ::std::option::Option::Some(JwtRequirement_oneof_requires_type::allow_missing(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.requires_type {
            match v {
                &JwtRequirement_oneof_requires_type::provider_name(ref v) => {
                    my_size += ::protobuf::rt::string_size(1, &v);
                },
                &JwtRequirement_oneof_requires_type::provider_and_audiences(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JwtRequirement_oneof_requires_type::requires_any(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JwtRequirement_oneof_requires_type::requires_all(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JwtRequirement_oneof_requires_type::allow_missing_or_failed(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &JwtRequirement_oneof_requires_type::allow_missing(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.requires_type {
            match v {
                &JwtRequirement_oneof_requires_type::provider_name(ref v) => {
                    os.write_string(1, v)?;
                },
                &JwtRequirement_oneof_requires_type::provider_and_audiences(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JwtRequirement_oneof_requires_type::requires_any(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JwtRequirement_oneof_requires_type::requires_all(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JwtRequirement_oneof_requires_type::allow_missing_or_failed(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &JwtRequirement_oneof_requires_type::allow_missing(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JwtRequirement {
        JwtRequirement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_string_accessor::<_>(
                "provider_name",
                JwtRequirement::has_provider_name,
                JwtRequirement::get_provider_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProviderWithAudiences>(
                "provider_and_audiences",
                JwtRequirement::has_provider_and_audiences,
                JwtRequirement::get_provider_and_audiences,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JwtRequirementOrList>(
                "requires_any",
                JwtRequirement::has_requires_any,
                JwtRequirement::get_requires_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, JwtRequirementAndList>(
                "requires_all",
                JwtRequirement::has_requires_all,
                JwtRequirement::get_requires_all,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "allow_missing_or_failed",
                JwtRequirement::has_allow_missing_or_failed,
                JwtRequirement::get_allow_missing_or_failed,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Empty>(
                "allow_missing",
                JwtRequirement::has_allow_missing,
                JwtRequirement::get_allow_missing,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JwtRequirement>(
                "JwtRequirement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JwtRequirement {
        static instance: ::protobuf::rt::LazyV2<JwtRequirement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JwtRequirement::new)
    }
}

impl ::protobuf::Clear for JwtRequirement {
    fn clear(&mut self) {
        self.requires_type = ::std::option::Option::None;
        self.requires_type = ::std::option::Option::None;
        self.requires_type = ::std::option::Option::None;
        self.requires_type = ::std::option::Option::None;
        self.requires_type = ::std::option::Option::None;
        self.requires_type = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JwtRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JwtRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JwtRequirementOrList {
    // message fields
    pub requirements: ::protobuf::RepeatedField<JwtRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JwtRequirementOrList {
    fn default() -> &'a JwtRequirementOrList {
        <JwtRequirementOrList as ::protobuf::Message>::default_instance()
    }
}

impl JwtRequirementOrList {
    pub fn new() -> JwtRequirementOrList {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1;


    pub fn get_requirements(&self) -> &[JwtRequirement] {
        &self.requirements
    }
    pub fn clear_requirements(&mut self) {
        self.requirements.clear();
    }

    // Param is passed by value, moved
    pub fn set_requirements(&mut self, v: ::protobuf::RepeatedField<JwtRequirement>) {
        self.requirements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requirements(&mut self) -> &mut ::protobuf::RepeatedField<JwtRequirement> {
        &mut self.requirements
    }

    // Take field
    pub fn take_requirements(&mut self) -> ::protobuf::RepeatedField<JwtRequirement> {
        ::std::mem::replace(&mut self.requirements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for JwtRequirementOrList {
    fn is_initialized(&self) -> bool {
        for v in &self.requirements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requirements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requirements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requirements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JwtRequirementOrList {
        JwtRequirementOrList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(
                "requirements",
                |m: &JwtRequirementOrList| { &m.requirements },
                |m: &mut JwtRequirementOrList| { &mut m.requirements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JwtRequirementOrList>(
                "JwtRequirementOrList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JwtRequirementOrList {
        static instance: ::protobuf::rt::LazyV2<JwtRequirementOrList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JwtRequirementOrList::new)
    }
}

impl ::protobuf::Clear for JwtRequirementOrList {
    fn clear(&mut self) {
        self.requirements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JwtRequirementOrList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JwtRequirementOrList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JwtRequirementAndList {
    // message fields
    pub requirements: ::protobuf::RepeatedField<JwtRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JwtRequirementAndList {
    fn default() -> &'a JwtRequirementAndList {
        <JwtRequirementAndList as ::protobuf::Message>::default_instance()
    }
}

impl JwtRequirementAndList {
    pub fn new() -> JwtRequirementAndList {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requirements = 1;


    pub fn get_requirements(&self) -> &[JwtRequirement] {
        &self.requirements
    }
    pub fn clear_requirements(&mut self) {
        self.requirements.clear();
    }

    // Param is passed by value, moved
    pub fn set_requirements(&mut self, v: ::protobuf::RepeatedField<JwtRequirement>) {
        self.requirements = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requirements(&mut self) -> &mut ::protobuf::RepeatedField<JwtRequirement> {
        &mut self.requirements
    }

    // Take field
    pub fn take_requirements(&mut self) -> ::protobuf::RepeatedField<JwtRequirement> {
        ::std::mem::replace(&mut self.requirements, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for JwtRequirementAndList {
    fn is_initialized(&self) -> bool {
        for v in &self.requirements {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requirements)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requirements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requirements {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JwtRequirementAndList {
        JwtRequirementAndList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(
                "requirements",
                |m: &JwtRequirementAndList| { &m.requirements },
                |m: &mut JwtRequirementAndList| { &mut m.requirements },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JwtRequirementAndList>(
                "JwtRequirementAndList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JwtRequirementAndList {
        static instance: ::protobuf::rt::LazyV2<JwtRequirementAndList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JwtRequirementAndList::new)
    }
}

impl ::protobuf::Clear for JwtRequirementAndList {
    fn clear(&mut self) {
        self.requirements.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JwtRequirementAndList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JwtRequirementAndList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RequirementRule {
    // message fields
    pub field_match: ::protobuf::SingularPtrField<super::route_components::RouteMatch>,
    pub requires: ::protobuf::SingularPtrField<JwtRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RequirementRule {
    fn default() -> &'a RequirementRule {
        <RequirementRule as ::protobuf::Message>::default_instance()
    }
}

impl RequirementRule {
    pub fn new() -> RequirementRule {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.route.RouteMatch match = 1;


    pub fn get_field_match(&self) -> &super::route_components::RouteMatch {
        self.field_match.as_ref().unwrap_or_else(|| <super::route_components::RouteMatch as ::protobuf::Message>::default_instance())
    }
    pub fn clear_field_match(&mut self) {
        self.field_match.clear();
    }

    pub fn has_field_match(&self) -> bool {
        self.field_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_match(&mut self, v: super::route_components::RouteMatch) {
        self.field_match = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_match(&mut self) -> &mut super::route_components::RouteMatch {
        if self.field_match.is_none() {
            self.field_match.set_default();
        }
        self.field_match.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_match(&mut self) -> super::route_components::RouteMatch {
        self.field_match.take().unwrap_or_else(|| super::route_components::RouteMatch::new())
    }

    // .envoy.config.filter.http.jwt_authn.v2alpha.JwtRequirement requires = 2;


    pub fn get_requires(&self) -> &JwtRequirement {
        self.requires.as_ref().unwrap_or_else(|| <JwtRequirement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_requires(&mut self) {
        self.requires.clear();
    }

    pub fn has_requires(&self) -> bool {
        self.requires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires(&mut self, v: JwtRequirement) {
        self.requires = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requires(&mut self) -> &mut JwtRequirement {
        if self.requires.is_none() {
            self.requires.set_default();
        }
        self.requires.as_mut().unwrap()
    }

    // Take field
    pub fn take_requires(&mut self) -> JwtRequirement {
        self.requires.take().unwrap_or_else(|| JwtRequirement::new())
    }
}

impl ::protobuf::Message for RequirementRule {
    fn is_initialized(&self) -> bool {
        for v in &self.field_match {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requires {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.field_match)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requires)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_match.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.requires.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_match.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.requires.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RequirementRule {
        RequirementRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::route_components::RouteMatch>>(
                "match",
                |m: &RequirementRule| { &m.field_match },
                |m: &mut RequirementRule| { &mut m.field_match },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(
                "requires",
                |m: &RequirementRule| { &m.requires },
                |m: &mut RequirementRule| { &mut m.requires },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RequirementRule>(
                "RequirementRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RequirementRule {
        static instance: ::protobuf::rt::LazyV2<RequirementRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RequirementRule::new)
    }
}

impl ::protobuf::Clear for RequirementRule {
    fn clear(&mut self) {
        self.field_match.clear();
        self.requires.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RequirementRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RequirementRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FilterStateRule {
    // message fields
    pub name: ::std::string::String,
    pub requires: ::std::collections::HashMap<::std::string::String, JwtRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FilterStateRule {
    fn default() -> &'a FilterStateRule {
        <FilterStateRule as ::protobuf::Message>::default_instance()
    }
}

impl FilterStateRule {
    pub fn new() -> FilterStateRule {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule.RequiresEntry requires = 3;


    pub fn get_requires(&self) -> &::std::collections::HashMap<::std::string::String, JwtRequirement> {
        &self.requires
    }
    pub fn clear_requires(&mut self) {
        self.requires.clear();
    }

    // Param is passed by value, moved
    pub fn set_requires(&mut self, v: ::std::collections::HashMap<::std::string::String, JwtRequirement>) {
        self.requires = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requires(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, JwtRequirement> {
        &mut self.requires
    }

    // Take field
    pub fn take_requires(&mut self) -> ::std::collections::HashMap<::std::string::String, JwtRequirement> {
        ::std::mem::replace(&mut self.requires, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for FilterStateRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(wire_type, is, &mut self.requires)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(3, &self.requires);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(3, &self.requires, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FilterStateRule {
        FilterStateRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &FilterStateRule| { &m.name },
                |m: &mut FilterStateRule| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtRequirement>>(
                "requires",
                |m: &FilterStateRule| { &m.requires },
                |m: &mut FilterStateRule| { &mut m.requires },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FilterStateRule>(
                "FilterStateRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FilterStateRule {
        static instance: ::protobuf::rt::LazyV2<FilterStateRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FilterStateRule::new)
    }
}

impl ::protobuf::Clear for FilterStateRule {
    fn clear(&mut self) {
        self.name.clear();
        self.requires.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FilterStateRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilterStateRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct JwtAuthentication {
    // message fields
    pub providers: ::std::collections::HashMap<::std::string::String, JwtProvider>,
    pub rules: ::protobuf::RepeatedField<RequirementRule>,
    pub filter_state_rules: ::protobuf::SingularPtrField<FilterStateRule>,
    pub bypass_cors_preflight: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a JwtAuthentication {
    fn default() -> &'a JwtAuthentication {
        <JwtAuthentication as ::protobuf::Message>::default_instance()
    }
}

impl JwtAuthentication {
    pub fn new() -> JwtAuthentication {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.filter.http.jwt_authn.v2alpha.JwtAuthentication.ProvidersEntry providers = 1;


    pub fn get_providers(&self) -> &::std::collections::HashMap<::std::string::String, JwtProvider> {
        &self.providers
    }
    pub fn clear_providers(&mut self) {
        self.providers.clear();
    }

    // Param is passed by value, moved
    pub fn set_providers(&mut self, v: ::std::collections::HashMap<::std::string::String, JwtProvider>) {
        self.providers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_providers(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, JwtProvider> {
        &mut self.providers
    }

    // Take field
    pub fn take_providers(&mut self) -> ::std::collections::HashMap<::std::string::String, JwtProvider> {
        ::std::mem::replace(&mut self.providers, ::std::collections::HashMap::new())
    }

    // repeated .envoy.config.filter.http.jwt_authn.v2alpha.RequirementRule rules = 2;


    pub fn get_rules(&self) -> &[RequirementRule] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<RequirementRule>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<RequirementRule> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<RequirementRule> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.filter.http.jwt_authn.v2alpha.FilterStateRule filter_state_rules = 3;


    pub fn get_filter_state_rules(&self) -> &FilterStateRule {
        self.filter_state_rules.as_ref().unwrap_or_else(|| <FilterStateRule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_filter_state_rules(&mut self) {
        self.filter_state_rules.clear();
    }

    pub fn has_filter_state_rules(&self) -> bool {
        self.filter_state_rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter_state_rules(&mut self, v: FilterStateRule) {
        self.filter_state_rules = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter_state_rules(&mut self) -> &mut FilterStateRule {
        if self.filter_state_rules.is_none() {
            self.filter_state_rules.set_default();
        }
        self.filter_state_rules.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter_state_rules(&mut self) -> FilterStateRule {
        self.filter_state_rules.take().unwrap_or_else(|| FilterStateRule::new())
    }

    // bool bypass_cors_preflight = 4;


    pub fn get_bypass_cors_preflight(&self) -> bool {
        self.bypass_cors_preflight
    }
    pub fn clear_bypass_cors_preflight(&mut self) {
        self.bypass_cors_preflight = false;
    }

    // Param is passed by value, moved
    pub fn set_bypass_cors_preflight(&mut self, v: bool) {
        self.bypass_cors_preflight = v;
    }
}

impl ::protobuf::Message for JwtAuthentication {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.filter_state_rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtProvider>>(wire_type, is, &mut self.providers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.filter_state_rules)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.bypass_cors_preflight = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtProvider>>(1, &self.providers);
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.filter_state_rules.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.bypass_cors_preflight != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtProvider>>(1, &self.providers, os)?;
        for v in &self.rules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.filter_state_rules.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.bypass_cors_preflight != false {
            os.write_bool(4, self.bypass_cors_preflight)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> JwtAuthentication {
        JwtAuthentication::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<JwtProvider>>(
                "providers",
                |m: &JwtAuthentication| { &m.providers },
                |m: &mut JwtAuthentication| { &mut m.providers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RequirementRule>>(
                "rules",
                |m: &JwtAuthentication| { &m.rules },
                |m: &mut JwtAuthentication| { &mut m.rules },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FilterStateRule>>(
                "filter_state_rules",
                |m: &JwtAuthentication| { &m.filter_state_rules },
                |m: &mut JwtAuthentication| { &mut m.filter_state_rules },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "bypass_cors_preflight",
                |m: &JwtAuthentication| { &m.bypass_cors_preflight },
                |m: &mut JwtAuthentication| { &mut m.bypass_cors_preflight },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<JwtAuthentication>(
                "JwtAuthentication",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static JwtAuthentication {
        static instance: ::protobuf::rt::LazyV2<JwtAuthentication> = ::protobuf::rt::LazyV2::INIT;
        instance.get(JwtAuthentication::new)
    }
}

impl ::protobuf::Clear for JwtAuthentication {
    fn clear(&mut self) {
        self.providers.clear();
        self.rules.clear();
        self.filter_state_rules.clear();
        self.bypass_cors_preflight = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for JwtAuthentication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for JwtAuthentication {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n7envoy/config/filter/http/jwt_authn/v2alpha/config.proto\x12*envoy.con\
    fig.filter.http.jwt_authn.v2alpha\x1a\x1cenvoy/api/v2/core/base.proto\
    \x1a\x20envoy/api/v2/core/http_uri.proto\x1a)envoy/api/v2/route/route_co\
    mponents.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1bgoogle/proto\
    buf/empty.proto\x1a\x1eudpa/annotations/migrate.proto\x1a\x1dudpa/annota\
    tions/status.proto\x1a\x17validate/validate.proto\"\x80\x04\n\x0bJwtProv\
    ider\x12\x1f\n\x06issuer\x18\x01\x20\x01(\tR\x06issuerB\x07\xfaB\x04r\
    \x02\x20\x01\x12\x1c\n\taudiences\x18\x02\x20\x03(\tR\taudiences\x12Y\n\
    \x0bremote_jwks\x18\x03\x20\x01(\x0b26.envoy.config.filter.http.jwt_auth\
    n.v2alpha.RemoteJwksH\0R\nremoteJwks\x12>\n\nlocal_jwks\x18\x04\x20\x01(\
    \x0b2\x1d.envoy.api.v2.core.DataSourceH\0R\tlocalJwks\x12\x18\n\x07forwa\
    rd\x18\x05\x20\x01(\x08R\x07forward\x12X\n\x0cfrom_headers\x18\x06\x20\
    \x03(\x0b25.envoy.config.filter.http.jwt_authn.v2alpha.JwtHeaderR\x0bfro\
    mHeaders\x12\x1f\n\x0bfrom_params\x18\x07\x20\x03(\tR\nfromParams\x124\n\
    \x16forward_payload_header\x18\x08\x20\x01(\tR\x14forwardPayloadHeader\
    \x12.\n\x13payload_in_metadata\x18\t\x20\x01(\tR\x11payloadInMetadataB\
    \x1c\n\x15jwks_source_specifier\x12\x03\xf8B\x01\"\x85\x01\n\nRemoteJwks\
    \x125\n\x08http_uri\x18\x01\x20\x01(\x0b2\x1a.envoy.api.v2.core.HttpUriR\
    \x07httpUri\x12@\n\x0ecache_duration\x18\x02\x20\x01(\x0b2\x19.google.pr\
    otobuf.DurationR\rcacheDuration\"K\n\tJwtHeader\x12\x1b\n\x04name\x18\
    \x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\x20\x01\x12!\n\x0cvalue_pref\
    ix\x18\x02\x20\x01(\tR\x0bvaluePrefix\"Z\n\x15ProviderWithAudiences\x12#\
    \n\rprovider_name\x18\x01\x20\x01(\tR\x0cproviderName\x12\x1c\n\taudienc\
    es\x18\x02\x20\x03(\tR\taudiences\"\xa2\x04\n\x0eJwtRequirement\x12%\n\r\
    provider_name\x18\x01\x20\x01(\tH\0R\x0cproviderName\x12y\n\x16provider_\
    and_audiences\x18\x02\x20\x01(\x0b2A.envoy.config.filter.http.jwt_authn.\
    v2alpha.ProviderWithAudiencesH\0R\x14providerAndAudiences\x12e\n\x0crequ\
    ires_any\x18\x03\x20\x01(\x0b2@.envoy.config.filter.http.jwt_authn.v2alp\
    ha.JwtRequirementOrListH\0R\x0brequiresAny\x12f\n\x0crequires_all\x18\
    \x04\x20\x01(\x0b2A.envoy.config.filter.http.jwt_authn.v2alpha.JwtRequir\
    ementAndListH\0R\x0brequiresAll\x12O\n\x17allow_missing_or_failed\x18\
    \x05\x20\x01(\x0b2\x16.google.protobuf.EmptyH\0R\x14allowMissingOrFailed\
    \x12=\n\rallow_missing\x18\x06\x20\x01(\x0b2\x16.google.protobuf.EmptyH\
    \0R\x0callowMissingB\x0f\n\rrequires_type\"\x80\x01\n\x14JwtRequirementO\
    rList\x12h\n\x0crequirements\x18\x01\x20\x03(\x0b2:.envoy.config.filter.\
    http.jwt_authn.v2alpha.JwtRequirementR\x0crequirementsB\x08\xfaB\x05\x92\
    \x01\x02\x08\x02\"\x81\x01\n\x15JwtRequirementAndList\x12h\n\x0crequirem\
    ents\x18\x01\x20\x03(\x0b2:.envoy.config.filter.http.jwt_authn.v2alpha.J\
    wtRequirementR\x0crequirementsB\x08\xfaB\x05\x92\x01\x02\x08\x02\"\xa9\
    \x01\n\x0fRequirementRule\x12>\n\x05match\x18\x01\x20\x01(\x0b2\x1e.envo\
    y.api.v2.route.RouteMatchR\x05matchB\x08\xfaB\x05\x8a\x01\x02\x10\x01\
    \x12V\n\x08requires\x18\x02\x20\x01(\x0b2:.envoy.config.filter.http.jwt_\
    authn.v2alpha.JwtRequirementR\x08requires\"\x8e\x02\n\x0fFilterStateRule\
    \x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\x04r\x02\x20\
    \x01\x12e\n\x08requires\x18\x03\x20\x03(\x0b2I.envoy.config.filter.http.\
    jwt_authn.v2alpha.FilterStateRule.RequiresEntryR\x08requires\x1aw\n\rReq\
    uiresEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12P\n\x05value\
    \x18\x02\x20\x01(\x0b2:.envoy.config.filter.http.jwt_authn.v2alpha.JwtRe\
    quirementR\x05value:\x028\x01\"\xe8\x03\n\x11JwtAuthentication\x12j\n\tp\
    roviders\x18\x01\x20\x03(\x0b2L.envoy.config.filter.http.jwt_authn.v2alp\
    ha.JwtAuthentication.ProvidersEntryR\tproviders\x12Q\n\x05rules\x18\x02\
    \x20\x03(\x0b2;.envoy.config.filter.http.jwt_authn.v2alpha.RequirementRu\
    leR\x05rules\x12i\n\x12filter_state_rules\x18\x03\x20\x01(\x0b2;.envoy.c\
    onfig.filter.http.jwt_authn.v2alpha.FilterStateRuleR\x10filterStateRules\
    \x122\n\x15bypass_cors_preflight\x18\x04\x20\x01(\x08R\x13bypassCorsPref\
    light\x1au\n\x0eProvidersEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03k\
    ey\x12M\n\x05value\x18\x02\x20\x01(\x0b27.envoy.config.filter.http.jwt_a\
    uthn.v2alpha.JwtProviderR\x05value:\x028\x01B\x83\x01\n8io.envoyproxy.en\
    voy.config.filter.http.jwt_authn.v2alphaB\x0bConfigProtoP\x01\xf2\x98\
    \xfe\x8f\x05,\x12*envoy.extensions.filters.http.jwt_authn.v3\xba\x80\xc8\
    \xd1\x06\x02\x10\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
