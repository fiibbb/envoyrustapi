// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/bootstrap/v2/bootstrap.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct Bootstrap {
    // message fields
    pub node: ::protobuf::SingularPtrField<super::base::Node>,
    pub static_resources: ::protobuf::SingularPtrField<Bootstrap_StaticResources>,
    pub dynamic_resources: ::protobuf::SingularPtrField<Bootstrap_DynamicResources>,
    pub cluster_manager: ::protobuf::SingularPtrField<ClusterManager>,
    pub hds_config: ::protobuf::SingularPtrField<super::config_source::ApiConfigSource>,
    pub flags_path: ::std::string::String,
    pub stats_sinks: ::protobuf::RepeatedField<super::stats::StatsSink>,
    pub stats_config: ::protobuf::SingularPtrField<super::stats::StatsConfig>,
    pub stats_flush_interval: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub watchdog: ::protobuf::SingularPtrField<Watchdog>,
    pub tracing: ::protobuf::SingularPtrField<super::http_tracer::Tracing>,
    pub runtime: ::protobuf::SingularPtrField<Runtime>,
    pub layered_runtime: ::protobuf::SingularPtrField<LayeredRuntime>,
    pub admin: ::protobuf::SingularPtrField<Admin>,
    pub overload_manager: ::protobuf::SingularPtrField<super::overload::OverloadManager>,
    pub enable_dispatcher_stats: bool,
    pub header_prefix: ::std::string::String,
    pub stats_server_version_override: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt64Value>,
    pub use_tcp_for_dns_lookups: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bootstrap {
    fn default() -> &'a Bootstrap {
        <Bootstrap as ::protobuf::Message>::default_instance()
    }
}

impl Bootstrap {
    pub fn new() -> Bootstrap {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.core.Node node = 1;


    pub fn get_node(&self) -> &super::base::Node {
        self.node.as_ref().unwrap_or_else(|| <super::base::Node as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    pub fn has_node(&self) -> bool {
        self.node.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: super::base::Node) {
        self.node = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut super::base::Node {
        if self.node.is_none() {
            self.node.set_default();
        }
        self.node.as_mut().unwrap()
    }

    // Take field
    pub fn take_node(&mut self) -> super::base::Node {
        self.node.take().unwrap_or_else(|| super::base::Node::new())
    }

    // .envoy.config.bootstrap.v2.Bootstrap.StaticResources static_resources = 2;


    pub fn get_static_resources(&self) -> &Bootstrap_StaticResources {
        self.static_resources.as_ref().unwrap_or_else(|| <Bootstrap_StaticResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_static_resources(&mut self) {
        self.static_resources.clear();
    }

    pub fn has_static_resources(&self) -> bool {
        self.static_resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_static_resources(&mut self, v: Bootstrap_StaticResources) {
        self.static_resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_static_resources(&mut self) -> &mut Bootstrap_StaticResources {
        if self.static_resources.is_none() {
            self.static_resources.set_default();
        }
        self.static_resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_static_resources(&mut self) -> Bootstrap_StaticResources {
        self.static_resources.take().unwrap_or_else(|| Bootstrap_StaticResources::new())
    }

    // .envoy.config.bootstrap.v2.Bootstrap.DynamicResources dynamic_resources = 3;


    pub fn get_dynamic_resources(&self) -> &Bootstrap_DynamicResources {
        self.dynamic_resources.as_ref().unwrap_or_else(|| <Bootstrap_DynamicResources as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dynamic_resources(&mut self) {
        self.dynamic_resources.clear();
    }

    pub fn has_dynamic_resources(&self) -> bool {
        self.dynamic_resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_resources(&mut self, v: Bootstrap_DynamicResources) {
        self.dynamic_resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_resources(&mut self) -> &mut Bootstrap_DynamicResources {
        if self.dynamic_resources.is_none() {
            self.dynamic_resources.set_default();
        }
        self.dynamic_resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_resources(&mut self) -> Bootstrap_DynamicResources {
        self.dynamic_resources.take().unwrap_or_else(|| Bootstrap_DynamicResources::new())
    }

    // .envoy.config.bootstrap.v2.ClusterManager cluster_manager = 4;


    pub fn get_cluster_manager(&self) -> &ClusterManager {
        self.cluster_manager.as_ref().unwrap_or_else(|| <ClusterManager as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster_manager(&mut self) {
        self.cluster_manager.clear();
    }

    pub fn has_cluster_manager(&self) -> bool {
        self.cluster_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_manager(&mut self, v: ClusterManager) {
        self.cluster_manager = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_manager(&mut self) -> &mut ClusterManager {
        if self.cluster_manager.is_none() {
            self.cluster_manager.set_default();
        }
        self.cluster_manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster_manager(&mut self) -> ClusterManager {
        self.cluster_manager.take().unwrap_or_else(|| ClusterManager::new())
    }

    // .envoy.api.v2.core.ApiConfigSource hds_config = 14;


    pub fn get_hds_config(&self) -> &super::config_source::ApiConfigSource {
        self.hds_config.as_ref().unwrap_or_else(|| <super::config_source::ApiConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hds_config(&mut self) {
        self.hds_config.clear();
    }

    pub fn has_hds_config(&self) -> bool {
        self.hds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hds_config(&mut self, v: super::config_source::ApiConfigSource) {
        self.hds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hds_config(&mut self) -> &mut super::config_source::ApiConfigSource {
        if self.hds_config.is_none() {
            self.hds_config.set_default();
        }
        self.hds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_hds_config(&mut self) -> super::config_source::ApiConfigSource {
        self.hds_config.take().unwrap_or_else(|| super::config_source::ApiConfigSource::new())
    }

    // string flags_path = 5;


    pub fn get_flags_path(&self) -> &str {
        &self.flags_path
    }
    pub fn clear_flags_path(&mut self) {
        self.flags_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_flags_path(&mut self, v: ::std::string::String) {
        self.flags_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flags_path(&mut self) -> &mut ::std::string::String {
        &mut self.flags_path
    }

    // Take field
    pub fn take_flags_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.flags_path, ::std::string::String::new())
    }

    // repeated .envoy.config.metrics.v2.StatsSink stats_sinks = 6;


    pub fn get_stats_sinks(&self) -> &[super::stats::StatsSink] {
        &self.stats_sinks
    }
    pub fn clear_stats_sinks(&mut self) {
        self.stats_sinks.clear();
    }

    // Param is passed by value, moved
    pub fn set_stats_sinks(&mut self, v: ::protobuf::RepeatedField<super::stats::StatsSink>) {
        self.stats_sinks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stats_sinks(&mut self) -> &mut ::protobuf::RepeatedField<super::stats::StatsSink> {
        &mut self.stats_sinks
    }

    // Take field
    pub fn take_stats_sinks(&mut self) -> ::protobuf::RepeatedField<super::stats::StatsSink> {
        ::std::mem::replace(&mut self.stats_sinks, ::protobuf::RepeatedField::new())
    }

    // .envoy.config.metrics.v2.StatsConfig stats_config = 13;


    pub fn get_stats_config(&self) -> &super::stats::StatsConfig {
        self.stats_config.as_ref().unwrap_or_else(|| <super::stats::StatsConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_config(&mut self) {
        self.stats_config.clear();
    }

    pub fn has_stats_config(&self) -> bool {
        self.stats_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_config(&mut self, v: super::stats::StatsConfig) {
        self.stats_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_config(&mut self) -> &mut super::stats::StatsConfig {
        if self.stats_config.is_none() {
            self.stats_config.set_default();
        }
        self.stats_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_config(&mut self) -> super::stats::StatsConfig {
        self.stats_config.take().unwrap_or_else(|| super::stats::StatsConfig::new())
    }

    // .google.protobuf.Duration stats_flush_interval = 7;


    pub fn get_stats_flush_interval(&self) -> &::protobuf::well_known_types::Duration {
        self.stats_flush_interval.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_flush_interval(&mut self) {
        self.stats_flush_interval.clear();
    }

    pub fn has_stats_flush_interval(&self) -> bool {
        self.stats_flush_interval.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_flush_interval(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.stats_flush_interval = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_flush_interval(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.stats_flush_interval.is_none() {
            self.stats_flush_interval.set_default();
        }
        self.stats_flush_interval.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_flush_interval(&mut self) -> ::protobuf::well_known_types::Duration {
        self.stats_flush_interval.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .envoy.config.bootstrap.v2.Watchdog watchdog = 8;


    pub fn get_watchdog(&self) -> &Watchdog {
        self.watchdog.as_ref().unwrap_or_else(|| <Watchdog as ::protobuf::Message>::default_instance())
    }
    pub fn clear_watchdog(&mut self) {
        self.watchdog.clear();
    }

    pub fn has_watchdog(&self) -> bool {
        self.watchdog.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watchdog(&mut self, v: Watchdog) {
        self.watchdog = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_watchdog(&mut self) -> &mut Watchdog {
        if self.watchdog.is_none() {
            self.watchdog.set_default();
        }
        self.watchdog.as_mut().unwrap()
    }

    // Take field
    pub fn take_watchdog(&mut self) -> Watchdog {
        self.watchdog.take().unwrap_or_else(|| Watchdog::new())
    }

    // .envoy.config.trace.v2.Tracing tracing = 9;


    pub fn get_tracing(&self) -> &super::http_tracer::Tracing {
        self.tracing.as_ref().unwrap_or_else(|| <super::http_tracer::Tracing as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tracing(&mut self) {
        self.tracing.clear();
    }

    pub fn has_tracing(&self) -> bool {
        self.tracing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracing(&mut self, v: super::http_tracer::Tracing) {
        self.tracing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracing(&mut self) -> &mut super::http_tracer::Tracing {
        if self.tracing.is_none() {
            self.tracing.set_default();
        }
        self.tracing.as_mut().unwrap()
    }

    // Take field
    pub fn take_tracing(&mut self) -> super::http_tracer::Tracing {
        self.tracing.take().unwrap_or_else(|| super::http_tracer::Tracing::new())
    }

    // .envoy.config.bootstrap.v2.Runtime runtime = 11;


    pub fn get_runtime(&self) -> &Runtime {
        self.runtime.as_ref().unwrap_or_else(|| <Runtime as ::protobuf::Message>::default_instance())
    }
    pub fn clear_runtime(&mut self) {
        self.runtime.clear();
    }

    pub fn has_runtime(&self) -> bool {
        self.runtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtime(&mut self, v: Runtime) {
        self.runtime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime(&mut self) -> &mut Runtime {
        if self.runtime.is_none() {
            self.runtime.set_default();
        }
        self.runtime.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtime(&mut self) -> Runtime {
        self.runtime.take().unwrap_or_else(|| Runtime::new())
    }

    // .envoy.config.bootstrap.v2.LayeredRuntime layered_runtime = 17;


    pub fn get_layered_runtime(&self) -> &LayeredRuntime {
        self.layered_runtime.as_ref().unwrap_or_else(|| <LayeredRuntime as ::protobuf::Message>::default_instance())
    }
    pub fn clear_layered_runtime(&mut self) {
        self.layered_runtime.clear();
    }

    pub fn has_layered_runtime(&self) -> bool {
        self.layered_runtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layered_runtime(&mut self, v: LayeredRuntime) {
        self.layered_runtime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layered_runtime(&mut self) -> &mut LayeredRuntime {
        if self.layered_runtime.is_none() {
            self.layered_runtime.set_default();
        }
        self.layered_runtime.as_mut().unwrap()
    }

    // Take field
    pub fn take_layered_runtime(&mut self) -> LayeredRuntime {
        self.layered_runtime.take().unwrap_or_else(|| LayeredRuntime::new())
    }

    // .envoy.config.bootstrap.v2.Admin admin = 12;


    pub fn get_admin(&self) -> &Admin {
        self.admin.as_ref().unwrap_or_else(|| <Admin as ::protobuf::Message>::default_instance())
    }
    pub fn clear_admin(&mut self) {
        self.admin.clear();
    }

    pub fn has_admin(&self) -> bool {
        self.admin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin(&mut self, v: Admin) {
        self.admin = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_admin(&mut self) -> &mut Admin {
        if self.admin.is_none() {
            self.admin.set_default();
        }
        self.admin.as_mut().unwrap()
    }

    // Take field
    pub fn take_admin(&mut self) -> Admin {
        self.admin.take().unwrap_or_else(|| Admin::new())
    }

    // .envoy.config.overload.v2alpha.OverloadManager overload_manager = 15;


    pub fn get_overload_manager(&self) -> &super::overload::OverloadManager {
        self.overload_manager.as_ref().unwrap_or_else(|| <super::overload::OverloadManager as ::protobuf::Message>::default_instance())
    }
    pub fn clear_overload_manager(&mut self) {
        self.overload_manager.clear();
    }

    pub fn has_overload_manager(&self) -> bool {
        self.overload_manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overload_manager(&mut self, v: super::overload::OverloadManager) {
        self.overload_manager = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_overload_manager(&mut self) -> &mut super::overload::OverloadManager {
        if self.overload_manager.is_none() {
            self.overload_manager.set_default();
        }
        self.overload_manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_overload_manager(&mut self) -> super::overload::OverloadManager {
        self.overload_manager.take().unwrap_or_else(|| super::overload::OverloadManager::new())
    }

    // bool enable_dispatcher_stats = 16;


    pub fn get_enable_dispatcher_stats(&self) -> bool {
        self.enable_dispatcher_stats
    }
    pub fn clear_enable_dispatcher_stats(&mut self) {
        self.enable_dispatcher_stats = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_dispatcher_stats(&mut self, v: bool) {
        self.enable_dispatcher_stats = v;
    }

    // string header_prefix = 18;


    pub fn get_header_prefix(&self) -> &str {
        &self.header_prefix
    }
    pub fn clear_header_prefix(&mut self) {
        self.header_prefix.clear();
    }

    // Param is passed by value, moved
    pub fn set_header_prefix(&mut self, v: ::std::string::String) {
        self.header_prefix = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_prefix(&mut self) -> &mut ::std::string::String {
        &mut self.header_prefix
    }

    // Take field
    pub fn take_header_prefix(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.header_prefix, ::std::string::String::new())
    }

    // .google.protobuf.UInt64Value stats_server_version_override = 19;


    pub fn get_stats_server_version_override(&self) -> &::protobuf::well_known_types::UInt64Value {
        self.stats_server_version_override.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt64Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats_server_version_override(&mut self) {
        self.stats_server_version_override.clear();
    }

    pub fn has_stats_server_version_override(&self) -> bool {
        self.stats_server_version_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats_server_version_override(&mut self, v: ::protobuf::well_known_types::UInt64Value) {
        self.stats_server_version_override = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats_server_version_override(&mut self) -> &mut ::protobuf::well_known_types::UInt64Value {
        if self.stats_server_version_override.is_none() {
            self.stats_server_version_override.set_default();
        }
        self.stats_server_version_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats_server_version_override(&mut self) -> ::protobuf::well_known_types::UInt64Value {
        self.stats_server_version_override.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt64Value::new())
    }

    // bool use_tcp_for_dns_lookups = 20;


    pub fn get_use_tcp_for_dns_lookups(&self) -> bool {
        self.use_tcp_for_dns_lookups
    }
    pub fn clear_use_tcp_for_dns_lookups(&mut self) {
        self.use_tcp_for_dns_lookups = false;
    }

    // Param is passed by value, moved
    pub fn set_use_tcp_for_dns_lookups(&mut self, v: bool) {
        self.use_tcp_for_dns_lookups = v;
    }
}

impl ::protobuf::Message for Bootstrap {
    fn is_initialized(&self) -> bool {
        for v in &self.node {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.static_resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cluster_manager {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_sinks {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_flush_interval {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.watchdog {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tracing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.runtime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.layered_runtime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.admin {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.overload_manager {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stats_server_version_override {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.static_resources)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_resources)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster_manager)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hds_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.flags_path)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.stats_sinks)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_config)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_flush_interval)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.watchdog)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tracing)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.runtime)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.layered_runtime)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.admin)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.overload_manager)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_dispatcher_stats = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.header_prefix)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats_server_version_override)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_tcp_for_dns_lookups = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.static_resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dynamic_resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cluster_manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.flags_path.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.flags_path);
        }
        for value in &self.stats_sinks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.stats_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stats_flush_interval.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.watchdog.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tracing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.runtime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.layered_runtime.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.admin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.overload_manager.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enable_dispatcher_stats != false {
            my_size += 3;
        }
        if !self.header_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.header_prefix);
        }
        if let Some(ref v) = self.stats_server_version_override.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.use_tcp_for_dns_lookups != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.node.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.static_resources.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dynamic_resources.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cluster_manager.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hds_config.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.flags_path.is_empty() {
            os.write_string(5, &self.flags_path)?;
        }
        for v in &self.stats_sinks {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.stats_config.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stats_flush_interval.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.watchdog.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tracing.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.runtime.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.layered_runtime.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.admin.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.overload_manager.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enable_dispatcher_stats != false {
            os.write_bool(16, self.enable_dispatcher_stats)?;
        }
        if !self.header_prefix.is_empty() {
            os.write_string(18, &self.header_prefix)?;
        }
        if let Some(ref v) = self.stats_server_version_override.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.use_tcp_for_dns_lookups != false {
            os.write_bool(20, self.use_tcp_for_dns_lookups)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bootstrap {
        Bootstrap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::Node>>(
                "node",
                |m: &Bootstrap| { &m.node },
                |m: &mut Bootstrap| { &mut m.node },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bootstrap_StaticResources>>(
                "static_resources",
                |m: &Bootstrap| { &m.static_resources },
                |m: &mut Bootstrap| { &mut m.static_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Bootstrap_DynamicResources>>(
                "dynamic_resources",
                |m: &Bootstrap| { &m.dynamic_resources },
                |m: &mut Bootstrap| { &mut m.dynamic_resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterManager>>(
                "cluster_manager",
                |m: &Bootstrap| { &m.cluster_manager },
                |m: &mut Bootstrap| { &mut m.cluster_manager },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ApiConfigSource>>(
                "hds_config",
                |m: &Bootstrap| { &m.hds_config },
                |m: &mut Bootstrap| { &mut m.hds_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "flags_path",
                |m: &Bootstrap| { &m.flags_path },
                |m: &mut Bootstrap| { &mut m.flags_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::StatsSink>>(
                "stats_sinks",
                |m: &Bootstrap| { &m.stats_sinks },
                |m: &mut Bootstrap| { &mut m.stats_sinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::stats::StatsConfig>>(
                "stats_config",
                |m: &Bootstrap| { &m.stats_config },
                |m: &mut Bootstrap| { &mut m.stats_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "stats_flush_interval",
                |m: &Bootstrap| { &m.stats_flush_interval },
                |m: &mut Bootstrap| { &mut m.stats_flush_interval },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Watchdog>>(
                "watchdog",
                |m: &Bootstrap| { &m.watchdog },
                |m: &mut Bootstrap| { &mut m.watchdog },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http_tracer::Tracing>>(
                "tracing",
                |m: &Bootstrap| { &m.tracing },
                |m: &mut Bootstrap| { &mut m.tracing },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Runtime>>(
                "runtime",
                |m: &Bootstrap| { &m.runtime },
                |m: &mut Bootstrap| { &mut m.runtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LayeredRuntime>>(
                "layered_runtime",
                |m: &Bootstrap| { &m.layered_runtime },
                |m: &mut Bootstrap| { &mut m.layered_runtime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Admin>>(
                "admin",
                |m: &Bootstrap| { &m.admin },
                |m: &mut Bootstrap| { &mut m.admin },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::overload::OverloadManager>>(
                "overload_manager",
                |m: &Bootstrap| { &m.overload_manager },
                |m: &mut Bootstrap| { &mut m.overload_manager },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_dispatcher_stats",
                |m: &Bootstrap| { &m.enable_dispatcher_stats },
                |m: &mut Bootstrap| { &mut m.enable_dispatcher_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "header_prefix",
                |m: &Bootstrap| { &m.header_prefix },
                |m: &mut Bootstrap| { &mut m.header_prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt64Value>>(
                "stats_server_version_override",
                |m: &Bootstrap| { &m.stats_server_version_override },
                |m: &mut Bootstrap| { &mut m.stats_server_version_override },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_tcp_for_dns_lookups",
                |m: &Bootstrap| { &m.use_tcp_for_dns_lookups },
                |m: &mut Bootstrap| { &mut m.use_tcp_for_dns_lookups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bootstrap>(
                "Bootstrap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bootstrap {
        static instance: ::protobuf::rt::LazyV2<Bootstrap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bootstrap::new)
    }
}

impl ::protobuf::Clear for Bootstrap {
    fn clear(&mut self) {
        self.node.clear();
        self.static_resources.clear();
        self.dynamic_resources.clear();
        self.cluster_manager.clear();
        self.hds_config.clear();
        self.flags_path.clear();
        self.stats_sinks.clear();
        self.stats_config.clear();
        self.stats_flush_interval.clear();
        self.watchdog.clear();
        self.tracing.clear();
        self.runtime.clear();
        self.layered_runtime.clear();
        self.admin.clear();
        self.overload_manager.clear();
        self.enable_dispatcher_stats = false;
        self.header_prefix.clear();
        self.stats_server_version_override.clear();
        self.use_tcp_for_dns_lookups = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bootstrap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bootstrap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bootstrap_StaticResources {
    // message fields
    pub listeners: ::protobuf::RepeatedField<super::listener::Listener>,
    pub clusters: ::protobuf::RepeatedField<super::cluster::Cluster>,
    pub secrets: ::protobuf::RepeatedField<super::secret::Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bootstrap_StaticResources {
    fn default() -> &'a Bootstrap_StaticResources {
        <Bootstrap_StaticResources as ::protobuf::Message>::default_instance()
    }
}

impl Bootstrap_StaticResources {
    pub fn new() -> Bootstrap_StaticResources {
        ::std::default::Default::default()
    }

    // repeated .envoy.api.v2.Listener listeners = 1;


    pub fn get_listeners(&self) -> &[super::listener::Listener] {
        &self.listeners
    }
    pub fn clear_listeners(&mut self) {
        self.listeners.clear();
    }

    // Param is passed by value, moved
    pub fn set_listeners(&mut self, v: ::protobuf::RepeatedField<super::listener::Listener>) {
        self.listeners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_listeners(&mut self) -> &mut ::protobuf::RepeatedField<super::listener::Listener> {
        &mut self.listeners
    }

    // Take field
    pub fn take_listeners(&mut self) -> ::protobuf::RepeatedField<super::listener::Listener> {
        ::std::mem::replace(&mut self.listeners, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.Cluster clusters = 2;


    pub fn get_clusters(&self) -> &[super::cluster::Cluster] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<super::cluster::Cluster>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<super::cluster::Cluster> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<super::cluster::Cluster> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.api.v2.auth.Secret secrets = 3;


    pub fn get_secrets(&self) -> &[super::secret::Secret] {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::protobuf::RepeatedField<super::secret::Secret>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::protobuf::RepeatedField<super::secret::Secret> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::protobuf::RepeatedField<super::secret::Secret> {
        ::std::mem::replace(&mut self.secrets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Bootstrap_StaticResources {
    fn is_initialized(&self) -> bool {
        for v in &self.listeners {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.listeners)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secrets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.listeners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.listeners {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.clusters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.secrets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bootstrap_StaticResources {
        Bootstrap_StaticResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::listener::Listener>>(
                "listeners",
                |m: &Bootstrap_StaticResources| { &m.listeners },
                |m: &mut Bootstrap_StaticResources| { &mut m.listeners },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cluster::Cluster>>(
                "clusters",
                |m: &Bootstrap_StaticResources| { &m.clusters },
                |m: &mut Bootstrap_StaticResources| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::secret::Secret>>(
                "secrets",
                |m: &Bootstrap_StaticResources| { &m.secrets },
                |m: &mut Bootstrap_StaticResources| { &mut m.secrets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bootstrap_StaticResources>(
                "Bootstrap.StaticResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bootstrap_StaticResources {
        static instance: ::protobuf::rt::LazyV2<Bootstrap_StaticResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bootstrap_StaticResources::new)
    }
}

impl ::protobuf::Clear for Bootstrap_StaticResources {
    fn clear(&mut self) {
        self.listeners.clear();
        self.clusters.clear();
        self.secrets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bootstrap_StaticResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bootstrap_StaticResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Bootstrap_DynamicResources {
    // message fields
    pub lds_config: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    pub cds_config: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    pub ads_config: ::protobuf::SingularPtrField<super::config_source::ApiConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Bootstrap_DynamicResources {
    fn default() -> &'a Bootstrap_DynamicResources {
        <Bootstrap_DynamicResources as ::protobuf::Message>::default_instance()
    }
}

impl Bootstrap_DynamicResources {
    pub fn new() -> Bootstrap_DynamicResources {
        ::std::default::Default::default()
    }

    // .envoy.api.v2.core.ConfigSource lds_config = 1;


    pub fn get_lds_config(&self) -> &super::config_source::ConfigSource {
        self.lds_config.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lds_config(&mut self) {
        self.lds_config.clear();
    }

    pub fn has_lds_config(&self) -> bool {
        self.lds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lds_config(&mut self, v: super::config_source::ConfigSource) {
        self.lds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lds_config(&mut self) -> &mut super::config_source::ConfigSource {
        if self.lds_config.is_none() {
            self.lds_config.set_default();
        }
        self.lds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_lds_config(&mut self) -> super::config_source::ConfigSource {
        self.lds_config.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }

    // .envoy.api.v2.core.ConfigSource cds_config = 2;


    pub fn get_cds_config(&self) -> &super::config_source::ConfigSource {
        self.cds_config.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cds_config(&mut self) {
        self.cds_config.clear();
    }

    pub fn has_cds_config(&self) -> bool {
        self.cds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cds_config(&mut self, v: super::config_source::ConfigSource) {
        self.cds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cds_config(&mut self) -> &mut super::config_source::ConfigSource {
        if self.cds_config.is_none() {
            self.cds_config.set_default();
        }
        self.cds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_cds_config(&mut self) -> super::config_source::ConfigSource {
        self.cds_config.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }

    // .envoy.api.v2.core.ApiConfigSource ads_config = 3;


    pub fn get_ads_config(&self) -> &super::config_source::ApiConfigSource {
        self.ads_config.as_ref().unwrap_or_else(|| <super::config_source::ApiConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ads_config(&mut self) {
        self.ads_config.clear();
    }

    pub fn has_ads_config(&self) -> bool {
        self.ads_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ads_config(&mut self, v: super::config_source::ApiConfigSource) {
        self.ads_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ads_config(&mut self) -> &mut super::config_source::ApiConfigSource {
        if self.ads_config.is_none() {
            self.ads_config.set_default();
        }
        self.ads_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_ads_config(&mut self) -> super::config_source::ApiConfigSource {
        self.ads_config.take().unwrap_or_else(|| super::config_source::ApiConfigSource::new())
    }
}

impl ::protobuf::Message for Bootstrap_DynamicResources {
    fn is_initialized(&self) -> bool {
        for v in &self.lds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ads_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lds_config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cds_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ads_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.lds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ads_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.lds_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cds_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ads_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Bootstrap_DynamicResources {
        Bootstrap_DynamicResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "lds_config",
                |m: &Bootstrap_DynamicResources| { &m.lds_config },
                |m: &mut Bootstrap_DynamicResources| { &mut m.lds_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "cds_config",
                |m: &Bootstrap_DynamicResources| { &m.cds_config },
                |m: &mut Bootstrap_DynamicResources| { &mut m.cds_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ApiConfigSource>>(
                "ads_config",
                |m: &Bootstrap_DynamicResources| { &m.ads_config },
                |m: &mut Bootstrap_DynamicResources| { &mut m.ads_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Bootstrap_DynamicResources>(
                "Bootstrap.DynamicResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Bootstrap_DynamicResources {
        static instance: ::protobuf::rt::LazyV2<Bootstrap_DynamicResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Bootstrap_DynamicResources::new)
    }
}

impl ::protobuf::Clear for Bootstrap_DynamicResources {
    fn clear(&mut self) {
        self.lds_config.clear();
        self.cds_config.clear();
        self.ads_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Bootstrap_DynamicResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Bootstrap_DynamicResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Admin {
    // message fields
    pub access_log_path: ::std::string::String,
    pub profile_path: ::std::string::String,
    pub address: ::protobuf::SingularPtrField<super::address::Address>,
    pub socket_options: ::protobuf::RepeatedField<super::socket_option::SocketOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Admin {
    fn default() -> &'a Admin {
        <Admin as ::protobuf::Message>::default_instance()
    }
}

impl Admin {
    pub fn new() -> Admin {
        ::std::default::Default::default()
    }

    // string access_log_path = 1;


    pub fn get_access_log_path(&self) -> &str {
        &self.access_log_path
    }
    pub fn clear_access_log_path(&mut self) {
        self.access_log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_access_log_path(&mut self, v: ::std::string::String) {
        self.access_log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_access_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.access_log_path
    }

    // Take field
    pub fn take_access_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.access_log_path, ::std::string::String::new())
    }

    // string profile_path = 2;


    pub fn get_profile_path(&self) -> &str {
        &self.profile_path
    }
    pub fn clear_profile_path(&mut self) {
        self.profile_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_profile_path(&mut self, v: ::std::string::String) {
        self.profile_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_path(&mut self) -> &mut ::std::string::String {
        &mut self.profile_path
    }

    // Take field
    pub fn take_profile_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.profile_path, ::std::string::String::new())
    }

    // .envoy.api.v2.core.Address address = 3;


    pub fn get_address(&self) -> &super::address::Address {
        self.address.as_ref().unwrap_or_else(|| <super::address::Address as ::protobuf::Message>::default_instance())
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: super::address::Address) {
        self.address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut super::address::Address {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> super::address::Address {
        self.address.take().unwrap_or_else(|| super::address::Address::new())
    }

    // repeated .envoy.api.v2.core.SocketOption socket_options = 4;


    pub fn get_socket_options(&self) -> &[super::socket_option::SocketOption] {
        &self.socket_options
    }
    pub fn clear_socket_options(&mut self) {
        self.socket_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_socket_options(&mut self, v: ::protobuf::RepeatedField<super::socket_option::SocketOption>) {
        self.socket_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_socket_options(&mut self) -> &mut ::protobuf::RepeatedField<super::socket_option::SocketOption> {
        &mut self.socket_options
    }

    // Take field
    pub fn take_socket_options(&mut self) -> ::protobuf::RepeatedField<super::socket_option::SocketOption> {
        ::std::mem::replace(&mut self.socket_options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Admin {
    fn is_initialized(&self) -> bool {
        for v in &self.address {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.socket_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.access_log_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.profile_path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.socket_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.access_log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.access_log_path);
        }
        if !self.profile_path.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.profile_path);
        }
        if let Some(ref v) = self.address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.socket_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.access_log_path.is_empty() {
            os.write_string(1, &self.access_log_path)?;
        }
        if !self.profile_path.is_empty() {
            os.write_string(2, &self.profile_path)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.socket_options {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Admin {
        Admin::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "access_log_path",
                |m: &Admin| { &m.access_log_path },
                |m: &mut Admin| { &mut m.access_log_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "profile_path",
                |m: &Admin| { &m.profile_path },
                |m: &mut Admin| { &mut m.profile_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::address::Address>>(
                "address",
                |m: &Admin| { &m.address },
                |m: &mut Admin| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::socket_option::SocketOption>>(
                "socket_options",
                |m: &Admin| { &m.socket_options },
                |m: &mut Admin| { &mut m.socket_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Admin>(
                "Admin",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Admin {
        static instance: ::protobuf::rt::LazyV2<Admin> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Admin::new)
    }
}

impl ::protobuf::Clear for Admin {
    fn clear(&mut self) {
        self.access_log_path.clear();
        self.profile_path.clear();
        self.address.clear();
        self.socket_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Admin {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Admin {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterManager {
    // message fields
    pub local_cluster_name: ::std::string::String,
    pub outlier_detection: ::protobuf::SingularPtrField<ClusterManager_OutlierDetection>,
    pub upstream_bind_config: ::protobuf::SingularPtrField<super::address::BindConfig>,
    pub load_stats_config: ::protobuf::SingularPtrField<super::config_source::ApiConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterManager {
    fn default() -> &'a ClusterManager {
        <ClusterManager as ::protobuf::Message>::default_instance()
    }
}

impl ClusterManager {
    pub fn new() -> ClusterManager {
        ::std::default::Default::default()
    }

    // string local_cluster_name = 1;


    pub fn get_local_cluster_name(&self) -> &str {
        &self.local_cluster_name
    }
    pub fn clear_local_cluster_name(&mut self) {
        self.local_cluster_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_local_cluster_name(&mut self, v: ::std::string::String) {
        self.local_cluster_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local_cluster_name(&mut self) -> &mut ::std::string::String {
        &mut self.local_cluster_name
    }

    // Take field
    pub fn take_local_cluster_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.local_cluster_name, ::std::string::String::new())
    }

    // .envoy.config.bootstrap.v2.ClusterManager.OutlierDetection outlier_detection = 2;


    pub fn get_outlier_detection(&self) -> &ClusterManager_OutlierDetection {
        self.outlier_detection.as_ref().unwrap_or_else(|| <ClusterManager_OutlierDetection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outlier_detection(&mut self) {
        self.outlier_detection.clear();
    }

    pub fn has_outlier_detection(&self) -> bool {
        self.outlier_detection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outlier_detection(&mut self, v: ClusterManager_OutlierDetection) {
        self.outlier_detection = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outlier_detection(&mut self) -> &mut ClusterManager_OutlierDetection {
        if self.outlier_detection.is_none() {
            self.outlier_detection.set_default();
        }
        self.outlier_detection.as_mut().unwrap()
    }

    // Take field
    pub fn take_outlier_detection(&mut self) -> ClusterManager_OutlierDetection {
        self.outlier_detection.take().unwrap_or_else(|| ClusterManager_OutlierDetection::new())
    }

    // .envoy.api.v2.core.BindConfig upstream_bind_config = 3;


    pub fn get_upstream_bind_config(&self) -> &super::address::BindConfig {
        self.upstream_bind_config.as_ref().unwrap_or_else(|| <super::address::BindConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_upstream_bind_config(&mut self) {
        self.upstream_bind_config.clear();
    }

    pub fn has_upstream_bind_config(&self) -> bool {
        self.upstream_bind_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upstream_bind_config(&mut self, v: super::address::BindConfig) {
        self.upstream_bind_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upstream_bind_config(&mut self) -> &mut super::address::BindConfig {
        if self.upstream_bind_config.is_none() {
            self.upstream_bind_config.set_default();
        }
        self.upstream_bind_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_upstream_bind_config(&mut self) -> super::address::BindConfig {
        self.upstream_bind_config.take().unwrap_or_else(|| super::address::BindConfig::new())
    }

    // .envoy.api.v2.core.ApiConfigSource load_stats_config = 4;


    pub fn get_load_stats_config(&self) -> &super::config_source::ApiConfigSource {
        self.load_stats_config.as_ref().unwrap_or_else(|| <super::config_source::ApiConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_load_stats_config(&mut self) {
        self.load_stats_config.clear();
    }

    pub fn has_load_stats_config(&self) -> bool {
        self.load_stats_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_stats_config(&mut self, v: super::config_source::ApiConfigSource) {
        self.load_stats_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_stats_config(&mut self) -> &mut super::config_source::ApiConfigSource {
        if self.load_stats_config.is_none() {
            self.load_stats_config.set_default();
        }
        self.load_stats_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_stats_config(&mut self) -> super::config_source::ApiConfigSource {
        self.load_stats_config.take().unwrap_or_else(|| super::config_source::ApiConfigSource::new())
    }
}

impl ::protobuf::Message for ClusterManager {
    fn is_initialized(&self) -> bool {
        for v in &self.outlier_detection {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upstream_bind_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.load_stats_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.local_cluster_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outlier_detection)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.upstream_bind_config)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_stats_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.local_cluster_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.local_cluster_name);
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.upstream_bind_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.load_stats_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.local_cluster_name.is_empty() {
            os.write_string(1, &self.local_cluster_name)?;
        }
        if let Some(ref v) = self.outlier_detection.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.upstream_bind_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.load_stats_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterManager {
        ClusterManager::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "local_cluster_name",
                |m: &ClusterManager| { &m.local_cluster_name },
                |m: &mut ClusterManager| { &mut m.local_cluster_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterManager_OutlierDetection>>(
                "outlier_detection",
                |m: &ClusterManager| { &m.outlier_detection },
                |m: &mut ClusterManager| { &mut m.outlier_detection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::address::BindConfig>>(
                "upstream_bind_config",
                |m: &ClusterManager| { &m.upstream_bind_config },
                |m: &mut ClusterManager| { &mut m.upstream_bind_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ApiConfigSource>>(
                "load_stats_config",
                |m: &ClusterManager| { &m.load_stats_config },
                |m: &mut ClusterManager| { &mut m.load_stats_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClusterManager>(
                "ClusterManager",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClusterManager {
        static instance: ::protobuf::rt::LazyV2<ClusterManager> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClusterManager::new)
    }
}

impl ::protobuf::Clear for ClusterManager {
    fn clear(&mut self) {
        self.local_cluster_name.clear();
        self.outlier_detection.clear();
        self.upstream_bind_config.clear();
        self.load_stats_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterManager {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterManager {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterManager_OutlierDetection {
    // message fields
    pub event_log_path: ::std::string::String,
    pub event_service: ::protobuf::SingularPtrField<super::event_service_config::EventServiceConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterManager_OutlierDetection {
    fn default() -> &'a ClusterManager_OutlierDetection {
        <ClusterManager_OutlierDetection as ::protobuf::Message>::default_instance()
    }
}

impl ClusterManager_OutlierDetection {
    pub fn new() -> ClusterManager_OutlierDetection {
        ::std::default::Default::default()
    }

    // string event_log_path = 1;


    pub fn get_event_log_path(&self) -> &str {
        &self.event_log_path
    }
    pub fn clear_event_log_path(&mut self) {
        self.event_log_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_event_log_path(&mut self, v: ::std::string::String) {
        self.event_log_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_log_path(&mut self) -> &mut ::std::string::String {
        &mut self.event_log_path
    }

    // Take field
    pub fn take_event_log_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.event_log_path, ::std::string::String::new())
    }

    // .envoy.api.v2.core.EventServiceConfig event_service = 2;


    pub fn get_event_service(&self) -> &super::event_service_config::EventServiceConfig {
        self.event_service.as_ref().unwrap_or_else(|| <super::event_service_config::EventServiceConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_event_service(&mut self) {
        self.event_service.clear();
    }

    pub fn has_event_service(&self) -> bool {
        self.event_service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_service(&mut self, v: super::event_service_config::EventServiceConfig) {
        self.event_service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_service(&mut self) -> &mut super::event_service_config::EventServiceConfig {
        if self.event_service.is_none() {
            self.event_service.set_default();
        }
        self.event_service.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_service(&mut self) -> super::event_service_config::EventServiceConfig {
        self.event_service.take().unwrap_or_else(|| super::event_service_config::EventServiceConfig::new())
    }
}

impl ::protobuf::Message for ClusterManager_OutlierDetection {
    fn is_initialized(&self) -> bool {
        for v in &self.event_service {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.event_log_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.event_service)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.event_log_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.event_log_path);
        }
        if let Some(ref v) = self.event_service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.event_log_path.is_empty() {
            os.write_string(1, &self.event_log_path)?;
        }
        if let Some(ref v) = self.event_service.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterManager_OutlierDetection {
        ClusterManager_OutlierDetection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "event_log_path",
                |m: &ClusterManager_OutlierDetection| { &m.event_log_path },
                |m: &mut ClusterManager_OutlierDetection| { &mut m.event_log_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::event_service_config::EventServiceConfig>>(
                "event_service",
                |m: &ClusterManager_OutlierDetection| { &m.event_service },
                |m: &mut ClusterManager_OutlierDetection| { &mut m.event_service },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClusterManager_OutlierDetection>(
                "ClusterManager.OutlierDetection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClusterManager_OutlierDetection {
        static instance: ::protobuf::rt::LazyV2<ClusterManager_OutlierDetection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClusterManager_OutlierDetection::new)
    }
}

impl ::protobuf::Clear for ClusterManager_OutlierDetection {
    fn clear(&mut self) {
        self.event_log_path.clear();
        self.event_service.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterManager_OutlierDetection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterManager_OutlierDetection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Watchdog {
    // message fields
    pub miss_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub megamiss_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub kill_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    pub multikill_timeout: ::protobuf::SingularPtrField<::protobuf::well_known_types::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Watchdog {
    fn default() -> &'a Watchdog {
        <Watchdog as ::protobuf::Message>::default_instance()
    }
}

impl Watchdog {
    pub fn new() -> Watchdog {
        ::std::default::Default::default()
    }

    // .google.protobuf.Duration miss_timeout = 1;


    pub fn get_miss_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.miss_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_miss_timeout(&mut self) {
        self.miss_timeout.clear();
    }

    pub fn has_miss_timeout(&self) -> bool {
        self.miss_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_miss_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.miss_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_miss_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.miss_timeout.is_none() {
            self.miss_timeout.set_default();
        }
        self.miss_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_miss_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.miss_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration megamiss_timeout = 2;


    pub fn get_megamiss_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.megamiss_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_megamiss_timeout(&mut self) {
        self.megamiss_timeout.clear();
    }

    pub fn has_megamiss_timeout(&self) -> bool {
        self.megamiss_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_megamiss_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.megamiss_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_megamiss_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.megamiss_timeout.is_none() {
            self.megamiss_timeout.set_default();
        }
        self.megamiss_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_megamiss_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.megamiss_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration kill_timeout = 3;


    pub fn get_kill_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.kill_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kill_timeout(&mut self) {
        self.kill_timeout.clear();
    }

    pub fn has_kill_timeout(&self) -> bool {
        self.kill_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.kill_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kill_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.kill_timeout.is_none() {
            self.kill_timeout.set_default();
        }
        self.kill_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_kill_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.kill_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }

    // .google.protobuf.Duration multikill_timeout = 4;


    pub fn get_multikill_timeout(&self) -> &::protobuf::well_known_types::Duration {
        self.multikill_timeout.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Duration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_multikill_timeout(&mut self) {
        self.multikill_timeout.clear();
    }

    pub fn has_multikill_timeout(&self) -> bool {
        self.multikill_timeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multikill_timeout(&mut self, v: ::protobuf::well_known_types::Duration) {
        self.multikill_timeout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_multikill_timeout(&mut self) -> &mut ::protobuf::well_known_types::Duration {
        if self.multikill_timeout.is_none() {
            self.multikill_timeout.set_default();
        }
        self.multikill_timeout.as_mut().unwrap()
    }

    // Take field
    pub fn take_multikill_timeout(&mut self) -> ::protobuf::well_known_types::Duration {
        self.multikill_timeout.take().unwrap_or_else(|| ::protobuf::well_known_types::Duration::new())
    }
}

impl ::protobuf::Message for Watchdog {
    fn is_initialized(&self) -> bool {
        for v in &self.miss_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.megamiss_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kill_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.multikill_timeout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.miss_timeout)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.megamiss_timeout)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kill_timeout)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.multikill_timeout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.miss_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.megamiss_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kill_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.multikill_timeout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.miss_timeout.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.megamiss_timeout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kill_timeout.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.multikill_timeout.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Watchdog {
        Watchdog::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "miss_timeout",
                |m: &Watchdog| { &m.miss_timeout },
                |m: &mut Watchdog| { &mut m.miss_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "megamiss_timeout",
                |m: &Watchdog| { &m.megamiss_timeout },
                |m: &mut Watchdog| { &mut m.megamiss_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "kill_timeout",
                |m: &Watchdog| { &m.kill_timeout },
                |m: &mut Watchdog| { &mut m.kill_timeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Duration>>(
                "multikill_timeout",
                |m: &Watchdog| { &m.multikill_timeout },
                |m: &mut Watchdog| { &mut m.multikill_timeout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Watchdog>(
                "Watchdog",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Watchdog {
        static instance: ::protobuf::rt::LazyV2<Watchdog> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Watchdog::new)
    }
}

impl ::protobuf::Clear for Watchdog {
    fn clear(&mut self) {
        self.miss_timeout.clear();
        self.megamiss_timeout.clear();
        self.kill_timeout.clear();
        self.multikill_timeout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Watchdog {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Watchdog {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Runtime {
    // message fields
    pub symlink_root: ::std::string::String,
    pub subdirectory: ::std::string::String,
    pub override_subdirectory: ::std::string::String,
    pub base: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Runtime {
    fn default() -> &'a Runtime {
        <Runtime as ::protobuf::Message>::default_instance()
    }
}

impl Runtime {
    pub fn new() -> Runtime {
        ::std::default::Default::default()
    }

    // string symlink_root = 1;


    pub fn get_symlink_root(&self) -> &str {
        &self.symlink_root
    }
    pub fn clear_symlink_root(&mut self) {
        self.symlink_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_symlink_root(&mut self, v: ::std::string::String) {
        self.symlink_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink_root(&mut self) -> &mut ::std::string::String {
        &mut self.symlink_root
    }

    // Take field
    pub fn take_symlink_root(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symlink_root, ::std::string::String::new())
    }

    // string subdirectory = 2;


    pub fn get_subdirectory(&self) -> &str {
        &self.subdirectory
    }
    pub fn clear_subdirectory(&mut self) {
        self.subdirectory.clear();
    }

    // Param is passed by value, moved
    pub fn set_subdirectory(&mut self, v: ::std::string::String) {
        self.subdirectory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdirectory(&mut self) -> &mut ::std::string::String {
        &mut self.subdirectory
    }

    // Take field
    pub fn take_subdirectory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subdirectory, ::std::string::String::new())
    }

    // string override_subdirectory = 3;


    pub fn get_override_subdirectory(&self) -> &str {
        &self.override_subdirectory
    }
    pub fn clear_override_subdirectory(&mut self) {
        self.override_subdirectory.clear();
    }

    // Param is passed by value, moved
    pub fn set_override_subdirectory(&mut self, v: ::std::string::String) {
        self.override_subdirectory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_override_subdirectory(&mut self) -> &mut ::std::string::String {
        &mut self.override_subdirectory
    }

    // Take field
    pub fn take_override_subdirectory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.override_subdirectory, ::std::string::String::new())
    }

    // .google.protobuf.Struct base = 4;


    pub fn get_base(&self) -> &::protobuf::well_known_types::Struct {
        self.base.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_base(&mut self) {
        self.base.clear();
    }

    pub fn has_base(&self) -> bool {
        self.base.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.base = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_base(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.base.is_none() {
            self.base.set_default();
        }
        self.base.as_mut().unwrap()
    }

    // Take field
    pub fn take_base(&mut self) -> ::protobuf::well_known_types::Struct {
        self.base.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }
}

impl ::protobuf::Message for Runtime {
    fn is_initialized(&self) -> bool {
        for v in &self.base {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symlink_root)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subdirectory)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.override_subdirectory)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.base)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.symlink_root.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.symlink_root);
        }
        if !self.subdirectory.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subdirectory);
        }
        if !self.override_subdirectory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.override_subdirectory);
        }
        if let Some(ref v) = self.base.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.symlink_root.is_empty() {
            os.write_string(1, &self.symlink_root)?;
        }
        if !self.subdirectory.is_empty() {
            os.write_string(2, &self.subdirectory)?;
        }
        if !self.override_subdirectory.is_empty() {
            os.write_string(3, &self.override_subdirectory)?;
        }
        if let Some(ref v) = self.base.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Runtime {
        Runtime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "symlink_root",
                |m: &Runtime| { &m.symlink_root },
                |m: &mut Runtime| { &mut m.symlink_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subdirectory",
                |m: &Runtime| { &m.subdirectory },
                |m: &mut Runtime| { &mut m.subdirectory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "override_subdirectory",
                |m: &Runtime| { &m.override_subdirectory },
                |m: &mut Runtime| { &mut m.override_subdirectory },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "base",
                |m: &Runtime| { &m.base },
                |m: &mut Runtime| { &mut m.base },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Runtime>(
                "Runtime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Runtime {
        static instance: ::protobuf::rt::LazyV2<Runtime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Runtime::new)
    }
}

impl ::protobuf::Clear for Runtime {
    fn clear(&mut self) {
        self.symlink_root.clear();
        self.subdirectory.clear();
        self.override_subdirectory.clear();
        self.base.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Runtime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Runtime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub layer_specifier: ::std::option::Option<RuntimeLayer_oneof_layer_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer {
    fn default() -> &'a RuntimeLayer {
        <RuntimeLayer as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum RuntimeLayer_oneof_layer_specifier {
    static_layer(::protobuf::well_known_types::Struct),
    disk_layer(RuntimeLayer_DiskLayer),
    admin_layer(RuntimeLayer_AdminLayer),
    rtds_layer(RuntimeLayer_RtdsLayer),
}

impl RuntimeLayer {
    pub fn new() -> RuntimeLayer {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Struct static_layer = 2;


    pub fn get_static_layer(&self) -> &::protobuf::well_known_types::Struct {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(ref v)) => v,
            _ => <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_static_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_static_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_static_layer(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_static_layer(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(::protobuf::well_known_types::Struct::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_static_layer(&mut self) -> ::protobuf::well_known_types::Struct {
        if self.has_static_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            ::protobuf::well_known_types::Struct::new()
        }
    }

    // .envoy.config.bootstrap.v2.RuntimeLayer.DiskLayer disk_layer = 3;


    pub fn get_disk_layer(&self) -> &RuntimeLayer_DiskLayer {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(ref v)) => v,
            _ => <RuntimeLayer_DiskLayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_disk_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_disk_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_disk_layer(&mut self, v: RuntimeLayer_DiskLayer) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_disk_layer(&mut self) -> &mut RuntimeLayer_DiskLayer {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(RuntimeLayer_DiskLayer::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_disk_layer(&mut self) -> RuntimeLayer_DiskLayer {
        if self.has_disk_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeLayer_DiskLayer::new()
        }
    }

    // .envoy.config.bootstrap.v2.RuntimeLayer.AdminLayer admin_layer = 4;


    pub fn get_admin_layer(&self) -> &RuntimeLayer_AdminLayer {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(ref v)) => v,
            _ => <RuntimeLayer_AdminLayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_admin_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_admin_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_admin_layer(&mut self, v: RuntimeLayer_AdminLayer) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_admin_layer(&mut self) -> &mut RuntimeLayer_AdminLayer {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(RuntimeLayer_AdminLayer::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_admin_layer(&mut self) -> RuntimeLayer_AdminLayer {
        if self.has_admin_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeLayer_AdminLayer::new()
        }
    }

    // .envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayer rtds_layer = 5;


    pub fn get_rtds_layer(&self) -> &RuntimeLayer_RtdsLayer {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v)) => v,
            _ => <RuntimeLayer_RtdsLayer as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rtds_layer(&mut self) {
        self.layer_specifier = ::std::option::Option::None;
    }

    pub fn has_rtds_layer(&self) -> bool {
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rtds_layer(&mut self, v: RuntimeLayer_RtdsLayer) {
        self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rtds_layer(&mut self) -> &mut RuntimeLayer_RtdsLayer {
        if let ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(_)) = self.layer_specifier {
        } else {
            self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(RuntimeLayer_RtdsLayer::new()));
        }
        match self.layer_specifier {
            ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rtds_layer(&mut self) -> RuntimeLayer_RtdsLayer {
        if self.has_rtds_layer() {
            match self.layer_specifier.take() {
                ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(v)) => v,
                _ => panic!(),
            }
        } else {
            RuntimeLayer_RtdsLayer::new()
        }
    }
}

impl ::protobuf::Message for RuntimeLayer {
    fn is_initialized(&self) -> bool {
        if let Some(RuntimeLayer_oneof_layer_specifier::static_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RuntimeLayer_oneof_layer_specifier::disk_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RuntimeLayer_oneof_layer_specifier::admin_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v)) = self.layer_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::static_layer(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::disk_layer(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::admin_layer(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.layer_specifier = ::std::option::Option::Some(RuntimeLayer_oneof_layer_specifier::rtds_layer(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.layer_specifier {
            match v {
                &RuntimeLayer_oneof_layer_specifier::static_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RuntimeLayer_oneof_layer_specifier::disk_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RuntimeLayer_oneof_layer_specifier::admin_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.layer_specifier {
            match v {
                &RuntimeLayer_oneof_layer_specifier::static_layer(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RuntimeLayer_oneof_layer_specifier::disk_layer(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RuntimeLayer_oneof_layer_specifier::admin_layer(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &RuntimeLayer_oneof_layer_specifier::rtds_layer(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer {
        RuntimeLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RuntimeLayer| { &m.name },
                |m: &mut RuntimeLayer| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ::protobuf::well_known_types::Struct>(
                "static_layer",
                RuntimeLayer::has_static_layer,
                RuntimeLayer::get_static_layer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeLayer_DiskLayer>(
                "disk_layer",
                RuntimeLayer::has_disk_layer,
                RuntimeLayer::get_disk_layer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeLayer_AdminLayer>(
                "admin_layer",
                RuntimeLayer::has_admin_layer,
                RuntimeLayer::get_admin_layer,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RuntimeLayer_RtdsLayer>(
                "rtds_layer",
                RuntimeLayer::has_rtds_layer,
                RuntimeLayer::get_rtds_layer,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer>(
                "RuntimeLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer {
    fn clear(&mut self) {
        self.name.clear();
        self.layer_specifier = ::std::option::Option::None;
        self.layer_specifier = ::std::option::Option::None;
        self.layer_specifier = ::std::option::Option::None;
        self.layer_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer_DiskLayer {
    // message fields
    pub symlink_root: ::std::string::String,
    pub subdirectory: ::std::string::String,
    pub append_service_cluster: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer_DiskLayer {
    fn default() -> &'a RuntimeLayer_DiskLayer {
        <RuntimeLayer_DiskLayer as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeLayer_DiskLayer {
    pub fn new() -> RuntimeLayer_DiskLayer {
        ::std::default::Default::default()
    }

    // string symlink_root = 1;


    pub fn get_symlink_root(&self) -> &str {
        &self.symlink_root
    }
    pub fn clear_symlink_root(&mut self) {
        self.symlink_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_symlink_root(&mut self, v: ::std::string::String) {
        self.symlink_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_symlink_root(&mut self) -> &mut ::std::string::String {
        &mut self.symlink_root
    }

    // Take field
    pub fn take_symlink_root(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.symlink_root, ::std::string::String::new())
    }

    // string subdirectory = 3;


    pub fn get_subdirectory(&self) -> &str {
        &self.subdirectory
    }
    pub fn clear_subdirectory(&mut self) {
        self.subdirectory.clear();
    }

    // Param is passed by value, moved
    pub fn set_subdirectory(&mut self, v: ::std::string::String) {
        self.subdirectory = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdirectory(&mut self) -> &mut ::std::string::String {
        &mut self.subdirectory
    }

    // Take field
    pub fn take_subdirectory(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subdirectory, ::std::string::String::new())
    }

    // bool append_service_cluster = 2;


    pub fn get_append_service_cluster(&self) -> bool {
        self.append_service_cluster
    }
    pub fn clear_append_service_cluster(&mut self) {
        self.append_service_cluster = false;
    }

    // Param is passed by value, moved
    pub fn set_append_service_cluster(&mut self, v: bool) {
        self.append_service_cluster = v;
    }
}

impl ::protobuf::Message for RuntimeLayer_DiskLayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.symlink_root)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subdirectory)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.append_service_cluster = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.symlink_root.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.symlink_root);
        }
        if !self.subdirectory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subdirectory);
        }
        if self.append_service_cluster != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.symlink_root.is_empty() {
            os.write_string(1, &self.symlink_root)?;
        }
        if !self.subdirectory.is_empty() {
            os.write_string(3, &self.subdirectory)?;
        }
        if self.append_service_cluster != false {
            os.write_bool(2, self.append_service_cluster)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer_DiskLayer {
        RuntimeLayer_DiskLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "symlink_root",
                |m: &RuntimeLayer_DiskLayer| { &m.symlink_root },
                |m: &mut RuntimeLayer_DiskLayer| { &mut m.symlink_root },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subdirectory",
                |m: &RuntimeLayer_DiskLayer| { &m.subdirectory },
                |m: &mut RuntimeLayer_DiskLayer| { &mut m.subdirectory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "append_service_cluster",
                |m: &RuntimeLayer_DiskLayer| { &m.append_service_cluster },
                |m: &mut RuntimeLayer_DiskLayer| { &mut m.append_service_cluster },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer_DiskLayer>(
                "RuntimeLayer.DiskLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer_DiskLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer_DiskLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer_DiskLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer_DiskLayer {
    fn clear(&mut self) {
        self.symlink_root.clear();
        self.subdirectory.clear();
        self.append_service_cluster = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer_DiskLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer_DiskLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer_AdminLayer {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer_AdminLayer {
    fn default() -> &'a RuntimeLayer_AdminLayer {
        <RuntimeLayer_AdminLayer as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeLayer_AdminLayer {
    pub fn new() -> RuntimeLayer_AdminLayer {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RuntimeLayer_AdminLayer {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer_AdminLayer {
        RuntimeLayer_AdminLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer_AdminLayer>(
                "RuntimeLayer.AdminLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer_AdminLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer_AdminLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer_AdminLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer_AdminLayer {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer_AdminLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer_AdminLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RuntimeLayer_RtdsLayer {
    // message fields
    pub name: ::std::string::String,
    pub rtds_config: ::protobuf::SingularPtrField<super::config_source::ConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RuntimeLayer_RtdsLayer {
    fn default() -> &'a RuntimeLayer_RtdsLayer {
        <RuntimeLayer_RtdsLayer as ::protobuf::Message>::default_instance()
    }
}

impl RuntimeLayer_RtdsLayer {
    pub fn new() -> RuntimeLayer_RtdsLayer {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.api.v2.core.ConfigSource rtds_config = 2;


    pub fn get_rtds_config(&self) -> &super::config_source::ConfigSource {
        self.rtds_config.as_ref().unwrap_or_else(|| <super::config_source::ConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rtds_config(&mut self) {
        self.rtds_config.clear();
    }

    pub fn has_rtds_config(&self) -> bool {
        self.rtds_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtds_config(&mut self, v: super::config_source::ConfigSource) {
        self.rtds_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rtds_config(&mut self) -> &mut super::config_source::ConfigSource {
        if self.rtds_config.is_none() {
            self.rtds_config.set_default();
        }
        self.rtds_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_rtds_config(&mut self) -> super::config_source::ConfigSource {
        self.rtds_config.take().unwrap_or_else(|| super::config_source::ConfigSource::new())
    }
}

impl ::protobuf::Message for RuntimeLayer_RtdsLayer {
    fn is_initialized(&self) -> bool {
        for v in &self.rtds_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rtds_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.rtds_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.rtds_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RuntimeLayer_RtdsLayer {
        RuntimeLayer_RtdsLayer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RuntimeLayer_RtdsLayer| { &m.name },
                |m: &mut RuntimeLayer_RtdsLayer| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config_source::ConfigSource>>(
                "rtds_config",
                |m: &RuntimeLayer_RtdsLayer| { &m.rtds_config },
                |m: &mut RuntimeLayer_RtdsLayer| { &mut m.rtds_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RuntimeLayer_RtdsLayer>(
                "RuntimeLayer.RtdsLayer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RuntimeLayer_RtdsLayer {
        static instance: ::protobuf::rt::LazyV2<RuntimeLayer_RtdsLayer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RuntimeLayer_RtdsLayer::new)
    }
}

impl ::protobuf::Clear for RuntimeLayer_RtdsLayer {
    fn clear(&mut self) {
        self.name.clear();
        self.rtds_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RuntimeLayer_RtdsLayer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RuntimeLayer_RtdsLayer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LayeredRuntime {
    // message fields
    pub layers: ::protobuf::RepeatedField<RuntimeLayer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LayeredRuntime {
    fn default() -> &'a LayeredRuntime {
        <LayeredRuntime as ::protobuf::Message>::default_instance()
    }
}

impl LayeredRuntime {
    pub fn new() -> LayeredRuntime {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.bootstrap.v2.RuntimeLayer layers = 1;


    pub fn get_layers(&self) -> &[RuntimeLayer] {
        &self.layers
    }
    pub fn clear_layers(&mut self) {
        self.layers.clear();
    }

    // Param is passed by value, moved
    pub fn set_layers(&mut self, v: ::protobuf::RepeatedField<RuntimeLayer>) {
        self.layers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_layers(&mut self) -> &mut ::protobuf::RepeatedField<RuntimeLayer> {
        &mut self.layers
    }

    // Take field
    pub fn take_layers(&mut self) -> ::protobuf::RepeatedField<RuntimeLayer> {
        ::std::mem::replace(&mut self.layers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LayeredRuntime {
    fn is_initialized(&self) -> bool {
        for v in &self.layers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.layers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.layers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.layers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LayeredRuntime {
        LayeredRuntime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RuntimeLayer>>(
                "layers",
                |m: &LayeredRuntime| { &m.layers },
                |m: &mut LayeredRuntime| { &mut m.layers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LayeredRuntime>(
                "LayeredRuntime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LayeredRuntime {
        static instance: ::protobuf::rt::LazyV2<LayeredRuntime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LayeredRuntime::new)
    }
}

impl ::protobuf::Clear for LayeredRuntime {
    fn clear(&mut self) {
        self.layers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LayeredRuntime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LayeredRuntime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)envoy/config/bootstrap/v2/bootstrap.proto\x12\x19envoy.config.bootstr\
    ap.v2\x1a\x1eenvoy/api/v2/auth/secret.proto\x1a\x1aenvoy/api/v2/cluster.\
    proto\x1a\x1fenvoy/api/v2/core/address.proto\x1a\x1cenvoy/api/v2/core/ba\
    se.proto\x1a%envoy/api/v2/core/config_source.proto\x1a,envoy/api/v2/core\
    /event_service_config.proto\x1a%envoy/api/v2/core/socket_option.proto\
    \x1a\x1benvoy/api/v2/listener.proto\x1a#envoy/config/metrics/v2/stats.pr\
    oto\x1a,envoy/config/overload/v2alpha/overload.proto\x1a'envoy/config/tr\
    ace/v2/http_tracer.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgo\
    ogle/protobuf/struct.proto\x1a\x1egoogle/protobuf/wrappers.proto\x1a#env\
    oy/annotations/deprecation.proto\x1a\x1dudpa/annotations/status.proto\
    \x1a\x17validate/validate.proto\"\xd5\r\n\tBootstrap\x12+\n\x04node\x18\
    \x01\x20\x01(\x0b2\x17.envoy.api.v2.core.NodeR\x04node\x12_\n\x10static_\
    resources\x18\x02\x20\x01(\x0b24.envoy.config.bootstrap.v2.Bootstrap.Sta\
    ticResourcesR\x0fstaticResources\x12b\n\x11dynamic_resources\x18\x03\x20\
    \x01(\x0b25.envoy.config.bootstrap.v2.Bootstrap.DynamicResourcesR\x10dyn\
    amicResources\x12R\n\x0fcluster_manager\x18\x04\x20\x01(\x0b2).envoy.con\
    fig.bootstrap.v2.ClusterManagerR\x0eclusterManager\x12A\n\nhds_config\
    \x18\x0e\x20\x01(\x0b2\".envoy.api.v2.core.ApiConfigSourceR\thdsConfig\
    \x12\x1d\n\nflags_path\x18\x05\x20\x01(\tR\tflagsPath\x12C\n\x0bstats_si\
    nks\x18\x06\x20\x03(\x0b2\".envoy.config.metrics.v2.StatsSinkR\nstatsSin\
    ks\x12G\n\x0cstats_config\x18\r\x20\x01(\x0b2$.envoy.config.metrics.v2.S\
    tatsConfigR\x0bstatsConfig\x12^\n\x14stats_flush_interval\x18\x07\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x12statsFlushIntervalB\x11\xfaB\
    \x0e\xaa\x01\x0b\x1a\x03\x08\xac\x022\x04\x10\xc0\x84=\x12?\n\x08watchdo\
    g\x18\x08\x20\x01(\x0b2#.envoy.config.bootstrap.v2.WatchdogR\x08watchdog\
    \x128\n\x07tracing\x18\t\x20\x01(\x0b2\x1e.envoy.config.trace.v2.Tracing\
    R\x07tracing\x12F\n\x07runtime\x18\x0b\x20\x01(\x0b2\".envoy.config.boot\
    strap.v2.RuntimeR\x07runtimeB\x08\x18\x01\xb8\xee\xf2\xd2\x05\x01\x12R\n\
    \x0flayered_runtime\x18\x11\x20\x01(\x0b2).envoy.config.bootstrap.v2.Lay\
    eredRuntimeR\x0elayeredRuntime\x126\n\x05admin\x18\x0c\x20\x01(\x0b2\x20\
    .envoy.config.bootstrap.v2.AdminR\x05admin\x12Y\n\x10overload_manager\
    \x18\x0f\x20\x01(\x0b2..envoy.config.overload.v2alpha.OverloadManagerR\
    \x0foverloadManager\x126\n\x17enable_dispatcher_stats\x18\x10\x20\x01(\
    \x08R\x15enableDispatcherStats\x12#\n\rheader_prefix\x18\x12\x20\x01(\tR\
    \x0cheaderPrefix\x12_\n\x1dstats_server_version_override\x18\x13\x20\x01\
    (\x0b2\x1c.google.protobuf.UInt64ValueR\x1astatsServerVersionOverride\
    \x124\n\x17use_tcp_for_dns_lookups\x18\x14\x20\x01(\x08R\x13useTcpForDns\
    Lookups\x1a\xaf\x01\n\x0fStaticResources\x124\n\tlisteners\x18\x01\x20\
    \x03(\x0b2\x16.envoy.api.v2.ListenerR\tlisteners\x121\n\x08clusters\x18\
    \x02\x20\x03(\x0b2\x15.envoy.api.v2.ClusterR\x08clusters\x123\n\x07secre\
    ts\x18\x03\x20\x03(\x0b2\x19.envoy.api.v2.auth.SecretR\x07secrets\x1a\
    \xdb\x01\n\x10DynamicResources\x12>\n\nlds_config\x18\x01\x20\x01(\x0b2\
    \x1f.envoy.api.v2.core.ConfigSourceR\tldsConfig\x12>\n\ncds_config\x18\
    \x02\x20\x01(\x0b2\x1f.envoy.api.v2.core.ConfigSourceR\tcdsConfig\x12A\n\
    \nads_config\x18\x03\x20\x01(\x0b2\".envoy.api.v2.core.ApiConfigSourceR\
    \tadsConfigJ\x04\x08\x04\x10\x05J\x04\x08\n\x10\x0b\"\xd0\x01\n\x05Admin\
    \x12&\n\x0faccess_log_path\x18\x01\x20\x01(\tR\raccessLogPath\x12!\n\x0c\
    profile_path\x18\x02\x20\x01(\tR\x0bprofilePath\x124\n\x07address\x18\
    \x03\x20\x01(\x0b2\x1a.envoy.api.v2.core.AddressR\x07address\x12F\n\x0es\
    ocket_options\x18\x04\x20\x03(\x0b2\x1f.envoy.api.v2.core.SocketOptionR\
    \rsocketOptions\"\xcf\x03\n\x0eClusterManager\x12,\n\x12local_cluster_na\
    me\x18\x01\x20\x01(\tR\x10localClusterName\x12g\n\x11outlier_detection\
    \x18\x02\x20\x01(\x0b2:.envoy.config.bootstrap.v2.ClusterManager.Outlier\
    DetectionR\x10outlierDetection\x12O\n\x14upstream_bind_config\x18\x03\
    \x20\x01(\x0b2\x1d.envoy.api.v2.core.BindConfigR\x12upstreamBindConfig\
    \x12N\n\x11load_stats_config\x18\x04\x20\x01(\x0b2\".envoy.api.v2.core.A\
    piConfigSourceR\x0floadStatsConfig\x1a\x84\x01\n\x10OutlierDetection\x12\
    $\n\x0eevent_log_path\x18\x01\x20\x01(\tR\x0ceventLogPath\x12J\n\revent_\
    service\x18\x02\x20\x01(\x0b2%.envoy.api.v2.core.EventServiceConfigR\x0c\
    eventService\"\x94\x02\n\x08Watchdog\x12<\n\x0cmiss_timeout\x18\x01\x20\
    \x01(\x0b2\x19.google.protobuf.DurationR\x0bmissTimeout\x12D\n\x10megami\
    ss_timeout\x18\x02\x20\x01(\x0b2\x19.google.protobuf.DurationR\x0fmegami\
    ssTimeout\x12<\n\x0ckill_timeout\x18\x03\x20\x01(\x0b2\x19.google.protob\
    uf.DurationR\x0bkillTimeout\x12F\n\x11multikill_timeout\x18\x04\x20\x01(\
    \x0b2\x19.google.protobuf.DurationR\x10multikillTimeout\"\xb2\x01\n\x07R\
    untime\x12!\n\x0csymlink_root\x18\x01\x20\x01(\tR\x0bsymlinkRoot\x12\"\n\
    \x0csubdirectory\x18\x02\x20\x01(\tR\x0csubdirectory\x123\n\x15override_\
    subdirectory\x18\x03\x20\x01(\tR\x14overrideSubdirectory\x12+\n\x04base\
    \x18\x04\x20\x01(\x0b2\x17.google.protobuf.StructR\x04base\"\xfc\x04\n\
    \x0cRuntimeLayer\x12\x1b\n\x04name\x18\x01\x20\x01(\tR\x04nameB\x07\xfaB\
    \x04r\x02\x20\x01\x12<\n\x0cstatic_layer\x18\x02\x20\x01(\x0b2\x17.googl\
    e.protobuf.StructH\0R\x0bstaticLayer\x12R\n\ndisk_layer\x18\x03\x20\x01(\
    \x0b21.envoy.config.bootstrap.v2.RuntimeLayer.DiskLayerH\0R\tdiskLayer\
    \x12U\n\x0badmin_layer\x18\x04\x20\x01(\x0b22.envoy.config.bootstrap.v2.\
    RuntimeLayer.AdminLayerH\0R\nadminLayer\x12R\n\nrtds_layer\x18\x05\x20\
    \x01(\x0b21.envoy.config.bootstrap.v2.RuntimeLayer.RtdsLayerH\0R\trtdsLa\
    yer\x1a\x88\x01\n\tDiskLayer\x12!\n\x0csymlink_root\x18\x01\x20\x01(\tR\
    \x0bsymlinkRoot\x12\"\n\x0csubdirectory\x18\x03\x20\x01(\tR\x0csubdirect\
    ory\x124\n\x16append_service_cluster\x18\x02\x20\x01(\x08R\x14appendServ\
    iceCluster\x1a\x0c\n\nAdminLayer\x1aa\n\tRtdsLayer\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12@\n\x0brtds_config\x18\x02\x20\x01(\x0b2\x1f\
    .envoy.api.v2.core.ConfigSourceR\nrtdsConfigB\x16\n\x0flayer_specifier\
    \x12\x03\xf8B\x01\"Q\n\x0eLayeredRuntime\x12?\n\x06layers\x18\x01\x20\
    \x03(\x0b2'.envoy.config.bootstrap.v2.RuntimeLayerR\x06layersBC\n'io.env\
    oyproxy.envoy.config.bootstrap.v2B\x0eBootstrapProtoP\x01\xba\x80\xc8\
    \xd1\x06\x02\x10\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
