// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/rbac/v4alpha/rbac.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct RBAC {
    // message fields
    pub action: RBAC_Action,
    pub policies: ::std::collections::HashMap<::std::string::String, Policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RBAC {
    fn default() -> &'a RBAC {
        <RBAC as ::protobuf::Message>::default_instance()
    }
}

impl RBAC {
    pub fn new() -> RBAC {
        ::std::default::Default::default()
    }

    // .envoy.config.rbac.v4alpha.RBAC.Action action = 1;


    pub fn get_action(&self) -> RBAC_Action {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = RBAC_Action::ALLOW;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RBAC_Action) {
        self.action = v;
    }

    // repeated .envoy.config.rbac.v4alpha.RBAC.PoliciesEntry policies = 2;


    pub fn get_policies(&self) -> &::std::collections::HashMap<::std::string::String, Policy> {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, Policy>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Policy> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, Policy> {
        ::std::mem::replace(&mut self.policies, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for RBAC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != RBAC_Action::ALLOW {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(2, &self.policies);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action != RBAC_Action::ALLOW {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(2, &self.policies, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RBAC {
        RBAC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RBAC_Action>>(
                "action",
                |m: &RBAC| { &m.action },
                |m: &mut RBAC| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                "policies",
                |m: &RBAC| { &m.policies },
                |m: &mut RBAC| { &mut m.policies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RBAC>(
                "RBAC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RBAC {
        static instance: ::protobuf::rt::LazyV2<RBAC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RBAC::new)
    }
}

impl ::protobuf::Clear for RBAC {
    fn clear(&mut self) {
        self.action = RBAC_Action::ALLOW;
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RBAC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBAC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RBAC_Action {
    ALLOW = 0,
    DENY = 1,
    LOG = 2,
}

impl ::protobuf::ProtobufEnum for RBAC_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RBAC_Action> {
        match value {
            0 => ::std::option::Option::Some(RBAC_Action::ALLOW),
            1 => ::std::option::Option::Some(RBAC_Action::DENY),
            2 => ::std::option::Option::Some(RBAC_Action::LOG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RBAC_Action] = &[
            RBAC_Action::ALLOW,
            RBAC_Action::DENY,
            RBAC_Action::LOG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RBAC_Action>("RBAC.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RBAC_Action {
}

impl ::std::default::Default for RBAC_Action {
    fn default() -> Self {
        RBAC_Action::ALLOW
    }
}

impl ::protobuf::reflect::ProtobufValue for RBAC_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Policy {
    // message fields
    pub permissions: ::protobuf::RepeatedField<Permission>,
    pub principals: ::protobuf::RepeatedField<Principal>,
    // message oneof groups
    pub expression_specifier: ::std::option::Option<Policy_oneof_expression_specifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Policy {
    fn default() -> &'a Policy {
        <Policy as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Policy_oneof_expression_specifier {
    condition(super::syntax::Expr),
    checked_condition(super::checked::CheckedExpr),
}

impl Policy {
    pub fn new() -> Policy {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.rbac.v4alpha.Permission permissions = 1;


    pub fn get_permissions(&self) -> &[Permission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<Permission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<Permission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<Permission> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.rbac.v4alpha.Principal principals = 2;


    pub fn get_principals(&self) -> &[Principal] {
        &self.principals
    }
    pub fn clear_principals(&mut self) {
        self.principals.clear();
    }

    // Param is passed by value, moved
    pub fn set_principals(&mut self, v: ::protobuf::RepeatedField<Principal>) {
        self.principals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_principals(&mut self) -> &mut ::protobuf::RepeatedField<Principal> {
        &mut self.principals
    }

    // Take field
    pub fn take_principals(&mut self) -> ::protobuf::RepeatedField<Principal> {
        ::std::mem::replace(&mut self.principals, ::protobuf::RepeatedField::new())
    }

    // .google.api.expr.v1alpha1.Expr condition = 3;


    pub fn get_condition(&self) -> &super::syntax::Expr {
        match self.expression_specifier {
            ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(ref v)) => v,
            _ => <super::syntax::Expr as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_condition(&mut self) {
        self.expression_specifier = ::std::option::Option::None;
    }

    pub fn has_condition(&self) -> bool {
        match self.expression_specifier {
            ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: super::syntax::Expr) {
        self.expression_specifier = ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_condition(&mut self) -> &mut super::syntax::Expr {
        if let ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(_)) = self.expression_specifier {
        } else {
            self.expression_specifier = ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(super::syntax::Expr::new()));
        }
        match self.expression_specifier {
            ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_condition(&mut self) -> super::syntax::Expr {
        if self.has_condition() {
            match self.expression_specifier.take() {
                ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(v)) => v,
                _ => panic!(),
            }
        } else {
            super::syntax::Expr::new()
        }
    }

    // .google.api.expr.v1alpha1.CheckedExpr checked_condition = 4;


    pub fn get_checked_condition(&self) -> &super::checked::CheckedExpr {
        match self.expression_specifier {
            ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(ref v)) => v,
            _ => <super::checked::CheckedExpr as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_checked_condition(&mut self) {
        self.expression_specifier = ::std::option::Option::None;
    }

    pub fn has_checked_condition(&self) -> bool {
        match self.expression_specifier {
            ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_checked_condition(&mut self, v: super::checked::CheckedExpr) {
        self.expression_specifier = ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(v))
    }

    // Mutable pointer to the field.
    pub fn mut_checked_condition(&mut self) -> &mut super::checked::CheckedExpr {
        if let ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(_)) = self.expression_specifier {
        } else {
            self.expression_specifier = ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(super::checked::CheckedExpr::new()));
        }
        match self.expression_specifier {
            ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_checked_condition(&mut self) -> super::checked::CheckedExpr {
        if self.has_checked_condition() {
            match self.expression_specifier.take() {
                ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(v)) => v,
                _ => panic!(),
            }
        } else {
            super::checked::CheckedExpr::new()
        }
    }
}

impl ::protobuf::Message for Policy {
    fn is_initialized(&self) -> bool {
        for v in &self.permissions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.principals {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Policy_oneof_expression_specifier::condition(ref v)) = self.expression_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Policy_oneof_expression_specifier::checked_condition(ref v)) = self.expression_specifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permissions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.principals)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expression_specifier = ::std::option::Option::Some(Policy_oneof_expression_specifier::condition(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.expression_specifier = ::std::option::Option::Some(Policy_oneof_expression_specifier::checked_condition(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.principals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let ::std::option::Option::Some(ref v) = self.expression_specifier {
            match v {
                &Policy_oneof_expression_specifier::condition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Policy_oneof_expression_specifier::checked_condition(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.permissions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.principals {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let ::std::option::Option::Some(ref v) = self.expression_specifier {
            match v {
                &Policy_oneof_expression_specifier::condition(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Policy_oneof_expression_specifier::checked_condition(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Policy {
        Policy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "permissions",
                |m: &Policy| { &m.permissions },
                |m: &mut Policy| { &mut m.permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Principal>>(
                "principals",
                |m: &Policy| { &m.principals },
                |m: &mut Policy| { &mut m.principals },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::syntax::Expr>(
                "condition",
                Policy::has_condition,
                Policy::get_condition,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::checked::CheckedExpr>(
                "checked_condition",
                Policy::has_checked_condition,
                Policy::get_checked_condition,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Policy>(
                "Policy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Policy {
        static instance: ::protobuf::rt::LazyV2<Policy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Policy::new)
    }
}

impl ::protobuf::Clear for Policy {
    fn clear(&mut self) {
        self.permissions.clear();
        self.principals.clear();
        self.expression_specifier = ::std::option::Option::None;
        self.expression_specifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Policy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Policy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Permission {
    // message oneof groups
    pub rule: ::std::option::Option<Permission_oneof_rule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Permission_oneof_rule {
    and_rules(Permission_Set),
    or_rules(Permission_Set),
    any(bool),
    header(super::route_components::HeaderMatcher),
    url_path(super::path::PathMatcher),
    destination_ip(super::address::CidrRange),
    destination_port(u32),
    metadata(super::metadata::MetadataMatcher),
    not_rule(::std::boxed::Box<Permission>),
    requested_server_name(super::string::StringMatcher),
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    // .envoy.config.rbac.v4alpha.Permission.Set and_rules = 1;


    pub fn get_and_rules(&self) -> &Permission_Set {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::and_rules(ref v)) => v,
            _ => <Permission_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_and_rules(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_and_rules(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::and_rules(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_rules(&mut self, v: Permission_Set) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::and_rules(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_rules(&mut self) -> &mut Permission_Set {
        if let ::std::option::Option::Some(Permission_oneof_rule::and_rules(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::and_rules(Permission_Set::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::and_rules(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_rules(&mut self) -> Permission_Set {
        if self.has_and_rules() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::and_rules(v)) => v,
                _ => panic!(),
            }
        } else {
            Permission_Set::new()
        }
    }

    // .envoy.config.rbac.v4alpha.Permission.Set or_rules = 2;


    pub fn get_or_rules(&self) -> &Permission_Set {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::or_rules(ref v)) => v,
            _ => <Permission_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_or_rules(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_or_rules(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::or_rules(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_rules(&mut self, v: Permission_Set) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::or_rules(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_rules(&mut self) -> &mut Permission_Set {
        if let ::std::option::Option::Some(Permission_oneof_rule::or_rules(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::or_rules(Permission_Set::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::or_rules(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_rules(&mut self) -> Permission_Set {
        if self.has_or_rules() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::or_rules(v)) => v,
                _ => panic!(),
            }
        } else {
            Permission_Set::new()
        }
    }

    // bool any = 3;


    pub fn get_any(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::any(v)) => v,
            _ => false,
        }
    }
    pub fn clear_any(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::any(v))
    }

    // .envoy.config.route.v4alpha.HeaderMatcher header = 4;


    pub fn get_header(&self) -> &super::route_components::HeaderMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::header(ref v)) => v,
            _ => <super::route_components::HeaderMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: super::route_components::HeaderMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut super::route_components::HeaderMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::header(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::header(super::route_components::HeaderMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> super::route_components::HeaderMatcher {
        if self.has_header() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::header(v)) => v,
                _ => panic!(),
            }
        } else {
            super::route_components::HeaderMatcher::new()
        }
    }

    // .envoy.type.matcher.v4alpha.PathMatcher url_path = 10;


    pub fn get_url_path(&self) -> &super::path::PathMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::url_path(ref v)) => v,
            _ => <super::path::PathMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_url_path(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_url_path(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::url_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url_path(&mut self, v: super::path::PathMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::url_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url_path(&mut self) -> &mut super::path::PathMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::url_path(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::url_path(super::path::PathMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::url_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url_path(&mut self) -> super::path::PathMatcher {
        if self.has_url_path() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::url_path(v)) => v,
                _ => panic!(),
            }
        } else {
            super::path::PathMatcher::new()
        }
    }

    // .envoy.config.core.v4alpha.CidrRange destination_ip = 5;


    pub fn get_destination_ip(&self) -> &super::address::CidrRange {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_destination_ip(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_destination_ip(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination_ip(&mut self, v: super::address::CidrRange) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destination_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Permission_oneof_rule::destination_ip(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_ip(super::address::CidrRange::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destination_ip(&mut self) -> super::address::CidrRange {
        if self.has_destination_ip() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::destination_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // uint32 destination_port = 6;


    pub fn get_destination_port(&self) -> u32 {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_port(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_destination_port(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_destination_port(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_port(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination_port(&mut self, v: u32) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_port(v))
    }

    // .envoy.type.matcher.v4alpha.MetadataMatcher metadata = 7;


    pub fn get_metadata(&self) -> &super::metadata::MetadataMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::metadata(ref v)) => v,
            _ => <super::metadata::MetadataMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metadata(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::metadata::MetadataMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut super::metadata::MetadataMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::metadata(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::metadata(super::metadata::MetadataMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::metadata::MetadataMatcher {
        if self.has_metadata() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            super::metadata::MetadataMatcher::new()
        }
    }

    // .envoy.config.rbac.v4alpha.Permission not_rule = 8;


    pub fn get_not_rule(&self) -> &Permission {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::not_rule(ref v)) => v,
            _ => <Permission as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_not_rule(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_not_rule(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::not_rule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_rule(&mut self, v: Permission) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::not_rule(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_rule(&mut self) -> &mut Permission {
        if let ::std::option::Option::Some(Permission_oneof_rule::not_rule(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::not_rule(::std::boxed::Box::new(Permission::new())));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::not_rule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_rule(&mut self) -> Permission {
        if self.has_not_rule() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::not_rule(v)) => *v,
                _ => panic!(),
            }
        } else {
            Permission::new()
        }
    }

    // .envoy.type.matcher.v4alpha.StringMatcher requested_server_name = 9;


    pub fn get_requested_server_name(&self) -> &super::string::StringMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(ref v)) => v,
            _ => <super::string::StringMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_requested_server_name(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_requested_server_name(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_requested_server_name(&mut self, v: super::string::StringMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_requested_server_name(&mut self) -> &mut super::string::StringMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(super::string::StringMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_requested_server_name(&mut self) -> super::string::StringMatcher {
        if self.has_requested_server_name() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(v)) => v,
                _ => panic!(),
            }
        } else {
            super::string::StringMatcher::new()
        }
    }
}

impl ::protobuf::Message for Permission {
    fn is_initialized(&self) -> bool {
        if let Some(Permission_oneof_rule::and_rules(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::or_rules(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::header(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::url_path(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::destination_ip(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::metadata(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::not_rule(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::requested_server_name(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::and_rules(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::or_rules(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::any(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::header(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::url_path(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_ip(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_port(is.read_uint32()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::metadata(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::not_rule(::std::boxed::Box::new(is.read_message()?)));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &Permission_oneof_rule::and_rules(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::or_rules(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::any(v) => {
                    my_size += 2;
                },
                &Permission_oneof_rule::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::url_path(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::destination_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::destination_port(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Permission_oneof_rule::metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::not_rule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::requested_server_name(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &Permission_oneof_rule::and_rules(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::or_rules(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::any(v) => {
                    os.write_bool(3, v)?;
                },
                &Permission_oneof_rule::header(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::url_path(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::destination_ip(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::destination_port(v) => {
                    os.write_uint32(6, v)?;
                },
                &Permission_oneof_rule::metadata(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::not_rule(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::requested_server_name(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Permission_Set>(
                "and_rules",
                Permission::has_and_rules,
                Permission::get_and_rules,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Permission_Set>(
                "or_rules",
                Permission::has_or_rules,
                Permission::get_or_rules,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "any",
                Permission::has_any,
                Permission::get_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::route_components::HeaderMatcher>(
                "header",
                Permission::has_header,
                Permission::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::path::PathMatcher>(
                "url_path",
                Permission::has_url_path,
                Permission::get_url_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "destination_ip",
                Permission::has_destination_ip,
                Permission::get_destination_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "destination_port",
                Permission::has_destination_port,
                Permission::get_destination_port,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::metadata::MetadataMatcher>(
                "metadata",
                Permission::has_metadata,
                Permission::get_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Permission>(
                "not_rule",
                Permission::has_not_rule,
                Permission::get_not_rule,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::string::StringMatcher>(
                "requested_server_name",
                Permission::has_requested_server_name,
                Permission::get_requested_server_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Permission>(
                "Permission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Permission {
        static instance: ::protobuf::rt::LazyV2<Permission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Permission::new)
    }
}

impl ::protobuf::Clear for Permission {
    fn clear(&mut self) {
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Permission_Set {
    // message fields
    pub rules: ::protobuf::RepeatedField<Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Permission_Set {
    fn default() -> &'a Permission_Set {
        <Permission_Set as ::protobuf::Message>::default_instance()
    }
}

impl Permission_Set {
    pub fn new() -> Permission_Set {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.rbac.v4alpha.Permission rules = 1;


    pub fn get_rules(&self) -> &[Permission] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<Permission>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<Permission> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<Permission> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Permission_Set {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Permission_Set {
        Permission_Set::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "rules",
                |m: &Permission_Set| { &m.rules },
                |m: &mut Permission_Set| { &mut m.rules },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Permission_Set>(
                "Permission.Set",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Permission_Set {
        static instance: ::protobuf::rt::LazyV2<Permission_Set> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Permission_Set::new)
    }
}

impl ::protobuf::Clear for Permission_Set {
    fn clear(&mut self) {
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Permission_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission_Set {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Principal {
    // message oneof groups
    pub identifier: ::std::option::Option<Principal_oneof_identifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Principal {
    fn default() -> &'a Principal {
        <Principal as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Principal_oneof_identifier {
    and_ids(Principal_Set),
    or_ids(Principal_Set),
    any(bool),
    authenticated(Principal_Authenticated),
    direct_remote_ip(super::address::CidrRange),
    remote_ip(super::address::CidrRange),
    header(super::route_components::HeaderMatcher),
    url_path(super::path::PathMatcher),
    metadata(super::metadata::MetadataMatcher),
    not_id(::std::boxed::Box<Principal>),
}

impl Principal {
    pub fn new() -> Principal {
        ::std::default::Default::default()
    }

    // .envoy.config.rbac.v4alpha.Principal.Set and_ids = 1;


    pub fn get_and_ids(&self) -> &Principal_Set {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::and_ids(ref v)) => v,
            _ => <Principal_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_and_ids(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_and_ids(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::and_ids(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_ids(&mut self, v: Principal_Set) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::and_ids(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_ids(&mut self) -> &mut Principal_Set {
        if let ::std::option::Option::Some(Principal_oneof_identifier::and_ids(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::and_ids(Principal_Set::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::and_ids(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_ids(&mut self) -> Principal_Set {
        if self.has_and_ids() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::and_ids(v)) => v,
                _ => panic!(),
            }
        } else {
            Principal_Set::new()
        }
    }

    // .envoy.config.rbac.v4alpha.Principal.Set or_ids = 2;


    pub fn get_or_ids(&self) -> &Principal_Set {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::or_ids(ref v)) => v,
            _ => <Principal_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_or_ids(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_or_ids(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::or_ids(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_ids(&mut self, v: Principal_Set) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::or_ids(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_ids(&mut self) -> &mut Principal_Set {
        if let ::std::option::Option::Some(Principal_oneof_identifier::or_ids(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::or_ids(Principal_Set::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::or_ids(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_ids(&mut self) -> Principal_Set {
        if self.has_or_ids() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::or_ids(v)) => v,
                _ => panic!(),
            }
        } else {
            Principal_Set::new()
        }
    }

    // bool any = 3;


    pub fn get_any(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::any(v)) => v,
            _ => false,
        }
    }
    pub fn clear_any(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::any(v))
    }

    // .envoy.config.rbac.v4alpha.Principal.Authenticated authenticated = 4;


    pub fn get_authenticated(&self) -> &Principal_Authenticated {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::authenticated(ref v)) => v,
            _ => <Principal_Authenticated as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_authenticated(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_authenticated(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::authenticated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: Principal_Authenticated) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::authenticated(v))
    }

    // Mutable pointer to the field.
    pub fn mut_authenticated(&mut self) -> &mut Principal_Authenticated {
        if let ::std::option::Option::Some(Principal_oneof_identifier::authenticated(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::authenticated(Principal_Authenticated::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::authenticated(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_authenticated(&mut self) -> Principal_Authenticated {
        if self.has_authenticated() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::authenticated(v)) => v,
                _ => panic!(),
            }
        } else {
            Principal_Authenticated::new()
        }
    }

    // .envoy.config.core.v4alpha.CidrRange direct_remote_ip = 10;


    pub fn get_direct_remote_ip(&self) -> &super::address::CidrRange {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_direct_remote_ip(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_direct_remote_ip(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_remote_ip(&mut self, v: super::address::CidrRange) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_remote_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(super::address::CidrRange::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_remote_ip(&mut self) -> super::address::CidrRange {
        if self.has_direct_remote_ip() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // .envoy.config.core.v4alpha.CidrRange remote_ip = 11;


    pub fn get_remote_ip(&self) -> &super::address::CidrRange {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote_ip(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_remote_ip(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote_ip(&mut self, v: super::address::CidrRange) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(super::address::CidrRange::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote_ip(&mut self) -> super::address::CidrRange {
        if self.has_remote_ip() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // .envoy.config.route.v4alpha.HeaderMatcher header = 6;


    pub fn get_header(&self) -> &super::route_components::HeaderMatcher {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::header(ref v)) => v,
            _ => <super::route_components::HeaderMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: super::route_components::HeaderMatcher) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut super::route_components::HeaderMatcher {
        if let ::std::option::Option::Some(Principal_oneof_identifier::header(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::header(super::route_components::HeaderMatcher::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> super::route_components::HeaderMatcher {
        if self.has_header() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::header(v)) => v,
                _ => panic!(),
            }
        } else {
            super::route_components::HeaderMatcher::new()
        }
    }

    // .envoy.type.matcher.v4alpha.PathMatcher url_path = 9;


    pub fn get_url_path(&self) -> &super::path::PathMatcher {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::url_path(ref v)) => v,
            _ => <super::path::PathMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_url_path(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_url_path(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::url_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url_path(&mut self, v: super::path::PathMatcher) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::url_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url_path(&mut self) -> &mut super::path::PathMatcher {
        if let ::std::option::Option::Some(Principal_oneof_identifier::url_path(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::url_path(super::path::PathMatcher::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::url_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url_path(&mut self) -> super::path::PathMatcher {
        if self.has_url_path() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::url_path(v)) => v,
                _ => panic!(),
            }
        } else {
            super::path::PathMatcher::new()
        }
    }

    // .envoy.type.matcher.v4alpha.MetadataMatcher metadata = 7;


    pub fn get_metadata(&self) -> &super::metadata::MetadataMatcher {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::metadata(ref v)) => v,
            _ => <super::metadata::MetadataMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metadata(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::metadata::MetadataMatcher) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut super::metadata::MetadataMatcher {
        if let ::std::option::Option::Some(Principal_oneof_identifier::metadata(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::metadata(super::metadata::MetadataMatcher::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::metadata::MetadataMatcher {
        if self.has_metadata() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            super::metadata::MetadataMatcher::new()
        }
    }

    // .envoy.config.rbac.v4alpha.Principal not_id = 8;


    pub fn get_not_id(&self) -> &Principal {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::not_id(ref v)) => v,
            _ => <Principal as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_not_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_not_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::not_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_id(&mut self, v: Principal) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::not_id(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_id(&mut self) -> &mut Principal {
        if let ::std::option::Option::Some(Principal_oneof_identifier::not_id(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::not_id(::std::boxed::Box::new(Principal::new())));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::not_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_id(&mut self) -> Principal {
        if self.has_not_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::not_id(v)) => *v,
                _ => panic!(),
            }
        } else {
            Principal::new()
        }
    }
}

impl ::protobuf::Message for Principal {
    fn is_initialized(&self) -> bool {
        if let Some(Principal_oneof_identifier::and_ids(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::or_ids(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::authenticated(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::direct_remote_ip(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::remote_ip(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::header(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::url_path(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::metadata(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::not_id(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::and_ids(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::or_ids(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::any(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::authenticated(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::header(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::url_path(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::metadata(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::not_id(::std::boxed::Box::new(is.read_message()?)));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &Principal_oneof_identifier::and_ids(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::or_ids(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::any(v) => {
                    my_size += 2;
                },
                &Principal_oneof_identifier::authenticated(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::direct_remote_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::remote_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::url_path(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::not_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &Principal_oneof_identifier::and_ids(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::or_ids(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::any(v) => {
                    os.write_bool(3, v)?;
                },
                &Principal_oneof_identifier::authenticated(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::direct_remote_ip(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::remote_ip(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::header(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::url_path(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::metadata(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::not_id(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Principal {
        Principal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal_Set>(
                "and_ids",
                Principal::has_and_ids,
                Principal::get_and_ids,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal_Set>(
                "or_ids",
                Principal::has_or_ids,
                Principal::get_or_ids,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "any",
                Principal::has_any,
                Principal::get_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal_Authenticated>(
                "authenticated",
                Principal::has_authenticated,
                Principal::get_authenticated,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "direct_remote_ip",
                Principal::has_direct_remote_ip,
                Principal::get_direct_remote_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "remote_ip",
                Principal::has_remote_ip,
                Principal::get_remote_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::route_components::HeaderMatcher>(
                "header",
                Principal::has_header,
                Principal::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::path::PathMatcher>(
                "url_path",
                Principal::has_url_path,
                Principal::get_url_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::metadata::MetadataMatcher>(
                "metadata",
                Principal::has_metadata,
                Principal::get_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal>(
                "not_id",
                Principal::has_not_id,
                Principal::get_not_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Principal>(
                "Principal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Principal {
        static instance: ::protobuf::rt::LazyV2<Principal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Principal::new)
    }
}

impl ::protobuf::Clear for Principal {
    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Principal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Principal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Principal_Set {
    // message fields
    pub ids: ::protobuf::RepeatedField<Principal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Principal_Set {
    fn default() -> &'a Principal_Set {
        <Principal_Set as ::protobuf::Message>::default_instance()
    }
}

impl Principal_Set {
    pub fn new() -> Principal_Set {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.rbac.v4alpha.Principal ids = 1;


    pub fn get_ids(&self) -> &[Principal] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<Principal>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<Principal> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<Principal> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Principal_Set {
    fn is_initialized(&self) -> bool {
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Principal_Set {
        Principal_Set::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Principal>>(
                "ids",
                |m: &Principal_Set| { &m.ids },
                |m: &mut Principal_Set| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Principal_Set>(
                "Principal.Set",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Principal_Set {
        static instance: ::protobuf::rt::LazyV2<Principal_Set> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Principal_Set::new)
    }
}

impl ::protobuf::Clear for Principal_Set {
    fn clear(&mut self) {
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Principal_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Principal_Set {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Principal_Authenticated {
    // message fields
    pub principal_name: ::protobuf::SingularPtrField<super::string::StringMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Principal_Authenticated {
    fn default() -> &'a Principal_Authenticated {
        <Principal_Authenticated as ::protobuf::Message>::default_instance()
    }
}

impl Principal_Authenticated {
    pub fn new() -> Principal_Authenticated {
        ::std::default::Default::default()
    }

    // .envoy.type.matcher.v4alpha.StringMatcher principal_name = 2;


    pub fn get_principal_name(&self) -> &super::string::StringMatcher {
        self.principal_name.as_ref().unwrap_or_else(|| <super::string::StringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_principal_name(&mut self) {
        self.principal_name.clear();
    }

    pub fn has_principal_name(&self) -> bool {
        self.principal_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal_name(&mut self, v: super::string::StringMatcher) {
        self.principal_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal_name(&mut self) -> &mut super::string::StringMatcher {
        if self.principal_name.is_none() {
            self.principal_name.set_default();
        }
        self.principal_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal_name(&mut self) -> super::string::StringMatcher {
        self.principal_name.take().unwrap_or_else(|| super::string::StringMatcher::new())
    }
}

impl ::protobuf::Message for Principal_Authenticated {
    fn is_initialized(&self) -> bool {
        for v in &self.principal_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.principal_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.principal_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.principal_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Principal_Authenticated {
        Principal_Authenticated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::StringMatcher>>(
                "principal_name",
                |m: &Principal_Authenticated| { &m.principal_name },
                |m: &mut Principal_Authenticated| { &mut m.principal_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Principal_Authenticated>(
                "Principal.Authenticated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Principal_Authenticated {
        static instance: ::protobuf::rt::LazyV2<Principal_Authenticated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Principal_Authenticated::new)
    }
}

impl ::protobuf::Clear for Principal_Authenticated {
    fn clear(&mut self) {
        self.principal_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Principal_Authenticated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Principal_Authenticated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n$envoy/config/rbac/v4alpha/rbac.proto\x12\x19envoy.config.rbac.v4alpha\
    \x1a'envoy/config/core/v4alpha/address.proto\x1a1envoy/config/route/v4al\
    pha/route_components.proto\x1a)envoy/type/matcher/v4alpha/metadata.proto\
    \x1a%envoy/type/matcher/v4alpha/path.proto\x1a'envoy/type/matcher/v4alph\
    a/string.proto\x1a&google/api/expr/v1alpha1/checked.proto\x1a%google/api\
    /expr/v1alpha1/syntax.proto\x1a\x1dudpa/annotations/status.proto\x1a!udp\
    a/annotations/versioning.proto\x1a\x17validate/validate.proto\"\xc5\x02\
    \n\x04RBAC\x12H\n\x06action\x18\x01\x20\x01(\x0e2&.envoy.config.rbac.v4a\
    lpha.RBAC.ActionR\x06actionB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12I\n\x08\
    policies\x18\x02\x20\x03(\x0b2-.envoy.config.rbac.v4alpha.RBAC.PoliciesE\
    ntryR\x08policies\x1a^\n\rPoliciesEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\tR\x03key\x127\n\x05value\x18\x02\x20\x01(\x0b2!.envoy.config.rbac.v4a\
    lpha.PolicyR\x05value:\x028\x01\"&\n\x06Action\x12\t\n\x05ALLOW\x10\0\
    \x12\x08\n\x04DENY\x10\x01\x12\x07\n\x03LOG\x10\x02:\x20\x9a\xc5\x88\x1e\
    \x1b\n\x19envoy.config.rbac.v3.RBAC\"\xfd\x02\n\x06Policy\x12Q\n\x0bperm\
    issions\x18\x01\x20\x03(\x0b2%.envoy.config.rbac.v4alpha.PermissionR\x0b\
    permissionsB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12N\n\nprincipals\x18\x02\
    \x20\x03(\x0b2$.envoy.config.rbac.v4alpha.PrincipalR\nprincipalsB\x08\
    \xfaB\x05\x92\x01\x02\x08\x01\x12>\n\tcondition\x18\x03\x20\x01(\x0b2\
    \x1e.google.api.expr.v1alpha1.ExprH\0R\tcondition\x12T\n\x11checked_cond\
    ition\x18\x04\x20\x01(\x0b2%.google.api.expr.v1alpha1.CheckedExprH\0R\
    \x10checkedConditionB\x16\n\x14expression_specifier:\"\x9a\xc5\x88\x1e\
    \x1d\n\x1benvoy.config.rbac.v3.Policy\"\xec\x06\n\nPermission\x12H\n\tan\
    d_rules\x18\x01\x20\x01(\x0b2).envoy.config.rbac.v4alpha.Permission.SetH\
    \0R\x08andRules\x12F\n\x08or_rules\x18\x02\x20\x01(\x0b2).envoy.config.r\
    bac.v4alpha.Permission.SetH\0R\x07orRules\x12\x1b\n\x03any\x18\x03\x20\
    \x01(\x08H\0R\x03anyB\x07\xfaB\x04j\x02\x08\x01\x12C\n\x06header\x18\x04\
    \x20\x01(\x0b2).envoy.config.route.v4alpha.HeaderMatcherH\0R\x06header\
    \x12D\n\x08url_path\x18\n\x20\x01(\x0b2'.envoy.type.matcher.v4alpha.Path\
    MatcherH\0R\x07urlPath\x12M\n\x0edestination_ip\x18\x05\x20\x01(\x0b2$.e\
    nvoy.config.core.v4alpha.CidrRangeH\0R\rdestinationIp\x126\n\x10destinat\
    ion_port\x18\x06\x20\x01(\rH\0R\x0fdestinationPortB\t\xfaB\x06*\x04\x18\
    \xff\xff\x03\x12I\n\x08metadata\x18\x07\x20\x01(\x0b2+.envoy.type.matche\
    r.v4alpha.MetadataMatcherH\0R\x08metadata\x12B\n\x08not_rule\x18\x08\x20\
    \x01(\x0b2%.envoy.config.rbac.v4alpha.PermissionH\0R\x07notRule\x12_\n\
    \x15requested_server_name\x18\t\x20\x01(\x0b2).envoy.type.matcher.v4alph\
    a.StringMatcherH\0R\x13requestedServerName\x1ax\n\x03Set\x12E\n\x05rules\
    \x18\x01\x20\x03(\x0b2%.envoy.config.rbac.v4alpha.PermissionR\x05rulesB\
    \x08\xfaB\x05\x92\x01\x02\x08\x01:*\x9a\xc5\x88\x1e%\n#envoy.config.rbac\
    .v3.Permission.SetB\x0b\n\x04rule\x12\x03\xf8B\x01:&\x9a\xc5\x88\x1e!\n\
    \x1fenvoy.config.rbac.v3.Permission\"\x96\x08\n\tPrincipal\x12C\n\x07and\
    _ids\x18\x01\x20\x01(\x0b2(.envoy.config.rbac.v4alpha.Principal.SetH\0R\
    \x06andIds\x12A\n\x06or_ids\x18\x02\x20\x01(\x0b2(.envoy.config.rbac.v4a\
    lpha.Principal.SetH\0R\x05orIds\x12\x1b\n\x03any\x18\x03\x20\x01(\x08H\0\
    R\x03anyB\x07\xfaB\x04j\x02\x08\x01\x12Z\n\rauthenticated\x18\x04\x20\
    \x01(\x0b22.envoy.config.rbac.v4alpha.Principal.AuthenticatedH\0R\rauthe\
    nticated\x12P\n\x10direct_remote_ip\x18\n\x20\x01(\x0b2$.envoy.config.co\
    re.v4alpha.CidrRangeH\0R\x0edirectRemoteIp\x12C\n\tremote_ip\x18\x0b\x20\
    \x01(\x0b2$.envoy.config.core.v4alpha.CidrRangeH\0R\x08remoteIp\x12C\n\
    \x06header\x18\x06\x20\x01(\x0b2).envoy.config.route.v4alpha.HeaderMatch\
    erH\0R\x06header\x12D\n\x08url_path\x18\t\x20\x01(\x0b2'.envoy.type.matc\
    her.v4alpha.PathMatcherH\0R\x07urlPath\x12I\n\x08metadata\x18\x07\x20\
    \x01(\x0b2+.envoy.type.matcher.v4alpha.MetadataMatcherH\0R\x08metadata\
    \x12=\n\x06not_id\x18\x08\x20\x01(\x0b2$.envoy.config.rbac.v4alpha.Princ\
    ipalH\0R\x05notId\x1ar\n\x03Set\x12@\n\x03ids\x18\x01\x20\x03(\x0b2$.env\
    oy.config.rbac.v4alpha.PrincipalR\x03idsB\x08\xfaB\x05\x92\x01\x02\x08\
    \x01:)\x9a\xc5\x88\x1e$\n\"envoy.config.rbac.v3.Principal.Set\x1a\x9c\
    \x01\n\rAuthenticated\x12P\n\x0eprincipal_name\x18\x02\x20\x01(\x0b2).en\
    voy.type.matcher.v4alpha.StringMatcherR\rprincipalName:3\x9a\xc5\x88\x1e\
    .\n,envoy.config.rbac.v3.Principal.AuthenticatedJ\x04\x08\x01\x10\x02B\
    \x11\n\nidentifier\x12\x03\xf8B\x01:%\x9a\xc5\x88\x1e\x20\n\x1eenvoy.con\
    fig.rbac.v3.PrincipalJ\x04\x08\x05\x10\x06R\tsource_ipB>\n'io.envoyproxy\
    .envoy.config.rbac.v4alphaB\tRbacProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\
    \x03b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
