// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/config/rbac/v3/rbac.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct RBAC {
    // message fields
    pub action: RBAC_Action,
    pub policies: ::std::collections::HashMap<::std::string::String, Policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RBAC {
    fn default() -> &'a RBAC {
        <RBAC as ::protobuf::Message>::default_instance()
    }
}

impl RBAC {
    pub fn new() -> RBAC {
        ::std::default::Default::default()
    }

    // .envoy.config.rbac.v3.RBAC.Action action = 1;


    pub fn get_action(&self) -> RBAC_Action {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = RBAC_Action::ALLOW;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: RBAC_Action) {
        self.action = v;
    }

    // repeated .envoy.config.rbac.v3.RBAC.PoliciesEntry policies = 2;


    pub fn get_policies(&self) -> &::std::collections::HashMap<::std::string::String, Policy> {
        &self.policies
    }
    pub fn clear_policies(&mut self) {
        self.policies.clear();
    }

    // Param is passed by value, moved
    pub fn set_policies(&mut self, v: ::std::collections::HashMap<::std::string::String, Policy>) {
        self.policies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_policies(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, Policy> {
        &mut self.policies
    }

    // Take field
    pub fn take_policies(&mut self) -> ::std::collections::HashMap<::std::string::String, Policy> {
        ::std::mem::replace(&mut self.policies, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for RBAC {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(wire_type, is, &mut self.policies)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.action != RBAC_Action::ALLOW {
            my_size += ::protobuf::rt::enum_size(1, self.action);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(2, &self.policies);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.action != RBAC_Action::ALLOW {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(2, &self.policies, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RBAC {
        RBAC::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<RBAC_Action>>(
                "action",
                |m: &RBAC| { &m.action },
                |m: &mut RBAC| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<Policy>>(
                "policies",
                |m: &RBAC| { &m.policies },
                |m: &mut RBAC| { &mut m.policies },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RBAC>(
                "RBAC",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RBAC {
        static instance: ::protobuf::rt::LazyV2<RBAC> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RBAC::new)
    }
}

impl ::protobuf::Clear for RBAC {
    fn clear(&mut self) {
        self.action = RBAC_Action::ALLOW;
        self.policies.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RBAC {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBAC {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RBAC_Action {
    ALLOW = 0,
    DENY = 1,
    LOG = 2,
}

impl ::protobuf::ProtobufEnum for RBAC_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RBAC_Action> {
        match value {
            0 => ::std::option::Option::Some(RBAC_Action::ALLOW),
            1 => ::std::option::Option::Some(RBAC_Action::DENY),
            2 => ::std::option::Option::Some(RBAC_Action::LOG),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RBAC_Action] = &[
            RBAC_Action::ALLOW,
            RBAC_Action::DENY,
            RBAC_Action::LOG,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RBAC_Action>("RBAC.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RBAC_Action {
}

impl ::std::default::Default for RBAC_Action {
    fn default() -> Self {
        RBAC_Action::ALLOW
    }
}

impl ::protobuf::reflect::ProtobufValue for RBAC_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Policy {
    // message fields
    pub permissions: ::protobuf::RepeatedField<Permission>,
    pub principals: ::protobuf::RepeatedField<Principal>,
    pub condition: ::protobuf::SingularPtrField<super::syntax::Expr>,
    pub checked_condition: ::protobuf::SingularPtrField<super::checked::CheckedExpr>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Policy {
    fn default() -> &'a Policy {
        <Policy as ::protobuf::Message>::default_instance()
    }
}

impl Policy {
    pub fn new() -> Policy {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.rbac.v3.Permission permissions = 1;


    pub fn get_permissions(&self) -> &[Permission] {
        &self.permissions
    }
    pub fn clear_permissions(&mut self) {
        self.permissions.clear();
    }

    // Param is passed by value, moved
    pub fn set_permissions(&mut self, v: ::protobuf::RepeatedField<Permission>) {
        self.permissions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_permissions(&mut self) -> &mut ::protobuf::RepeatedField<Permission> {
        &mut self.permissions
    }

    // Take field
    pub fn take_permissions(&mut self) -> ::protobuf::RepeatedField<Permission> {
        ::std::mem::replace(&mut self.permissions, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.config.rbac.v3.Principal principals = 2;


    pub fn get_principals(&self) -> &[Principal] {
        &self.principals
    }
    pub fn clear_principals(&mut self) {
        self.principals.clear();
    }

    // Param is passed by value, moved
    pub fn set_principals(&mut self, v: ::protobuf::RepeatedField<Principal>) {
        self.principals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_principals(&mut self) -> &mut ::protobuf::RepeatedField<Principal> {
        &mut self.principals
    }

    // Take field
    pub fn take_principals(&mut self) -> ::protobuf::RepeatedField<Principal> {
        ::std::mem::replace(&mut self.principals, ::protobuf::RepeatedField::new())
    }

    // .google.api.expr.v1alpha1.Expr condition = 3;


    pub fn get_condition(&self) -> &super::syntax::Expr {
        self.condition.as_ref().unwrap_or_else(|| <super::syntax::Expr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_condition(&mut self) {
        self.condition.clear();
    }

    pub fn has_condition(&self) -> bool {
        self.condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_condition(&mut self, v: super::syntax::Expr) {
        self.condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_condition(&mut self) -> &mut super::syntax::Expr {
        if self.condition.is_none() {
            self.condition.set_default();
        }
        self.condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_condition(&mut self) -> super::syntax::Expr {
        self.condition.take().unwrap_or_else(|| super::syntax::Expr::new())
    }

    // .google.api.expr.v1alpha1.CheckedExpr checked_condition = 4;


    pub fn get_checked_condition(&self) -> &super::checked::CheckedExpr {
        self.checked_condition.as_ref().unwrap_or_else(|| <super::checked::CheckedExpr as ::protobuf::Message>::default_instance())
    }
    pub fn clear_checked_condition(&mut self) {
        self.checked_condition.clear();
    }

    pub fn has_checked_condition(&self) -> bool {
        self.checked_condition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_checked_condition(&mut self, v: super::checked::CheckedExpr) {
        self.checked_condition = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_checked_condition(&mut self) -> &mut super::checked::CheckedExpr {
        if self.checked_condition.is_none() {
            self.checked_condition.set_default();
        }
        self.checked_condition.as_mut().unwrap()
    }

    // Take field
    pub fn take_checked_condition(&mut self) -> super::checked::CheckedExpr {
        self.checked_condition.take().unwrap_or_else(|| super::checked::CheckedExpr::new())
    }
}

impl ::protobuf::Message for Policy {
    fn is_initialized(&self) -> bool {
        for v in &self.permissions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.principals {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.condition {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.checked_condition {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.permissions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.principals)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.condition)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.checked_condition)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.permissions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.principals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.checked_condition.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.permissions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.principals {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.condition.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.checked_condition.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Policy {
        Policy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "permissions",
                |m: &Policy| { &m.permissions },
                |m: &mut Policy| { &mut m.permissions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Principal>>(
                "principals",
                |m: &Policy| { &m.principals },
                |m: &mut Policy| { &mut m.principals },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::syntax::Expr>>(
                "condition",
                |m: &Policy| { &m.condition },
                |m: &mut Policy| { &mut m.condition },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::checked::CheckedExpr>>(
                "checked_condition",
                |m: &Policy| { &m.checked_condition },
                |m: &mut Policy| { &mut m.checked_condition },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Policy>(
                "Policy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Policy {
        static instance: ::protobuf::rt::LazyV2<Policy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Policy::new)
    }
}

impl ::protobuf::Clear for Policy {
    fn clear(&mut self) {
        self.permissions.clear();
        self.principals.clear();
        self.condition.clear();
        self.checked_condition.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Policy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Policy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Permission {
    // message oneof groups
    pub rule: ::std::option::Option<Permission_oneof_rule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Permission {
    fn default() -> &'a Permission {
        <Permission as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Permission_oneof_rule {
    and_rules(Permission_Set),
    or_rules(Permission_Set),
    any(bool),
    header(super::route_components::HeaderMatcher),
    url_path(super::path::PathMatcher),
    destination_ip(super::address::CidrRange),
    destination_port(u32),
    metadata(super::metadata::MetadataMatcher),
    not_rule(::std::boxed::Box<Permission>),
    requested_server_name(super::string::StringMatcher),
}

impl Permission {
    pub fn new() -> Permission {
        ::std::default::Default::default()
    }

    // .envoy.config.rbac.v3.Permission.Set and_rules = 1;


    pub fn get_and_rules(&self) -> &Permission_Set {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::and_rules(ref v)) => v,
            _ => <Permission_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_and_rules(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_and_rules(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::and_rules(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_rules(&mut self, v: Permission_Set) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::and_rules(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_rules(&mut self) -> &mut Permission_Set {
        if let ::std::option::Option::Some(Permission_oneof_rule::and_rules(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::and_rules(Permission_Set::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::and_rules(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_rules(&mut self) -> Permission_Set {
        if self.has_and_rules() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::and_rules(v)) => v,
                _ => panic!(),
            }
        } else {
            Permission_Set::new()
        }
    }

    // .envoy.config.rbac.v3.Permission.Set or_rules = 2;


    pub fn get_or_rules(&self) -> &Permission_Set {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::or_rules(ref v)) => v,
            _ => <Permission_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_or_rules(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_or_rules(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::or_rules(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_rules(&mut self, v: Permission_Set) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::or_rules(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_rules(&mut self) -> &mut Permission_Set {
        if let ::std::option::Option::Some(Permission_oneof_rule::or_rules(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::or_rules(Permission_Set::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::or_rules(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_rules(&mut self) -> Permission_Set {
        if self.has_or_rules() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::or_rules(v)) => v,
                _ => panic!(),
            }
        } else {
            Permission_Set::new()
        }
    }

    // bool any = 3;


    pub fn get_any(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::any(v)) => v,
            _ => false,
        }
    }
    pub fn clear_any(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::any(v))
    }

    // .envoy.config.route.v3.HeaderMatcher header = 4;


    pub fn get_header(&self) -> &super::route_components::HeaderMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::header(ref v)) => v,
            _ => <super::route_components::HeaderMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: super::route_components::HeaderMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut super::route_components::HeaderMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::header(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::header(super::route_components::HeaderMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> super::route_components::HeaderMatcher {
        if self.has_header() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::header(v)) => v,
                _ => panic!(),
            }
        } else {
            super::route_components::HeaderMatcher::new()
        }
    }

    // .envoy.type.matcher.v3.PathMatcher url_path = 10;


    pub fn get_url_path(&self) -> &super::path::PathMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::url_path(ref v)) => v,
            _ => <super::path::PathMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_url_path(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_url_path(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::url_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url_path(&mut self, v: super::path::PathMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::url_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url_path(&mut self) -> &mut super::path::PathMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::url_path(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::url_path(super::path::PathMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::url_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url_path(&mut self) -> super::path::PathMatcher {
        if self.has_url_path() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::url_path(v)) => v,
                _ => panic!(),
            }
        } else {
            super::path::PathMatcher::new()
        }
    }

    // .envoy.config.core.v3.CidrRange destination_ip = 5;


    pub fn get_destination_ip(&self) -> &super::address::CidrRange {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_destination_ip(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_destination_ip(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination_ip(&mut self, v: super::address::CidrRange) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_destination_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Permission_oneof_rule::destination_ip(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_ip(super::address::CidrRange::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_destination_ip(&mut self) -> super::address::CidrRange {
        if self.has_destination_ip() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::destination_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // uint32 destination_port = 6;


    pub fn get_destination_port(&self) -> u32 {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_port(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_destination_port(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_destination_port(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::destination_port(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_destination_port(&mut self, v: u32) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_port(v))
    }

    // .envoy.type.matcher.v3.MetadataMatcher metadata = 7;


    pub fn get_metadata(&self) -> &super::metadata::MetadataMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::metadata(ref v)) => v,
            _ => <super::metadata::MetadataMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metadata(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::metadata::MetadataMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut super::metadata::MetadataMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::metadata(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::metadata(super::metadata::MetadataMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::metadata::MetadataMatcher {
        if self.has_metadata() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            super::metadata::MetadataMatcher::new()
        }
    }

    // .envoy.config.rbac.v3.Permission not_rule = 8;


    pub fn get_not_rule(&self) -> &Permission {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::not_rule(ref v)) => v,
            _ => <Permission as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_not_rule(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_not_rule(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::not_rule(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_rule(&mut self, v: Permission) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::not_rule(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_rule(&mut self) -> &mut Permission {
        if let ::std::option::Option::Some(Permission_oneof_rule::not_rule(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::not_rule(::std::boxed::Box::new(Permission::new())));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::not_rule(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_rule(&mut self) -> Permission {
        if self.has_not_rule() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::not_rule(v)) => *v,
                _ => panic!(),
            }
        } else {
            Permission::new()
        }
    }

    // .envoy.type.matcher.v3.StringMatcher requested_server_name = 9;


    pub fn get_requested_server_name(&self) -> &super::string::StringMatcher {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(ref v)) => v,
            _ => <super::string::StringMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_requested_server_name(&mut self) {
        self.rule = ::std::option::Option::None;
    }

    pub fn has_requested_server_name(&self) -> bool {
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_requested_server_name(&mut self, v: super::string::StringMatcher) {
        self.rule = ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(v))
    }

    // Mutable pointer to the field.
    pub fn mut_requested_server_name(&mut self) -> &mut super::string::StringMatcher {
        if let ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(_)) = self.rule {
        } else {
            self.rule = ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(super::string::StringMatcher::new()));
        }
        match self.rule {
            ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_requested_server_name(&mut self) -> super::string::StringMatcher {
        if self.has_requested_server_name() {
            match self.rule.take() {
                ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(v)) => v,
                _ => panic!(),
            }
        } else {
            super::string::StringMatcher::new()
        }
    }
}

impl ::protobuf::Message for Permission {
    fn is_initialized(&self) -> bool {
        if let Some(Permission_oneof_rule::and_rules(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::or_rules(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::header(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::url_path(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::destination_ip(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::metadata(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::not_rule(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Permission_oneof_rule::requested_server_name(ref v)) = self.rule {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::and_rules(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::or_rules(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::any(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::header(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::url_path(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_ip(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::destination_port(is.read_uint32()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::metadata(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::not_rule(::std::boxed::Box::new(is.read_message()?)));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.rule = ::std::option::Option::Some(Permission_oneof_rule::requested_server_name(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &Permission_oneof_rule::and_rules(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::or_rules(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::any(v) => {
                    my_size += 2;
                },
                &Permission_oneof_rule::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::url_path(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::destination_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::destination_port(v) => {
                    my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &Permission_oneof_rule::metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::not_rule(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Permission_oneof_rule::requested_server_name(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.rule {
            match v {
                &Permission_oneof_rule::and_rules(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::or_rules(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::any(v) => {
                    os.write_bool(3, v)?;
                },
                &Permission_oneof_rule::header(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::url_path(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::destination_ip(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::destination_port(v) => {
                    os.write_uint32(6, v)?;
                },
                &Permission_oneof_rule::metadata(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::not_rule(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Permission_oneof_rule::requested_server_name(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Permission {
        Permission::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Permission_Set>(
                "and_rules",
                Permission::has_and_rules,
                Permission::get_and_rules,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Permission_Set>(
                "or_rules",
                Permission::has_or_rules,
                Permission::get_or_rules,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "any",
                Permission::has_any,
                Permission::get_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::route_components::HeaderMatcher>(
                "header",
                Permission::has_header,
                Permission::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::path::PathMatcher>(
                "url_path",
                Permission::has_url_path,
                Permission::get_url_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "destination_ip",
                Permission::has_destination_ip,
                Permission::get_destination_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "destination_port",
                Permission::has_destination_port,
                Permission::get_destination_port,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::metadata::MetadataMatcher>(
                "metadata",
                Permission::has_metadata,
                Permission::get_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Permission>(
                "not_rule",
                Permission::has_not_rule,
                Permission::get_not_rule,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::string::StringMatcher>(
                "requested_server_name",
                Permission::has_requested_server_name,
                Permission::get_requested_server_name,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Permission>(
                "Permission",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Permission {
        static instance: ::protobuf::rt::LazyV2<Permission> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Permission::new)
    }
}

impl ::protobuf::Clear for Permission {
    fn clear(&mut self) {
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.rule = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Permission {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Permission_Set {
    // message fields
    pub rules: ::protobuf::RepeatedField<Permission>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Permission_Set {
    fn default() -> &'a Permission_Set {
        <Permission_Set as ::protobuf::Message>::default_instance()
    }
}

impl Permission_Set {
    pub fn new() -> Permission_Set {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.rbac.v3.Permission rules = 1;


    pub fn get_rules(&self) -> &[Permission] {
        &self.rules
    }
    pub fn clear_rules(&mut self) {
        self.rules.clear();
    }

    // Param is passed by value, moved
    pub fn set_rules(&mut self, v: ::protobuf::RepeatedField<Permission>) {
        self.rules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rules(&mut self) -> &mut ::protobuf::RepeatedField<Permission> {
        &mut self.rules
    }

    // Take field
    pub fn take_rules(&mut self) -> ::protobuf::RepeatedField<Permission> {
        ::std::mem::replace(&mut self.rules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Permission_Set {
    fn is_initialized(&self) -> bool {
        for v in &self.rules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.rules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.rules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.rules {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Permission_Set {
        Permission_Set::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Permission>>(
                "rules",
                |m: &Permission_Set| { &m.rules },
                |m: &mut Permission_Set| { &mut m.rules },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Permission_Set>(
                "Permission.Set",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Permission_Set {
        static instance: ::protobuf::rt::LazyV2<Permission_Set> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Permission_Set::new)
    }
}

impl ::protobuf::Clear for Permission_Set {
    fn clear(&mut self) {
        self.rules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Permission_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Permission_Set {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Principal {
    // message oneof groups
    pub identifier: ::std::option::Option<Principal_oneof_identifier>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Principal {
    fn default() -> &'a Principal {
        <Principal as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Principal_oneof_identifier {
    and_ids(Principal_Set),
    or_ids(Principal_Set),
    any(bool),
    authenticated(Principal_Authenticated),
    source_ip(super::address::CidrRange),
    direct_remote_ip(super::address::CidrRange),
    remote_ip(super::address::CidrRange),
    header(super::route_components::HeaderMatcher),
    url_path(super::path::PathMatcher),
    metadata(super::metadata::MetadataMatcher),
    not_id(::std::boxed::Box<Principal>),
}

impl Principal {
    pub fn new() -> Principal {
        ::std::default::Default::default()
    }

    // .envoy.config.rbac.v3.Principal.Set and_ids = 1;


    pub fn get_and_ids(&self) -> &Principal_Set {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::and_ids(ref v)) => v,
            _ => <Principal_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_and_ids(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_and_ids(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::and_ids(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_and_ids(&mut self, v: Principal_Set) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::and_ids(v))
    }

    // Mutable pointer to the field.
    pub fn mut_and_ids(&mut self) -> &mut Principal_Set {
        if let ::std::option::Option::Some(Principal_oneof_identifier::and_ids(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::and_ids(Principal_Set::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::and_ids(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_and_ids(&mut self) -> Principal_Set {
        if self.has_and_ids() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::and_ids(v)) => v,
                _ => panic!(),
            }
        } else {
            Principal_Set::new()
        }
    }

    // .envoy.config.rbac.v3.Principal.Set or_ids = 2;


    pub fn get_or_ids(&self) -> &Principal_Set {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::or_ids(ref v)) => v,
            _ => <Principal_Set as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_or_ids(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_or_ids(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::or_ids(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_or_ids(&mut self, v: Principal_Set) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::or_ids(v))
    }

    // Mutable pointer to the field.
    pub fn mut_or_ids(&mut self) -> &mut Principal_Set {
        if let ::std::option::Option::Some(Principal_oneof_identifier::or_ids(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::or_ids(Principal_Set::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::or_ids(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_or_ids(&mut self) -> Principal_Set {
        if self.has_or_ids() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::or_ids(v)) => v,
                _ => panic!(),
            }
        } else {
            Principal_Set::new()
        }
    }

    // bool any = 3;


    pub fn get_any(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::any(v)) => v,
            _ => false,
        }
    }
    pub fn clear_any(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::any(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::any(v))
    }

    // .envoy.config.rbac.v3.Principal.Authenticated authenticated = 4;


    pub fn get_authenticated(&self) -> &Principal_Authenticated {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::authenticated(ref v)) => v,
            _ => <Principal_Authenticated as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_authenticated(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_authenticated(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::authenticated(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: Principal_Authenticated) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::authenticated(v))
    }

    // Mutable pointer to the field.
    pub fn mut_authenticated(&mut self) -> &mut Principal_Authenticated {
        if let ::std::option::Option::Some(Principal_oneof_identifier::authenticated(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::authenticated(Principal_Authenticated::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::authenticated(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_authenticated(&mut self) -> Principal_Authenticated {
        if self.has_authenticated() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::authenticated(v)) => v,
                _ => panic!(),
            }
        } else {
            Principal_Authenticated::new()
        }
    }

    // .envoy.config.core.v3.CidrRange source_ip = 5;


    pub fn get_source_ip(&self) -> &super::address::CidrRange {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::source_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_source_ip(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_source_ip(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::source_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_source_ip(&mut self, v: super::address::CidrRange) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::source_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_source_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Principal_oneof_identifier::source_ip(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::source_ip(super::address::CidrRange::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::source_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_source_ip(&mut self) -> super::address::CidrRange {
        if self.has_source_ip() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::source_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // .envoy.config.core.v3.CidrRange direct_remote_ip = 10;


    pub fn get_direct_remote_ip(&self) -> &super::address::CidrRange {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_direct_remote_ip(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_direct_remote_ip(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_direct_remote_ip(&mut self, v: super::address::CidrRange) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_direct_remote_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(super::address::CidrRange::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_direct_remote_ip(&mut self) -> super::address::CidrRange {
        if self.has_direct_remote_ip() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // .envoy.config.core.v3.CidrRange remote_ip = 11;


    pub fn get_remote_ip(&self) -> &super::address::CidrRange {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(ref v)) => v,
            _ => <super::address::CidrRange as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_remote_ip(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_remote_ip(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_remote_ip(&mut self, v: super::address::CidrRange) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(v))
    }

    // Mutable pointer to the field.
    pub fn mut_remote_ip(&mut self) -> &mut super::address::CidrRange {
        if let ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(super::address::CidrRange::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_remote_ip(&mut self) -> super::address::CidrRange {
        if self.has_remote_ip() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(v)) => v,
                _ => panic!(),
            }
        } else {
            super::address::CidrRange::new()
        }
    }

    // .envoy.config.route.v3.HeaderMatcher header = 6;


    pub fn get_header(&self) -> &super::route_components::HeaderMatcher {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::header(ref v)) => v,
            _ => <super::route_components::HeaderMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_header(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_header(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::header(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: super::route_components::HeaderMatcher) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::header(v))
    }

    // Mutable pointer to the field.
    pub fn mut_header(&mut self) -> &mut super::route_components::HeaderMatcher {
        if let ::std::option::Option::Some(Principal_oneof_identifier::header(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::header(super::route_components::HeaderMatcher::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::header(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_header(&mut self) -> super::route_components::HeaderMatcher {
        if self.has_header() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::header(v)) => v,
                _ => panic!(),
            }
        } else {
            super::route_components::HeaderMatcher::new()
        }
    }

    // .envoy.type.matcher.v3.PathMatcher url_path = 9;


    pub fn get_url_path(&self) -> &super::path::PathMatcher {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::url_path(ref v)) => v,
            _ => <super::path::PathMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_url_path(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_url_path(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::url_path(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_url_path(&mut self, v: super::path::PathMatcher) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::url_path(v))
    }

    // Mutable pointer to the field.
    pub fn mut_url_path(&mut self) -> &mut super::path::PathMatcher {
        if let ::std::option::Option::Some(Principal_oneof_identifier::url_path(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::url_path(super::path::PathMatcher::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::url_path(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_url_path(&mut self) -> super::path::PathMatcher {
        if self.has_url_path() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::url_path(v)) => v,
                _ => panic!(),
            }
        } else {
            super::path::PathMatcher::new()
        }
    }

    // .envoy.type.matcher.v3.MetadataMatcher metadata = 7;


    pub fn get_metadata(&self) -> &super::metadata::MetadataMatcher {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::metadata(ref v)) => v,
            _ => <super::metadata::MetadataMatcher as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_metadata(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_metadata(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::metadata(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::metadata::MetadataMatcher) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::metadata(v))
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut super::metadata::MetadataMatcher {
        if let ::std::option::Option::Some(Principal_oneof_identifier::metadata(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::metadata(super::metadata::MetadataMatcher::new()));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::metadata(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::metadata::MetadataMatcher {
        if self.has_metadata() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::metadata(v)) => v,
                _ => panic!(),
            }
        } else {
            super::metadata::MetadataMatcher::new()
        }
    }

    // .envoy.config.rbac.v3.Principal not_id = 8;


    pub fn get_not_id(&self) -> &Principal {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::not_id(ref v)) => v,
            _ => <Principal as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_not_id(&mut self) {
        self.identifier = ::std::option::Option::None;
    }

    pub fn has_not_id(&self) -> bool {
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::not_id(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_not_id(&mut self, v: Principal) {
        self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::not_id(::std::boxed::Box::new(v)))
    }

    // Mutable pointer to the field.
    pub fn mut_not_id(&mut self) -> &mut Principal {
        if let ::std::option::Option::Some(Principal_oneof_identifier::not_id(_)) = self.identifier {
        } else {
            self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::not_id(::std::boxed::Box::new(Principal::new())));
        }
        match self.identifier {
            ::std::option::Option::Some(Principal_oneof_identifier::not_id(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_not_id(&mut self) -> Principal {
        if self.has_not_id() {
            match self.identifier.take() {
                ::std::option::Option::Some(Principal_oneof_identifier::not_id(v)) => *v,
                _ => panic!(),
            }
        } else {
            Principal::new()
        }
    }
}

impl ::protobuf::Message for Principal {
    fn is_initialized(&self) -> bool {
        if let Some(Principal_oneof_identifier::and_ids(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::or_ids(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::authenticated(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::source_ip(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::direct_remote_ip(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::remote_ip(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::header(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::url_path(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::metadata(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Principal_oneof_identifier::not_id(ref v)) = self.identifier {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::and_ids(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::or_ids(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::any(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::authenticated(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::source_ip(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::direct_remote_ip(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::remote_ip(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::header(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::url_path(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::metadata(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.identifier = ::std::option::Option::Some(Principal_oneof_identifier::not_id(::std::boxed::Box::new(is.read_message()?)));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &Principal_oneof_identifier::and_ids(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::or_ids(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::any(v) => {
                    my_size += 2;
                },
                &Principal_oneof_identifier::authenticated(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::source_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::direct_remote_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::remote_ip(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::header(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::url_path(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::metadata(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Principal_oneof_identifier::not_id(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.identifier {
            match v {
                &Principal_oneof_identifier::and_ids(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::or_ids(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::any(v) => {
                    os.write_bool(3, v)?;
                },
                &Principal_oneof_identifier::authenticated(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::source_ip(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::direct_remote_ip(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::remote_ip(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::header(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::url_path(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::metadata(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Principal_oneof_identifier::not_id(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Principal {
        Principal::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal_Set>(
                "and_ids",
                Principal::has_and_ids,
                Principal::get_and_ids,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal_Set>(
                "or_ids",
                Principal::has_or_ids,
                Principal::get_or_ids,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "any",
                Principal::has_any,
                Principal::get_any,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal_Authenticated>(
                "authenticated",
                Principal::has_authenticated,
                Principal::get_authenticated,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "source_ip",
                Principal::has_source_ip,
                Principal::get_source_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "direct_remote_ip",
                Principal::has_direct_remote_ip,
                Principal::get_direct_remote_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::address::CidrRange>(
                "remote_ip",
                Principal::has_remote_ip,
                Principal::get_remote_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::route_components::HeaderMatcher>(
                "header",
                Principal::has_header,
                Principal::get_header,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::path::PathMatcher>(
                "url_path",
                Principal::has_url_path,
                Principal::get_url_path,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::metadata::MetadataMatcher>(
                "metadata",
                Principal::has_metadata,
                Principal::get_metadata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Principal>(
                "not_id",
                Principal::has_not_id,
                Principal::get_not_id,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Principal>(
                "Principal",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Principal {
        static instance: ::protobuf::rt::LazyV2<Principal> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Principal::new)
    }
}

impl ::protobuf::Clear for Principal {
    fn clear(&mut self) {
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.identifier = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Principal {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Principal {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Principal_Set {
    // message fields
    pub ids: ::protobuf::RepeatedField<Principal>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Principal_Set {
    fn default() -> &'a Principal_Set {
        <Principal_Set as ::protobuf::Message>::default_instance()
    }
}

impl Principal_Set {
    pub fn new() -> Principal_Set {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.rbac.v3.Principal ids = 1;


    pub fn get_ids(&self) -> &[Principal] {
        &self.ids
    }
    pub fn clear_ids(&mut self) {
        self.ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_ids(&mut self, v: ::protobuf::RepeatedField<Principal>) {
        self.ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ids(&mut self) -> &mut ::protobuf::RepeatedField<Principal> {
        &mut self.ids
    }

    // Take field
    pub fn take_ids(&mut self) -> ::protobuf::RepeatedField<Principal> {
        ::std::mem::replace(&mut self.ids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Principal_Set {
    fn is_initialized(&self) -> bool {
        for v in &self.ids {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ids {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ids {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Principal_Set {
        Principal_Set::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Principal>>(
                "ids",
                |m: &Principal_Set| { &m.ids },
                |m: &mut Principal_Set| { &mut m.ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Principal_Set>(
                "Principal.Set",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Principal_Set {
        static instance: ::protobuf::rt::LazyV2<Principal_Set> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Principal_Set::new)
    }
}

impl ::protobuf::Clear for Principal_Set {
    fn clear(&mut self) {
        self.ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Principal_Set {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Principal_Set {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Principal_Authenticated {
    // message fields
    pub principal_name: ::protobuf::SingularPtrField<super::string::StringMatcher>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Principal_Authenticated {
    fn default() -> &'a Principal_Authenticated {
        <Principal_Authenticated as ::protobuf::Message>::default_instance()
    }
}

impl Principal_Authenticated {
    pub fn new() -> Principal_Authenticated {
        ::std::default::Default::default()
    }

    // .envoy.type.matcher.v3.StringMatcher principal_name = 2;


    pub fn get_principal_name(&self) -> &super::string::StringMatcher {
        self.principal_name.as_ref().unwrap_or_else(|| <super::string::StringMatcher as ::protobuf::Message>::default_instance())
    }
    pub fn clear_principal_name(&mut self) {
        self.principal_name.clear();
    }

    pub fn has_principal_name(&self) -> bool {
        self.principal_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_principal_name(&mut self, v: super::string::StringMatcher) {
        self.principal_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_principal_name(&mut self) -> &mut super::string::StringMatcher {
        if self.principal_name.is_none() {
            self.principal_name.set_default();
        }
        self.principal_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_principal_name(&mut self) -> super::string::StringMatcher {
        self.principal_name.take().unwrap_or_else(|| super::string::StringMatcher::new())
    }
}

impl ::protobuf::Message for Principal_Authenticated {
    fn is_initialized(&self) -> bool {
        for v in &self.principal_name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.principal_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.principal_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.principal_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Principal_Authenticated {
        Principal_Authenticated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::string::StringMatcher>>(
                "principal_name",
                |m: &Principal_Authenticated| { &m.principal_name },
                |m: &mut Principal_Authenticated| { &mut m.principal_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Principal_Authenticated>(
                "Principal.Authenticated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Principal_Authenticated {
        static instance: ::protobuf::rt::LazyV2<Principal_Authenticated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Principal_Authenticated::new)
    }
}

impl ::protobuf::Clear for Principal_Authenticated {
    fn clear(&mut self) {
        self.principal_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Principal_Authenticated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Principal_Authenticated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1fenvoy/config/rbac/v3/rbac.proto\x12\x14envoy.config.rbac.v3\x1a\"e\
    nvoy/config/core/v3/address.proto\x1a,envoy/config/route/v3/route_compon\
    ents.proto\x1a$envoy/type/matcher/v3/metadata.proto\x1a\x20envoy/type/ma\
    tcher/v3/path.proto\x1a\"envoy/type/matcher/v3/string.proto\x1a&google/a\
    pi/expr/v1alpha1/checked.proto\x1a%google/api/expr/v1alpha1/syntax.proto\
    \x1a\x1eudpa/annotations/migrate.proto\x1a\x1dudpa/annotations/status.pr\
    oto\x1a!udpa/annotations/versioning.proto\x1a\x17validate/validate.proto\
    \"\xb6\x02\n\x04RBAC\x12C\n\x06action\x18\x01\x20\x01(\x0e2!.envoy.confi\
    g.rbac.v3.RBAC.ActionR\x06actionB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12D\
    \n\x08policies\x18\x02\x20\x03(\x0b2(.envoy.config.rbac.v3.RBAC.Policies\
    EntryR\x08policies\x1aY\n\rPoliciesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x122\n\x05value\x18\x02\x20\x01(\x0b2\x1c.envoy.config.r\
    bac.v3.PolicyR\x05value:\x028\x01\"&\n\x06Action\x12\t\n\x05ALLOW\x10\0\
    \x12\x08\n\x04DENY\x10\x01\x12\x07\n\x03LOG\x10\x02:\x20\x9a\xc5\x88\x1e\
    \x1b\n\x19envoy.config.rbac.v2.RBAC\"\x93\x03\n\x06Policy\x12L\n\x0bperm\
    issions\x18\x01\x20\x03(\x0b2\x20.envoy.config.rbac.v3.PermissionR\x0bpe\
    rmissionsB\x08\xfaB\x05\x92\x01\x02\x08\x01\x12I\n\nprincipals\x18\x02\
    \x20\x03(\x0b2\x1f.envoy.config.rbac.v3.PrincipalR\nprincipalsB\x08\xfaB\
    \x05\x92\x01\x02\x08\x01\x12Z\n\tcondition\x18\x03\x20\x01(\x0b2\x1e.goo\
    gle.api.expr.v1alpha1.ExprR\tconditionB\x1c\xf2\x98\xfe\x8f\x05\x16\x12\
    \x14expression_specifier\x12p\n\x11checked_condition\x18\x04\x20\x01(\
    \x0b2%.google.api.expr.v1alpha1.CheckedExprR\x10checkedConditionB\x1c\
    \xf2\x98\xfe\x8f\x05\x16\x12\x14expression_specifier:\"\x9a\xc5\x88\x1e\
    \x1d\n\x1benvoy.config.rbac.v2.Policy\"\xbf\x06\n\nPermission\x12C\n\tan\
    d_rules\x18\x01\x20\x01(\x0b2$.envoy.config.rbac.v3.Permission.SetH\0R\
    \x08andRules\x12A\n\x08or_rules\x18\x02\x20\x01(\x0b2$.envoy.config.rbac\
    .v3.Permission.SetH\0R\x07orRules\x12\x1b\n\x03any\x18\x03\x20\x01(\x08H\
    \0R\x03anyB\x07\xfaB\x04j\x02\x08\x01\x12>\n\x06header\x18\x04\x20\x01(\
    \x0b2$.envoy.config.route.v3.HeaderMatcherH\0R\x06header\x12?\n\x08url_p\
    ath\x18\n\x20\x01(\x0b2\".envoy.type.matcher.v3.PathMatcherH\0R\x07urlPa\
    th\x12H\n\x0edestination_ip\x18\x05\x20\x01(\x0b2\x1f.envoy.config.core.\
    v3.CidrRangeH\0R\rdestinationIp\x126\n\x10destination_port\x18\x06\x20\
    \x01(\rH\0R\x0fdestinationPortB\t\xfaB\x06*\x04\x18\xff\xff\x03\x12D\n\
    \x08metadata\x18\x07\x20\x01(\x0b2&.envoy.type.matcher.v3.MetadataMatche\
    rH\0R\x08metadata\x12=\n\x08not_rule\x18\x08\x20\x01(\x0b2\x20.envoy.con\
    fig.rbac.v3.PermissionH\0R\x07notRule\x12Z\n\x15requested_server_name\
    \x18\t\x20\x01(\x0b2$.envoy.type.matcher.v3.StringMatcherH\0R\x13request\
    edServerName\x1as\n\x03Set\x12@\n\x05rules\x18\x01\x20\x03(\x0b2\x20.env\
    oy.config.rbac.v3.PermissionR\x05rulesB\x08\xfaB\x05\x92\x01\x02\x08\x01\
    :*\x9a\xc5\x88\x1e%\n#envoy.config.rbac.v2.Permission.SetB\x0b\n\x04rule\
    \x12\x03\xf8B\x01:&\x9a\xc5\x88\x1e!\n\x1fenvoy.config.rbac.v2.Permissio\
    n\"\x92\x08\n\tPrincipal\x12>\n\x07and_ids\x18\x01\x20\x01(\x0b2#.envoy.\
    config.rbac.v3.Principal.SetH\0R\x06andIds\x12<\n\x06or_ids\x18\x02\x20\
    \x01(\x0b2#.envoy.config.rbac.v3.Principal.SetH\0R\x05orIds\x12\x1b\n\
    \x03any\x18\x03\x20\x01(\x08H\0R\x03anyB\x07\xfaB\x04j\x02\x08\x01\x12U\
    \n\rauthenticated\x18\x04\x20\x01(\x0b2-.envoy.config.rbac.v3.Principal.\
    AuthenticatedH\0R\rauthenticated\x12B\n\tsource_ip\x18\x05\x20\x01(\x0b2\
    \x1f.envoy.config.core.v3.CidrRangeH\0R\x08sourceIpB\x02\x18\x01\x12K\n\
    \x10direct_remote_ip\x18\n\x20\x01(\x0b2\x1f.envoy.config.core.v3.CidrRa\
    ngeH\0R\x0edirectRemoteIp\x12>\n\tremote_ip\x18\x0b\x20\x01(\x0b2\x1f.en\
    voy.config.core.v3.CidrRangeH\0R\x08remoteIp\x12>\n\x06header\x18\x06\
    \x20\x01(\x0b2$.envoy.config.route.v3.HeaderMatcherH\0R\x06header\x12?\n\
    \x08url_path\x18\t\x20\x01(\x0b2\".envoy.type.matcher.v3.PathMatcherH\0R\
    \x07urlPath\x12D\n\x08metadata\x18\x07\x20\x01(\x0b2&.envoy.type.matcher\
    .v3.MetadataMatcherH\0R\x08metadata\x128\n\x06not_id\x18\x08\x20\x01(\
    \x0b2\x1f.envoy.config.rbac.v3.PrincipalH\0R\x05notId\x1am\n\x03Set\x12;\
    \n\x03ids\x18\x01\x20\x03(\x0b2\x1f.envoy.config.rbac.v3.PrincipalR\x03i\
    dsB\x08\xfaB\x05\x92\x01\x02\x08\x01:)\x9a\xc5\x88\x1e$\n\"envoy.config.\
    rbac.v2.Principal.Set\x1a\x97\x01\n\rAuthenticated\x12K\n\x0eprincipal_n\
    ame\x18\x02\x20\x01(\x0b2$.envoy.type.matcher.v3.StringMatcherR\rprincip\
    alName:3\x9a\xc5\x88\x1e.\n,envoy.config.rbac.v2.Principal.Authenticated\
    J\x04\x08\x01\x10\x02B\x11\n\nidentifier\x12\x03\xf8B\x01:%\x9a\xc5\x88\
    \x1e\x20\n\x1eenvoy.config.rbac.v2.PrincipalB9\n\"io.envoyproxy.envoy.co\
    nfig.rbac.v3B\tRbacProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
