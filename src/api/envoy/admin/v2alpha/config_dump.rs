// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/admin/v2alpha/config_dump.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct ConfigDump {
    // message fields
    pub configs: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigDump {
    fn default() -> &'a ConfigDump {
        <ConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl ConfigDump {
    pub fn new() -> ConfigDump {
        ::std::default::Default::default()
    }

    // repeated .google.protobuf.Any configs = 1;


    pub fn get_configs(&self) -> &[::protobuf::well_known_types::Any] {
        &self.configs
    }
    pub fn clear_configs(&mut self) {
        self.configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_configs(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_configs(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.configs
    }

    // Take field
    pub fn take_configs(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.configs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.configs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.configs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigDump {
        ConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "configs",
                |m: &ConfigDump| { &m.configs },
                |m: &mut ConfigDump| { &mut m.configs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigDump>(
                "ConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigDump {
        static instance: ::protobuf::rt::LazyV2<ConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigDump::new)
    }
}

impl ::protobuf::Clear for ConfigDump {
    fn clear(&mut self) {
        self.configs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateFailureState {
    // message fields
    pub failed_configuration: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_update_attempt: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub details: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateFailureState {
    fn default() -> &'a UpdateFailureState {
        <UpdateFailureState as ::protobuf::Message>::default_instance()
    }
}

impl UpdateFailureState {
    pub fn new() -> UpdateFailureState {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any failed_configuration = 1;


    pub fn get_failed_configuration(&self) -> &::protobuf::well_known_types::Any {
        self.failed_configuration.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_failed_configuration(&mut self) {
        self.failed_configuration.clear();
    }

    pub fn has_failed_configuration(&self) -> bool {
        self.failed_configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failed_configuration(&mut self, v: ::protobuf::well_known_types::Any) {
        self.failed_configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_failed_configuration(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.failed_configuration.is_none() {
            self.failed_configuration.set_default();
        }
        self.failed_configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_failed_configuration(&mut self) -> ::protobuf::well_known_types::Any {
        self.failed_configuration.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_update_attempt = 2;


    pub fn get_last_update_attempt(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_update_attempt.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_update_attempt(&mut self) {
        self.last_update_attempt.clear();
    }

    pub fn has_last_update_attempt(&self) -> bool {
        self.last_update_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_attempt(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_update_attempt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_update_attempt(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_update_attempt.is_none() {
            self.last_update_attempt.set_default();
        }
        self.last_update_attempt.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_update_attempt(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_update_attempt.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // string details = 3;


    pub fn get_details(&self) -> &str {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.details, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateFailureState {
    fn is_initialized(&self) -> bool {
        for v in &self.failed_configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_update_attempt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.failed_configuration)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_update_attempt)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.failed_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_update_attempt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.failed_configuration.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_update_attempt.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.details.is_empty() {
            os.write_string(3, &self.details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateFailureState {
        UpdateFailureState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "failed_configuration",
                |m: &UpdateFailureState| { &m.failed_configuration },
                |m: &mut UpdateFailureState| { &mut m.failed_configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_update_attempt",
                |m: &UpdateFailureState| { &m.last_update_attempt },
                |m: &mut UpdateFailureState| { &mut m.last_update_attempt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "details",
                |m: &UpdateFailureState| { &m.details },
                |m: &mut UpdateFailureState| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateFailureState>(
                "UpdateFailureState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateFailureState {
        static instance: ::protobuf::rt::LazyV2<UpdateFailureState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateFailureState::new)
    }
}

impl ::protobuf::Clear for UpdateFailureState {
    fn clear(&mut self) {
        self.failed_configuration.clear();
        self.last_update_attempt.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateFailureState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateFailureState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BootstrapConfigDump {
    // message fields
    pub bootstrap: ::protobuf::SingularPtrField<super::bootstrap::Bootstrap>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BootstrapConfigDump {
    fn default() -> &'a BootstrapConfigDump {
        <BootstrapConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl BootstrapConfigDump {
    pub fn new() -> BootstrapConfigDump {
        ::std::default::Default::default()
    }

    // .envoy.config.bootstrap.v2.Bootstrap bootstrap = 1;


    pub fn get_bootstrap(&self) -> &super::bootstrap::Bootstrap {
        self.bootstrap.as_ref().unwrap_or_else(|| <super::bootstrap::Bootstrap as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bootstrap(&mut self) {
        self.bootstrap.clear();
    }

    pub fn has_bootstrap(&self) -> bool {
        self.bootstrap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootstrap(&mut self, v: super::bootstrap::Bootstrap) {
        self.bootstrap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootstrap(&mut self) -> &mut super::bootstrap::Bootstrap {
        if self.bootstrap.is_none() {
            self.bootstrap.set_default();
        }
        self.bootstrap.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootstrap(&mut self) -> super::bootstrap::Bootstrap {
        self.bootstrap.take().unwrap_or_else(|| super::bootstrap::Bootstrap::new())
    }

    // .google.protobuf.Timestamp last_updated = 2;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for BootstrapConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.bootstrap {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bootstrap)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bootstrap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bootstrap.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BootstrapConfigDump {
        BootstrapConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::bootstrap::Bootstrap>>(
                "bootstrap",
                |m: &BootstrapConfigDump| { &m.bootstrap },
                |m: &mut BootstrapConfigDump| { &mut m.bootstrap },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &BootstrapConfigDump| { &m.last_updated },
                |m: &mut BootstrapConfigDump| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BootstrapConfigDump>(
                "BootstrapConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BootstrapConfigDump {
        static instance: ::protobuf::rt::LazyV2<BootstrapConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BootstrapConfigDump::new)
    }
}

impl ::protobuf::Clear for BootstrapConfigDump {
    fn clear(&mut self) {
        self.bootstrap.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BootstrapConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BootstrapConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListenersConfigDump {
    // message fields
    pub version_info: ::std::string::String,
    pub static_listeners: ::protobuf::RepeatedField<ListenersConfigDump_StaticListener>,
    pub dynamic_listeners: ::protobuf::RepeatedField<ListenersConfigDump_DynamicListener>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListenersConfigDump {
    fn default() -> &'a ListenersConfigDump {
        <ListenersConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl ListenersConfigDump {
    pub fn new() -> ListenersConfigDump {
        ::std::default::Default::default()
    }

    // string version_info = 1;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // repeated .envoy.admin.v2alpha.ListenersConfigDump.StaticListener static_listeners = 2;


    pub fn get_static_listeners(&self) -> &[ListenersConfigDump_StaticListener] {
        &self.static_listeners
    }
    pub fn clear_static_listeners(&mut self) {
        self.static_listeners.clear();
    }

    // Param is passed by value, moved
    pub fn set_static_listeners(&mut self, v: ::protobuf::RepeatedField<ListenersConfigDump_StaticListener>) {
        self.static_listeners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_static_listeners(&mut self) -> &mut ::protobuf::RepeatedField<ListenersConfigDump_StaticListener> {
        &mut self.static_listeners
    }

    // Take field
    pub fn take_static_listeners(&mut self) -> ::protobuf::RepeatedField<ListenersConfigDump_StaticListener> {
        ::std::mem::replace(&mut self.static_listeners, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.ListenersConfigDump.DynamicListener dynamic_listeners = 3;


    pub fn get_dynamic_listeners(&self) -> &[ListenersConfigDump_DynamicListener] {
        &self.dynamic_listeners
    }
    pub fn clear_dynamic_listeners(&mut self) {
        self.dynamic_listeners.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_listeners(&mut self, v: ::protobuf::RepeatedField<ListenersConfigDump_DynamicListener>) {
        self.dynamic_listeners = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_listeners(&mut self) -> &mut ::protobuf::RepeatedField<ListenersConfigDump_DynamicListener> {
        &mut self.dynamic_listeners
    }

    // Take field
    pub fn take_dynamic_listeners(&mut self) -> ::protobuf::RepeatedField<ListenersConfigDump_DynamicListener> {
        ::std::mem::replace(&mut self.dynamic_listeners, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListenersConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.static_listeners {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_listeners {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.static_listeners)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_listeners)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_info);
        }
        for value in &self.static_listeners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_listeners {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_info.is_empty() {
            os.write_string(1, &self.version_info)?;
        }
        for v in &self.static_listeners {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_listeners {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListenersConfigDump {
        ListenersConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &ListenersConfigDump| { &m.version_info },
                |m: &mut ListenersConfigDump| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListenersConfigDump_StaticListener>>(
                "static_listeners",
                |m: &ListenersConfigDump| { &m.static_listeners },
                |m: &mut ListenersConfigDump| { &mut m.static_listeners },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListenersConfigDump_DynamicListener>>(
                "dynamic_listeners",
                |m: &ListenersConfigDump| { &m.dynamic_listeners },
                |m: &mut ListenersConfigDump| { &mut m.dynamic_listeners },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListenersConfigDump>(
                "ListenersConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListenersConfigDump {
        static instance: ::protobuf::rt::LazyV2<ListenersConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListenersConfigDump::new)
    }
}

impl ::protobuf::Clear for ListenersConfigDump {
    fn clear(&mut self) {
        self.version_info.clear();
        self.static_listeners.clear();
        self.dynamic_listeners.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListenersConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListenersConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListenersConfigDump_StaticListener {
    // message fields
    pub listener: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListenersConfigDump_StaticListener {
    fn default() -> &'a ListenersConfigDump_StaticListener {
        <ListenersConfigDump_StaticListener as ::protobuf::Message>::default_instance()
    }
}

impl ListenersConfigDump_StaticListener {
    pub fn new() -> ListenersConfigDump_StaticListener {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any listener = 1;


    pub fn get_listener(&self) -> &::protobuf::well_known_types::Any {
        self.listener.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_listener(&mut self) {
        self.listener.clear();
    }

    pub fn has_listener(&self) -> bool {
        self.listener.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listener(&mut self, v: ::protobuf::well_known_types::Any) {
        self.listener = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listener(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.listener.is_none() {
            self.listener.set_default();
        }
        self.listener.as_mut().unwrap()
    }

    // Take field
    pub fn take_listener(&mut self) -> ::protobuf::well_known_types::Any {
        self.listener.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_updated = 2;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ListenersConfigDump_StaticListener {
    fn is_initialized(&self) -> bool {
        for v in &self.listener {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.listener)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.listener.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.listener.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListenersConfigDump_StaticListener {
        ListenersConfigDump_StaticListener::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "listener",
                |m: &ListenersConfigDump_StaticListener| { &m.listener },
                |m: &mut ListenersConfigDump_StaticListener| { &mut m.listener },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &ListenersConfigDump_StaticListener| { &m.last_updated },
                |m: &mut ListenersConfigDump_StaticListener| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListenersConfigDump_StaticListener>(
                "ListenersConfigDump.StaticListener",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListenersConfigDump_StaticListener {
        static instance: ::protobuf::rt::LazyV2<ListenersConfigDump_StaticListener> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListenersConfigDump_StaticListener::new)
    }
}

impl ::protobuf::Clear for ListenersConfigDump_StaticListener {
    fn clear(&mut self) {
        self.listener.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListenersConfigDump_StaticListener {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListenersConfigDump_StaticListener {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListenersConfigDump_DynamicListenerState {
    // message fields
    pub version_info: ::std::string::String,
    pub listener: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListenersConfigDump_DynamicListenerState {
    fn default() -> &'a ListenersConfigDump_DynamicListenerState {
        <ListenersConfigDump_DynamicListenerState as ::protobuf::Message>::default_instance()
    }
}

impl ListenersConfigDump_DynamicListenerState {
    pub fn new() -> ListenersConfigDump_DynamicListenerState {
        ::std::default::Default::default()
    }

    // string version_info = 1;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // .google.protobuf.Any listener = 2;


    pub fn get_listener(&self) -> &::protobuf::well_known_types::Any {
        self.listener.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_listener(&mut self) {
        self.listener.clear();
    }

    pub fn has_listener(&self) -> bool {
        self.listener.is_some()
    }

    // Param is passed by value, moved
    pub fn set_listener(&mut self, v: ::protobuf::well_known_types::Any) {
        self.listener = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listener(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.listener.is_none() {
            self.listener.set_default();
        }
        self.listener.as_mut().unwrap()
    }

    // Take field
    pub fn take_listener(&mut self) -> ::protobuf::well_known_types::Any {
        self.listener.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_updated = 3;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ListenersConfigDump_DynamicListenerState {
    fn is_initialized(&self) -> bool {
        for v in &self.listener {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.listener)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_info);
        }
        if let Some(ref v) = self.listener.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_info.is_empty() {
            os.write_string(1, &self.version_info)?;
        }
        if let Some(ref v) = self.listener.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListenersConfigDump_DynamicListenerState {
        ListenersConfigDump_DynamicListenerState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &ListenersConfigDump_DynamicListenerState| { &m.version_info },
                |m: &mut ListenersConfigDump_DynamicListenerState| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "listener",
                |m: &ListenersConfigDump_DynamicListenerState| { &m.listener },
                |m: &mut ListenersConfigDump_DynamicListenerState| { &mut m.listener },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &ListenersConfigDump_DynamicListenerState| { &m.last_updated },
                |m: &mut ListenersConfigDump_DynamicListenerState| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListenersConfigDump_DynamicListenerState>(
                "ListenersConfigDump.DynamicListenerState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListenersConfigDump_DynamicListenerState {
        static instance: ::protobuf::rt::LazyV2<ListenersConfigDump_DynamicListenerState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListenersConfigDump_DynamicListenerState::new)
    }
}

impl ::protobuf::Clear for ListenersConfigDump_DynamicListenerState {
    fn clear(&mut self) {
        self.version_info.clear();
        self.listener.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListenersConfigDump_DynamicListenerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListenersConfigDump_DynamicListenerState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListenersConfigDump_DynamicListener {
    // message fields
    pub name: ::std::string::String,
    pub active_state: ::protobuf::SingularPtrField<ListenersConfigDump_DynamicListenerState>,
    pub warming_state: ::protobuf::SingularPtrField<ListenersConfigDump_DynamicListenerState>,
    pub draining_state: ::protobuf::SingularPtrField<ListenersConfigDump_DynamicListenerState>,
    pub error_state: ::protobuf::SingularPtrField<UpdateFailureState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListenersConfigDump_DynamicListener {
    fn default() -> &'a ListenersConfigDump_DynamicListener {
        <ListenersConfigDump_DynamicListener as ::protobuf::Message>::default_instance()
    }
}

impl ListenersConfigDump_DynamicListener {
    pub fn new() -> ListenersConfigDump_DynamicListener {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState active_state = 2;


    pub fn get_active_state(&self) -> &ListenersConfigDump_DynamicListenerState {
        self.active_state.as_ref().unwrap_or_else(|| <ListenersConfigDump_DynamicListenerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_active_state(&mut self) {
        self.active_state.clear();
    }

    pub fn has_active_state(&self) -> bool {
        self.active_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_state(&mut self, v: ListenersConfigDump_DynamicListenerState) {
        self.active_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active_state(&mut self) -> &mut ListenersConfigDump_DynamicListenerState {
        if self.active_state.is_none() {
            self.active_state.set_default();
        }
        self.active_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_active_state(&mut self) -> ListenersConfigDump_DynamicListenerState {
        self.active_state.take().unwrap_or_else(|| ListenersConfigDump_DynamicListenerState::new())
    }

    // .envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState warming_state = 3;


    pub fn get_warming_state(&self) -> &ListenersConfigDump_DynamicListenerState {
        self.warming_state.as_ref().unwrap_or_else(|| <ListenersConfigDump_DynamicListenerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_warming_state(&mut self) {
        self.warming_state.clear();
    }

    pub fn has_warming_state(&self) -> bool {
        self.warming_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_warming_state(&mut self, v: ListenersConfigDump_DynamicListenerState) {
        self.warming_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_warming_state(&mut self) -> &mut ListenersConfigDump_DynamicListenerState {
        if self.warming_state.is_none() {
            self.warming_state.set_default();
        }
        self.warming_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_warming_state(&mut self) -> ListenersConfigDump_DynamicListenerState {
        self.warming_state.take().unwrap_or_else(|| ListenersConfigDump_DynamicListenerState::new())
    }

    // .envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerState draining_state = 4;


    pub fn get_draining_state(&self) -> &ListenersConfigDump_DynamicListenerState {
        self.draining_state.as_ref().unwrap_or_else(|| <ListenersConfigDump_DynamicListenerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_draining_state(&mut self) {
        self.draining_state.clear();
    }

    pub fn has_draining_state(&self) -> bool {
        self.draining_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_draining_state(&mut self, v: ListenersConfigDump_DynamicListenerState) {
        self.draining_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_draining_state(&mut self) -> &mut ListenersConfigDump_DynamicListenerState {
        if self.draining_state.is_none() {
            self.draining_state.set_default();
        }
        self.draining_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_draining_state(&mut self) -> ListenersConfigDump_DynamicListenerState {
        self.draining_state.take().unwrap_or_else(|| ListenersConfigDump_DynamicListenerState::new())
    }

    // .envoy.admin.v2alpha.UpdateFailureState error_state = 5;


    pub fn get_error_state(&self) -> &UpdateFailureState {
        self.error_state.as_ref().unwrap_or_else(|| <UpdateFailureState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_error_state(&mut self) {
        self.error_state.clear();
    }

    pub fn has_error_state(&self) -> bool {
        self.error_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_state(&mut self, v: UpdateFailureState) {
        self.error_state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_state(&mut self) -> &mut UpdateFailureState {
        if self.error_state.is_none() {
            self.error_state.set_default();
        }
        self.error_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_state(&mut self) -> UpdateFailureState {
        self.error_state.take().unwrap_or_else(|| UpdateFailureState::new())
    }
}

impl ::protobuf::Message for ListenersConfigDump_DynamicListener {
    fn is_initialized(&self) -> bool {
        for v in &self.active_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.warming_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.draining_state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.error_state {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.active_state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.warming_state)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.draining_state)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.error_state)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.active_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.warming_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.draining_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.active_state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.warming_state.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.draining_state.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error_state.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListenersConfigDump_DynamicListener {
        ListenersConfigDump_DynamicListener::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ListenersConfigDump_DynamicListener| { &m.name },
                |m: &mut ListenersConfigDump_DynamicListener| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListenersConfigDump_DynamicListenerState>>(
                "active_state",
                |m: &ListenersConfigDump_DynamicListener| { &m.active_state },
                |m: &mut ListenersConfigDump_DynamicListener| { &mut m.active_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListenersConfigDump_DynamicListenerState>>(
                "warming_state",
                |m: &ListenersConfigDump_DynamicListener| { &m.warming_state },
                |m: &mut ListenersConfigDump_DynamicListener| { &mut m.warming_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListenersConfigDump_DynamicListenerState>>(
                "draining_state",
                |m: &ListenersConfigDump_DynamicListener| { &m.draining_state },
                |m: &mut ListenersConfigDump_DynamicListener| { &mut m.draining_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UpdateFailureState>>(
                "error_state",
                |m: &ListenersConfigDump_DynamicListener| { &m.error_state },
                |m: &mut ListenersConfigDump_DynamicListener| { &mut m.error_state },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListenersConfigDump_DynamicListener>(
                "ListenersConfigDump.DynamicListener",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListenersConfigDump_DynamicListener {
        static instance: ::protobuf::rt::LazyV2<ListenersConfigDump_DynamicListener> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListenersConfigDump_DynamicListener::new)
    }
}

impl ::protobuf::Clear for ListenersConfigDump_DynamicListener {
    fn clear(&mut self) {
        self.name.clear();
        self.active_state.clear();
        self.warming_state.clear();
        self.draining_state.clear();
        self.error_state.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListenersConfigDump_DynamicListener {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListenersConfigDump_DynamicListener {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClustersConfigDump {
    // message fields
    pub version_info: ::std::string::String,
    pub static_clusters: ::protobuf::RepeatedField<ClustersConfigDump_StaticCluster>,
    pub dynamic_active_clusters: ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster>,
    pub dynamic_warming_clusters: ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClustersConfigDump {
    fn default() -> &'a ClustersConfigDump {
        <ClustersConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl ClustersConfigDump {
    pub fn new() -> ClustersConfigDump {
        ::std::default::Default::default()
    }

    // string version_info = 1;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // repeated .envoy.admin.v2alpha.ClustersConfigDump.StaticCluster static_clusters = 2;


    pub fn get_static_clusters(&self) -> &[ClustersConfigDump_StaticCluster] {
        &self.static_clusters
    }
    pub fn clear_static_clusters(&mut self) {
        self.static_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_static_clusters(&mut self, v: ::protobuf::RepeatedField<ClustersConfigDump_StaticCluster>) {
        self.static_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_static_clusters(&mut self) -> &mut ::protobuf::RepeatedField<ClustersConfigDump_StaticCluster> {
        &mut self.static_clusters
    }

    // Take field
    pub fn take_static_clusters(&mut self) -> ::protobuf::RepeatedField<ClustersConfigDump_StaticCluster> {
        ::std::mem::replace(&mut self.static_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_active_clusters = 3;


    pub fn get_dynamic_active_clusters(&self) -> &[ClustersConfigDump_DynamicCluster] {
        &self.dynamic_active_clusters
    }
    pub fn clear_dynamic_active_clusters(&mut self) {
        self.dynamic_active_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_active_clusters(&mut self, v: ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster>) {
        self.dynamic_active_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_active_clusters(&mut self) -> &mut ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster> {
        &mut self.dynamic_active_clusters
    }

    // Take field
    pub fn take_dynamic_active_clusters(&mut self) -> ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster> {
        ::std::mem::replace(&mut self.dynamic_active_clusters, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.ClustersConfigDump.DynamicCluster dynamic_warming_clusters = 4;


    pub fn get_dynamic_warming_clusters(&self) -> &[ClustersConfigDump_DynamicCluster] {
        &self.dynamic_warming_clusters
    }
    pub fn clear_dynamic_warming_clusters(&mut self) {
        self.dynamic_warming_clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_warming_clusters(&mut self, v: ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster>) {
        self.dynamic_warming_clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_warming_clusters(&mut self) -> &mut ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster> {
        &mut self.dynamic_warming_clusters
    }

    // Take field
    pub fn take_dynamic_warming_clusters(&mut self) -> ::protobuf::RepeatedField<ClustersConfigDump_DynamicCluster> {
        ::std::mem::replace(&mut self.dynamic_warming_clusters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClustersConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.static_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_active_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_warming_clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.static_clusters)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_active_clusters)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_warming_clusters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_info);
        }
        for value in &self.static_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_active_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_warming_clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_info.is_empty() {
            os.write_string(1, &self.version_info)?;
        }
        for v in &self.static_clusters {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_active_clusters {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_warming_clusters {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClustersConfigDump {
        ClustersConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &ClustersConfigDump| { &m.version_info },
                |m: &mut ClustersConfigDump| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClustersConfigDump_StaticCluster>>(
                "static_clusters",
                |m: &ClustersConfigDump| { &m.static_clusters },
                |m: &mut ClustersConfigDump| { &mut m.static_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClustersConfigDump_DynamicCluster>>(
                "dynamic_active_clusters",
                |m: &ClustersConfigDump| { &m.dynamic_active_clusters },
                |m: &mut ClustersConfigDump| { &mut m.dynamic_active_clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClustersConfigDump_DynamicCluster>>(
                "dynamic_warming_clusters",
                |m: &ClustersConfigDump| { &m.dynamic_warming_clusters },
                |m: &mut ClustersConfigDump| { &mut m.dynamic_warming_clusters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClustersConfigDump>(
                "ClustersConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClustersConfigDump {
        static instance: ::protobuf::rt::LazyV2<ClustersConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClustersConfigDump::new)
    }
}

impl ::protobuf::Clear for ClustersConfigDump {
    fn clear(&mut self) {
        self.version_info.clear();
        self.static_clusters.clear();
        self.dynamic_active_clusters.clear();
        self.dynamic_warming_clusters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClustersConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClustersConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClustersConfigDump_StaticCluster {
    // message fields
    pub cluster: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClustersConfigDump_StaticCluster {
    fn default() -> &'a ClustersConfigDump_StaticCluster {
        <ClustersConfigDump_StaticCluster as ::protobuf::Message>::default_instance()
    }
}

impl ClustersConfigDump_StaticCluster {
    pub fn new() -> ClustersConfigDump_StaticCluster {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any cluster = 1;


    pub fn get_cluster(&self) -> &::protobuf::well_known_types::Any {
        self.cluster.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::protobuf::well_known_types::Any) {
        self.cluster = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.cluster.is_none() {
            self.cluster.set_default();
        }
        self.cluster.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::protobuf::well_known_types::Any {
        self.cluster.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_updated = 2;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ClustersConfigDump_StaticCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.cluster.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClustersConfigDump_StaticCluster {
        ClustersConfigDump_StaticCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "cluster",
                |m: &ClustersConfigDump_StaticCluster| { &m.cluster },
                |m: &mut ClustersConfigDump_StaticCluster| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &ClustersConfigDump_StaticCluster| { &m.last_updated },
                |m: &mut ClustersConfigDump_StaticCluster| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClustersConfigDump_StaticCluster>(
                "ClustersConfigDump.StaticCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClustersConfigDump_StaticCluster {
        static instance: ::protobuf::rt::LazyV2<ClustersConfigDump_StaticCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClustersConfigDump_StaticCluster::new)
    }
}

impl ::protobuf::Clear for ClustersConfigDump_StaticCluster {
    fn clear(&mut self) {
        self.cluster.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClustersConfigDump_StaticCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClustersConfigDump_StaticCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClustersConfigDump_DynamicCluster {
    // message fields
    pub version_info: ::std::string::String,
    pub cluster: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClustersConfigDump_DynamicCluster {
    fn default() -> &'a ClustersConfigDump_DynamicCluster {
        <ClustersConfigDump_DynamicCluster as ::protobuf::Message>::default_instance()
    }
}

impl ClustersConfigDump_DynamicCluster {
    pub fn new() -> ClustersConfigDump_DynamicCluster {
        ::std::default::Default::default()
    }

    // string version_info = 1;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // .google.protobuf.Any cluster = 2;


    pub fn get_cluster(&self) -> &::protobuf::well_known_types::Any {
        self.cluster.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: ::protobuf::well_known_types::Any) {
        self.cluster = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.cluster.is_none() {
            self.cluster.set_default();
        }
        self.cluster.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster(&mut self) -> ::protobuf::well_known_types::Any {
        self.cluster.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_updated = 3;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ClustersConfigDump_DynamicCluster {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_info);
        }
        if let Some(ref v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_info.is_empty() {
            os.write_string(1, &self.version_info)?;
        }
        if let Some(ref v) = self.cluster.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClustersConfigDump_DynamicCluster {
        ClustersConfigDump_DynamicCluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &ClustersConfigDump_DynamicCluster| { &m.version_info },
                |m: &mut ClustersConfigDump_DynamicCluster| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "cluster",
                |m: &ClustersConfigDump_DynamicCluster| { &m.cluster },
                |m: &mut ClustersConfigDump_DynamicCluster| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &ClustersConfigDump_DynamicCluster| { &m.last_updated },
                |m: &mut ClustersConfigDump_DynamicCluster| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClustersConfigDump_DynamicCluster>(
                "ClustersConfigDump.DynamicCluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClustersConfigDump_DynamicCluster {
        static instance: ::protobuf::rt::LazyV2<ClustersConfigDump_DynamicCluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClustersConfigDump_DynamicCluster::new)
    }
}

impl ::protobuf::Clear for ClustersConfigDump_DynamicCluster {
    fn clear(&mut self) {
        self.version_info.clear();
        self.cluster.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClustersConfigDump_DynamicCluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClustersConfigDump_DynamicCluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutesConfigDump {
    // message fields
    pub static_route_configs: ::protobuf::RepeatedField<RoutesConfigDump_StaticRouteConfig>,
    pub dynamic_route_configs: ::protobuf::RepeatedField<RoutesConfigDump_DynamicRouteConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutesConfigDump {
    fn default() -> &'a RoutesConfigDump {
        <RoutesConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl RoutesConfigDump {
    pub fn new() -> RoutesConfigDump {
        ::std::default::Default::default()
    }

    // repeated .envoy.admin.v2alpha.RoutesConfigDump.StaticRouteConfig static_route_configs = 2;


    pub fn get_static_route_configs(&self) -> &[RoutesConfigDump_StaticRouteConfig] {
        &self.static_route_configs
    }
    pub fn clear_static_route_configs(&mut self) {
        self.static_route_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_static_route_configs(&mut self, v: ::protobuf::RepeatedField<RoutesConfigDump_StaticRouteConfig>) {
        self.static_route_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_static_route_configs(&mut self) -> &mut ::protobuf::RepeatedField<RoutesConfigDump_StaticRouteConfig> {
        &mut self.static_route_configs
    }

    // Take field
    pub fn take_static_route_configs(&mut self) -> ::protobuf::RepeatedField<RoutesConfigDump_StaticRouteConfig> {
        ::std::mem::replace(&mut self.static_route_configs, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.RoutesConfigDump.DynamicRouteConfig dynamic_route_configs = 3;


    pub fn get_dynamic_route_configs(&self) -> &[RoutesConfigDump_DynamicRouteConfig] {
        &self.dynamic_route_configs
    }
    pub fn clear_dynamic_route_configs(&mut self) {
        self.dynamic_route_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_route_configs(&mut self, v: ::protobuf::RepeatedField<RoutesConfigDump_DynamicRouteConfig>) {
        self.dynamic_route_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_route_configs(&mut self) -> &mut ::protobuf::RepeatedField<RoutesConfigDump_DynamicRouteConfig> {
        &mut self.dynamic_route_configs
    }

    // Take field
    pub fn take_dynamic_route_configs(&mut self) -> ::protobuf::RepeatedField<RoutesConfigDump_DynamicRouteConfig> {
        ::std::mem::replace(&mut self.dynamic_route_configs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoutesConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.static_route_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_route_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.static_route_configs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_route_configs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.static_route_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_route_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.static_route_configs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_route_configs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutesConfigDump {
        RoutesConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutesConfigDump_StaticRouteConfig>>(
                "static_route_configs",
                |m: &RoutesConfigDump| { &m.static_route_configs },
                |m: &mut RoutesConfigDump| { &mut m.static_route_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutesConfigDump_DynamicRouteConfig>>(
                "dynamic_route_configs",
                |m: &RoutesConfigDump| { &m.dynamic_route_configs },
                |m: &mut RoutesConfigDump| { &mut m.dynamic_route_configs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutesConfigDump>(
                "RoutesConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutesConfigDump {
        static instance: ::protobuf::rt::LazyV2<RoutesConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutesConfigDump::new)
    }
}

impl ::protobuf::Clear for RoutesConfigDump {
    fn clear(&mut self) {
        self.static_route_configs.clear();
        self.dynamic_route_configs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutesConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutesConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutesConfigDump_StaticRouteConfig {
    // message fields
    pub route_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutesConfigDump_StaticRouteConfig {
    fn default() -> &'a RoutesConfigDump_StaticRouteConfig {
        <RoutesConfigDump_StaticRouteConfig as ::protobuf::Message>::default_instance()
    }
}

impl RoutesConfigDump_StaticRouteConfig {
    pub fn new() -> RoutesConfigDump_StaticRouteConfig {
        ::std::default::Default::default()
    }

    // .google.protobuf.Any route_config = 1;


    pub fn get_route_config(&self) -> &::protobuf::well_known_types::Any {
        self.route_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_route_config(&mut self) {
        self.route_config.clear();
    }

    pub fn has_route_config(&self) -> bool {
        self.route_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.route_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.route_config.is_none() {
            self.route_config.set_default();
        }
        self.route_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.route_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_updated = 2;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for RoutesConfigDump_StaticRouteConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.route_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_config)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.route_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.route_config.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutesConfigDump_StaticRouteConfig {
        RoutesConfigDump_StaticRouteConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "route_config",
                |m: &RoutesConfigDump_StaticRouteConfig| { &m.route_config },
                |m: &mut RoutesConfigDump_StaticRouteConfig| { &mut m.route_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &RoutesConfigDump_StaticRouteConfig| { &m.last_updated },
                |m: &mut RoutesConfigDump_StaticRouteConfig| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutesConfigDump_StaticRouteConfig>(
                "RoutesConfigDump.StaticRouteConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutesConfigDump_StaticRouteConfig {
        static instance: ::protobuf::rt::LazyV2<RoutesConfigDump_StaticRouteConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutesConfigDump_StaticRouteConfig::new)
    }
}

impl ::protobuf::Clear for RoutesConfigDump_StaticRouteConfig {
    fn clear(&mut self) {
        self.route_config.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutesConfigDump_StaticRouteConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutesConfigDump_StaticRouteConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutesConfigDump_DynamicRouteConfig {
    // message fields
    pub version_info: ::std::string::String,
    pub route_config: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutesConfigDump_DynamicRouteConfig {
    fn default() -> &'a RoutesConfigDump_DynamicRouteConfig {
        <RoutesConfigDump_DynamicRouteConfig as ::protobuf::Message>::default_instance()
    }
}

impl RoutesConfigDump_DynamicRouteConfig {
    pub fn new() -> RoutesConfigDump_DynamicRouteConfig {
        ::std::default::Default::default()
    }

    // string version_info = 1;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // .google.protobuf.Any route_config = 2;


    pub fn get_route_config(&self) -> &::protobuf::well_known_types::Any {
        self.route_config.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_route_config(&mut self) {
        self.route_config.clear();
    }

    pub fn has_route_config(&self) -> bool {
        self.route_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_route_config(&mut self, v: ::protobuf::well_known_types::Any) {
        self.route_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_route_config(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.route_config.is_none() {
            self.route_config.set_default();
        }
        self.route_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_route_config(&mut self) -> ::protobuf::well_known_types::Any {
        self.route_config.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // .google.protobuf.Timestamp last_updated = 3;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for RoutesConfigDump_DynamicRouteConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.route_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.route_config)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version_info);
        }
        if let Some(ref v) = self.route_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version_info.is_empty() {
            os.write_string(1, &self.version_info)?;
        }
        if let Some(ref v) = self.route_config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutesConfigDump_DynamicRouteConfig {
        RoutesConfigDump_DynamicRouteConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &RoutesConfigDump_DynamicRouteConfig| { &m.version_info },
                |m: &mut RoutesConfigDump_DynamicRouteConfig| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "route_config",
                |m: &RoutesConfigDump_DynamicRouteConfig| { &m.route_config },
                |m: &mut RoutesConfigDump_DynamicRouteConfig| { &mut m.route_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &RoutesConfigDump_DynamicRouteConfig| { &m.last_updated },
                |m: &mut RoutesConfigDump_DynamicRouteConfig| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutesConfigDump_DynamicRouteConfig>(
                "RoutesConfigDump.DynamicRouteConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutesConfigDump_DynamicRouteConfig {
        static instance: ::protobuf::rt::LazyV2<RoutesConfigDump_DynamicRouteConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutesConfigDump_DynamicRouteConfig::new)
    }
}

impl ::protobuf::Clear for RoutesConfigDump_DynamicRouteConfig {
    fn clear(&mut self) {
        self.version_info.clear();
        self.route_config.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutesConfigDump_DynamicRouteConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutesConfigDump_DynamicRouteConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScopedRoutesConfigDump {
    // message fields
    pub inline_scoped_route_configs: ::protobuf::RepeatedField<ScopedRoutesConfigDump_InlineScopedRouteConfigs>,
    pub dynamic_scoped_route_configs: ::protobuf::RepeatedField<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScopedRoutesConfigDump {
    fn default() -> &'a ScopedRoutesConfigDump {
        <ScopedRoutesConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl ScopedRoutesConfigDump {
    pub fn new() -> ScopedRoutesConfigDump {
        ::std::default::Default::default()
    }

    // repeated .envoy.admin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigs inline_scoped_route_configs = 1;


    pub fn get_inline_scoped_route_configs(&self) -> &[ScopedRoutesConfigDump_InlineScopedRouteConfigs] {
        &self.inline_scoped_route_configs
    }
    pub fn clear_inline_scoped_route_configs(&mut self) {
        self.inline_scoped_route_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inline_scoped_route_configs(&mut self, v: ::protobuf::RepeatedField<ScopedRoutesConfigDump_InlineScopedRouteConfigs>) {
        self.inline_scoped_route_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inline_scoped_route_configs(&mut self) -> &mut ::protobuf::RepeatedField<ScopedRoutesConfigDump_InlineScopedRouteConfigs> {
        &mut self.inline_scoped_route_configs
    }

    // Take field
    pub fn take_inline_scoped_route_configs(&mut self) -> ::protobuf::RepeatedField<ScopedRoutesConfigDump_InlineScopedRouteConfigs> {
        ::std::mem::replace(&mut self.inline_scoped_route_configs, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScopedRouteConfigs dynamic_scoped_route_configs = 2;


    pub fn get_dynamic_scoped_route_configs(&self) -> &[ScopedRoutesConfigDump_DynamicScopedRouteConfigs] {
        &self.dynamic_scoped_route_configs
    }
    pub fn clear_dynamic_scoped_route_configs(&mut self) {
        self.dynamic_scoped_route_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_scoped_route_configs(&mut self, v: ::protobuf::RepeatedField<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>) {
        self.dynamic_scoped_route_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_scoped_route_configs(&mut self) -> &mut ::protobuf::RepeatedField<ScopedRoutesConfigDump_DynamicScopedRouteConfigs> {
        &mut self.dynamic_scoped_route_configs
    }

    // Take field
    pub fn take_dynamic_scoped_route_configs(&mut self) -> ::protobuf::RepeatedField<ScopedRoutesConfigDump_DynamicScopedRouteConfigs> {
        ::std::mem::replace(&mut self.dynamic_scoped_route_configs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScopedRoutesConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.inline_scoped_route_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_scoped_route_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inline_scoped_route_configs)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_scoped_route_configs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.inline_scoped_route_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_scoped_route_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.inline_scoped_route_configs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_scoped_route_configs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScopedRoutesConfigDump {
        ScopedRoutesConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScopedRoutesConfigDump_InlineScopedRouteConfigs>>(
                "inline_scoped_route_configs",
                |m: &ScopedRoutesConfigDump| { &m.inline_scoped_route_configs },
                |m: &mut ScopedRoutesConfigDump| { &mut m.inline_scoped_route_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>>(
                "dynamic_scoped_route_configs",
                |m: &ScopedRoutesConfigDump| { &m.dynamic_scoped_route_configs },
                |m: &mut ScopedRoutesConfigDump| { &mut m.dynamic_scoped_route_configs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScopedRoutesConfigDump>(
                "ScopedRoutesConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScopedRoutesConfigDump {
        static instance: ::protobuf::rt::LazyV2<ScopedRoutesConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScopedRoutesConfigDump::new)
    }
}

impl ::protobuf::Clear for ScopedRoutesConfigDump {
    fn clear(&mut self) {
        self.inline_scoped_route_configs.clear();
        self.dynamic_scoped_route_configs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScopedRoutesConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopedRoutesConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    // message fields
    pub name: ::std::string::String,
    pub scoped_route_configs: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    fn default() -> &'a ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        <ScopedRoutesConfigDump_InlineScopedRouteConfigs as ::protobuf::Message>::default_instance()
    }
}

impl ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    pub fn new() -> ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .google.protobuf.Any scoped_route_configs = 2;


    pub fn get_scoped_route_configs(&self) -> &[::protobuf::well_known_types::Any] {
        &self.scoped_route_configs
    }
    pub fn clear_scoped_route_configs(&mut self) {
        self.scoped_route_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_scoped_route_configs(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.scoped_route_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scoped_route_configs(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.scoped_route_configs
    }

    // Take field
    pub fn take_scoped_route_configs(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.scoped_route_configs, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp last_updated = 3;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    fn is_initialized(&self) -> bool {
        for v in &self.scoped_route_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scoped_route_configs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.scoped_route_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.scoped_route_configs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        ScopedRoutesConfigDump_InlineScopedRouteConfigs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ScopedRoutesConfigDump_InlineScopedRouteConfigs| { &m.name },
                |m: &mut ScopedRoutesConfigDump_InlineScopedRouteConfigs| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "scoped_route_configs",
                |m: &ScopedRoutesConfigDump_InlineScopedRouteConfigs| { &m.scoped_route_configs },
                |m: &mut ScopedRoutesConfigDump_InlineScopedRouteConfigs| { &mut m.scoped_route_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &ScopedRoutesConfigDump_InlineScopedRouteConfigs| { &m.last_updated },
                |m: &mut ScopedRoutesConfigDump_InlineScopedRouteConfigs| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScopedRoutesConfigDump_InlineScopedRouteConfigs>(
                "ScopedRoutesConfigDump.InlineScopedRouteConfigs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScopedRoutesConfigDump_InlineScopedRouteConfigs {
        static instance: ::protobuf::rt::LazyV2<ScopedRoutesConfigDump_InlineScopedRouteConfigs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScopedRoutesConfigDump_InlineScopedRouteConfigs::new)
    }
}

impl ::protobuf::Clear for ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    fn clear(&mut self) {
        self.name.clear();
        self.scoped_route_configs.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopedRoutesConfigDump_InlineScopedRouteConfigs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    // message fields
    pub name: ::std::string::String,
    pub version_info: ::std::string::String,
    pub scoped_route_configs: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    fn default() -> &'a ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        <ScopedRoutesConfigDump_DynamicScopedRouteConfigs as ::protobuf::Message>::default_instance()
    }
}

impl ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    pub fn new() -> ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version_info = 2;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // repeated .google.protobuf.Any scoped_route_configs = 3;


    pub fn get_scoped_route_configs(&self) -> &[::protobuf::well_known_types::Any] {
        &self.scoped_route_configs
    }
    pub fn clear_scoped_route_configs(&mut self) {
        self.scoped_route_configs.clear();
    }

    // Param is passed by value, moved
    pub fn set_scoped_route_configs(&mut self, v: ::protobuf::RepeatedField<::protobuf::well_known_types::Any>) {
        self.scoped_route_configs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scoped_route_configs(&mut self) -> &mut ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        &mut self.scoped_route_configs
    }

    // Take field
    pub fn take_scoped_route_configs(&mut self) -> ::protobuf::RepeatedField<::protobuf::well_known_types::Any> {
        ::std::mem::replace(&mut self.scoped_route_configs, ::protobuf::RepeatedField::new())
    }

    // .google.protobuf.Timestamp last_updated = 4;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    fn is_initialized(&self) -> bool {
        for v in &self.scoped_route_configs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.scoped_route_configs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version_info);
        }
        for value in &self.scoped_route_configs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version_info.is_empty() {
            os.write_string(2, &self.version_info)?;
        }
        for v in &self.scoped_route_configs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        ScopedRoutesConfigDump_DynamicScopedRouteConfigs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &m.name },
                |m: &mut ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &m.version_info },
                |m: &mut ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "scoped_route_configs",
                |m: &ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &m.scoped_route_configs },
                |m: &mut ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &mut m.scoped_route_configs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &m.last_updated },
                |m: &mut ScopedRoutesConfigDump_DynamicScopedRouteConfigs| { &mut m.last_updated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScopedRoutesConfigDump_DynamicScopedRouteConfigs>(
                "ScopedRoutesConfigDump.DynamicScopedRouteConfigs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
        static instance: ::protobuf::rt::LazyV2<ScopedRoutesConfigDump_DynamicScopedRouteConfigs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScopedRoutesConfigDump_DynamicScopedRouteConfigs::new)
    }
}

impl ::protobuf::Clear for ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    fn clear(&mut self) {
        self.name.clear();
        self.version_info.clear();
        self.scoped_route_configs.clear();
        self.last_updated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopedRoutesConfigDump_DynamicScopedRouteConfigs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsConfigDump {
    // message fields
    pub static_secrets: ::protobuf::RepeatedField<SecretsConfigDump_StaticSecret>,
    pub dynamic_active_secrets: ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret>,
    pub dynamic_warming_secrets: ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsConfigDump {
    fn default() -> &'a SecretsConfigDump {
        <SecretsConfigDump as ::protobuf::Message>::default_instance()
    }
}

impl SecretsConfigDump {
    pub fn new() -> SecretsConfigDump {
        ::std::default::Default::default()
    }

    // repeated .envoy.admin.v2alpha.SecretsConfigDump.StaticSecret static_secrets = 1;


    pub fn get_static_secrets(&self) -> &[SecretsConfigDump_StaticSecret] {
        &self.static_secrets
    }
    pub fn clear_static_secrets(&mut self) {
        self.static_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_static_secrets(&mut self, v: ::protobuf::RepeatedField<SecretsConfigDump_StaticSecret>) {
        self.static_secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_static_secrets(&mut self) -> &mut ::protobuf::RepeatedField<SecretsConfigDump_StaticSecret> {
        &mut self.static_secrets
    }

    // Take field
    pub fn take_static_secrets(&mut self) -> ::protobuf::RepeatedField<SecretsConfigDump_StaticSecret> {
        ::std::mem::replace(&mut self.static_secrets, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_active_secrets = 2;


    pub fn get_dynamic_active_secrets(&self) -> &[SecretsConfigDump_DynamicSecret] {
        &self.dynamic_active_secrets
    }
    pub fn clear_dynamic_active_secrets(&mut self) {
        self.dynamic_active_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_active_secrets(&mut self, v: ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret>) {
        self.dynamic_active_secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_active_secrets(&mut self) -> &mut ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret> {
        &mut self.dynamic_active_secrets
    }

    // Take field
    pub fn take_dynamic_active_secrets(&mut self) -> ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret> {
        ::std::mem::replace(&mut self.dynamic_active_secrets, ::protobuf::RepeatedField::new())
    }

    // repeated .envoy.admin.v2alpha.SecretsConfigDump.DynamicSecret dynamic_warming_secrets = 3;


    pub fn get_dynamic_warming_secrets(&self) -> &[SecretsConfigDump_DynamicSecret] {
        &self.dynamic_warming_secrets
    }
    pub fn clear_dynamic_warming_secrets(&mut self) {
        self.dynamic_warming_secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_warming_secrets(&mut self, v: ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret>) {
        self.dynamic_warming_secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_warming_secrets(&mut self) -> &mut ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret> {
        &mut self.dynamic_warming_secrets
    }

    // Take field
    pub fn take_dynamic_warming_secrets(&mut self) -> ::protobuf::RepeatedField<SecretsConfigDump_DynamicSecret> {
        ::std::mem::replace(&mut self.dynamic_warming_secrets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SecretsConfigDump {
    fn is_initialized(&self) -> bool {
        for v in &self.static_secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_active_secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_warming_secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.static_secrets)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_active_secrets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dynamic_warming_secrets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.static_secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_active_secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.dynamic_warming_secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.static_secrets {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_active_secrets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.dynamic_warming_secrets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsConfigDump {
        SecretsConfigDump::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretsConfigDump_StaticSecret>>(
                "static_secrets",
                |m: &SecretsConfigDump| { &m.static_secrets },
                |m: &mut SecretsConfigDump| { &mut m.static_secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretsConfigDump_DynamicSecret>>(
                "dynamic_active_secrets",
                |m: &SecretsConfigDump| { &m.dynamic_active_secrets },
                |m: &mut SecretsConfigDump| { &mut m.dynamic_active_secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretsConfigDump_DynamicSecret>>(
                "dynamic_warming_secrets",
                |m: &SecretsConfigDump| { &m.dynamic_warming_secrets },
                |m: &mut SecretsConfigDump| { &mut m.dynamic_warming_secrets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsConfigDump>(
                "SecretsConfigDump",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretsConfigDump {
        static instance: ::protobuf::rt::LazyV2<SecretsConfigDump> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretsConfigDump::new)
    }
}

impl ::protobuf::Clear for SecretsConfigDump {
    fn clear(&mut self) {
        self.static_secrets.clear();
        self.dynamic_active_secrets.clear();
        self.dynamic_warming_secrets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsConfigDump {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsConfigDump {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsConfigDump_DynamicSecret {
    // message fields
    pub name: ::std::string::String,
    pub version_info: ::std::string::String,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub secret: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsConfigDump_DynamicSecret {
    fn default() -> &'a SecretsConfigDump_DynamicSecret {
        <SecretsConfigDump_DynamicSecret as ::protobuf::Message>::default_instance()
    }
}

impl SecretsConfigDump_DynamicSecret {
    pub fn new() -> SecretsConfigDump_DynamicSecret {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version_info = 2;


    pub fn get_version_info(&self) -> &str {
        &self.version_info
    }
    pub fn clear_version_info(&mut self) {
        self.version_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_version_info(&mut self, v: ::std::string::String) {
        self.version_info = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_info(&mut self) -> &mut ::std::string::String {
        &mut self.version_info
    }

    // Take field
    pub fn take_version_info(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version_info, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp last_updated = 3;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Any secret = 4;


    pub fn get_secret(&self) -> &::protobuf::well_known_types::Any {
        self.secret.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::protobuf::well_known_types::Any) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> ::protobuf::well_known_types::Any {
        self.secret.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for SecretsConfigDump_DynamicSecret {
    fn is_initialized(&self) -> bool {
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version_info)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version_info.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version_info);
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version_info.is_empty() {
            os.write_string(2, &self.version_info)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsConfigDump_DynamicSecret {
        SecretsConfigDump_DynamicSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SecretsConfigDump_DynamicSecret| { &m.name },
                |m: &mut SecretsConfigDump_DynamicSecret| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version_info",
                |m: &SecretsConfigDump_DynamicSecret| { &m.version_info },
                |m: &mut SecretsConfigDump_DynamicSecret| { &mut m.version_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &SecretsConfigDump_DynamicSecret| { &m.last_updated },
                |m: &mut SecretsConfigDump_DynamicSecret| { &mut m.last_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "secret",
                |m: &SecretsConfigDump_DynamicSecret| { &m.secret },
                |m: &mut SecretsConfigDump_DynamicSecret| { &mut m.secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsConfigDump_DynamicSecret>(
                "SecretsConfigDump.DynamicSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretsConfigDump_DynamicSecret {
        static instance: ::protobuf::rt::LazyV2<SecretsConfigDump_DynamicSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretsConfigDump_DynamicSecret::new)
    }
}

impl ::protobuf::Clear for SecretsConfigDump_DynamicSecret {
    fn clear(&mut self) {
        self.name.clear();
        self.version_info.clear();
        self.last_updated.clear();
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsConfigDump_DynamicSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsConfigDump_DynamicSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretsConfigDump_StaticSecret {
    // message fields
    pub name: ::std::string::String,
    pub last_updated: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub secret: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretsConfigDump_StaticSecret {
    fn default() -> &'a SecretsConfigDump_StaticSecret {
        <SecretsConfigDump_StaticSecret as ::protobuf::Message>::default_instance()
    }
}

impl SecretsConfigDump_StaticSecret {
    pub fn new() -> SecretsConfigDump_StaticSecret {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.protobuf.Timestamp last_updated = 2;


    pub fn get_last_updated(&self) -> &::protobuf::well_known_types::Timestamp {
        self.last_updated.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_last_updated(&mut self) {
        self.last_updated.clear();
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.last_updated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_updated(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.last_updated.is_none() {
            self.last_updated.set_default();
        }
        self.last_updated.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_updated(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.last_updated.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Any secret = 3;


    pub fn get_secret(&self) -> &::protobuf::well_known_types::Any {
        self.secret.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: ::protobuf::well_known_types::Any) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> ::protobuf::well_known_types::Any {
        self.secret.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }
}

impl ::protobuf::Message for SecretsConfigDump_StaticSecret {
    fn is_initialized(&self) -> bool {
        for v in &self.last_updated {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.last_updated)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.last_updated.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretsConfigDump_StaticSecret {
        SecretsConfigDump_StaticSecret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SecretsConfigDump_StaticSecret| { &m.name },
                |m: &mut SecretsConfigDump_StaticSecret| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "last_updated",
                |m: &SecretsConfigDump_StaticSecret| { &m.last_updated },
                |m: &mut SecretsConfigDump_StaticSecret| { &mut m.last_updated },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "secret",
                |m: &SecretsConfigDump_StaticSecret| { &m.secret },
                |m: &mut SecretsConfigDump_StaticSecret| { &mut m.secret },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretsConfigDump_StaticSecret>(
                "SecretsConfigDump.StaticSecret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretsConfigDump_StaticSecret {
        static instance: ::protobuf::rt::LazyV2<SecretsConfigDump_StaticSecret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretsConfigDump_StaticSecret::new)
    }
}

impl ::protobuf::Clear for SecretsConfigDump_StaticSecret {
    fn clear(&mut self) {
        self.name.clear();
        self.last_updated.clear();
        self.secret.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretsConfigDump_StaticSecret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretsConfigDump_StaticSecret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%envoy/admin/v2alpha/config_dump.proto\x12\x13envoy.admin.v2alpha\x1a)\
    envoy/config/bootstrap/v2/bootstrap.proto\x1a\x19google/protobuf/any.pro\
    to\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1dudpa/annotations/status\
    .proto\"<\n\nConfigDump\x12.\n\x07configs\x18\x01\x20\x03(\x0b2\x14.goog\
    le.protobuf.AnyR\x07configs\"\xc3\x01\n\x12UpdateFailureState\x12G\n\x14\
    failed_configuration\x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x13f\
    ailedConfiguration\x12J\n\x13last_update_attempt\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x11lastUpdateAttempt\x12\x18\n\x07detail\
    s\x18\x03\x20\x01(\tR\x07details\"\x98\x01\n\x13BootstrapConfigDump\x12B\
    \n\tbootstrap\x18\x01\x20\x01(\x0b2$.envoy.config.bootstrap.v2.Bootstrap\
    R\tbootstrap\x12=\n\x0clast_updated\x18\x02\x20\x01(\x0b2\x1a.google.pro\
    tobuf.TimestampR\x0blastUpdated\"\xd2\x07\n\x13ListenersConfigDump\x12!\
    \n\x0cversion_info\x18\x01\x20\x01(\tR\x0bversionInfo\x12b\n\x10static_l\
    isteners\x18\x02\x20\x03(\x0b27.envoy.admin.v2alpha.ListenersConfigDump.\
    StaticListenerR\x0fstaticListeners\x12e\n\x11dynamic_listeners\x18\x03\
    \x20\x03(\x0b28.envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerR\
    \x10dynamicListeners\x1a\x81\x01\n\x0eStaticListener\x120\n\x08listener\
    \x18\x01\x20\x01(\x0b2\x14.google.protobuf.AnyR\x08listener\x12=\n\x0cla\
    st_updated\x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0blastU\
    pdated\x1a\xaa\x01\n\x14DynamicListenerState\x12!\n\x0cversion_info\x18\
    \x01\x20\x01(\tR\x0bversionInfo\x120\n\x08listener\x18\x02\x20\x01(\x0b2\
    \x14.google.protobuf.AnyR\x08listener\x12=\n\x0clast_updated\x18\x03\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x0blastUpdated\x1a\x9b\x03\n\
    \x0fDynamicListener\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12`\n\
    \x0cactive_state\x18\x02\x20\x01(\x0b2=.envoy.admin.v2alpha.ListenersCon\
    figDump.DynamicListenerStateR\x0bactiveState\x12b\n\rwarming_state\x18\
    \x03\x20\x01(\x0b2=.envoy.admin.v2alpha.ListenersConfigDump.DynamicListe\
    nerStateR\x0cwarmingState\x12d\n\x0edraining_state\x18\x04\x20\x01(\x0b2\
    =.envoy.admin.v2alpha.ListenersConfigDump.DynamicListenerStateR\rdrainin\
    gState\x12H\n\x0berror_state\x18\x05\x20\x01(\x0b2'.envoy.admin.v2alpha.\
    UpdateFailureStateR\nerrorState\"\x9e\x05\n\x12ClustersConfigDump\x12!\n\
    \x0cversion_info\x18\x01\x20\x01(\tR\x0bversionInfo\x12^\n\x0fstatic_clu\
    sters\x18\x02\x20\x03(\x0b25.envoy.admin.v2alpha.ClustersConfigDump.Stat\
    icClusterR\x0estaticClusters\x12n\n\x17dynamic_active_clusters\x18\x03\
    \x20\x03(\x0b26.envoy.admin.v2alpha.ClustersConfigDump.DynamicClusterR\
    \x15dynamicActiveClusters\x12p\n\x18dynamic_warming_clusters\x18\x04\x20\
    \x03(\x0b26.envoy.admin.v2alpha.ClustersConfigDump.DynamicClusterR\x16dy\
    namicWarmingClusters\x1a~\n\rStaticCluster\x12.\n\x07cluster\x18\x01\x20\
    \x01(\x0b2\x14.google.protobuf.AnyR\x07cluster\x12=\n\x0clast_updated\
    \x18\x02\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x0blastUpdated\x1a\
    \xa2\x01\n\x0eDynamicCluster\x12!\n\x0cversion_info\x18\x01\x20\x01(\tR\
    \x0bversionInfo\x12.\n\x07cluster\x18\x02\x20\x01(\x0b2\x14.google.proto\
    buf.AnyR\x07cluster\x12=\n\x0clast_updated\x18\x03\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\x0blastUpdated\"\xab\x04\n\x10RoutesConfigDump\
    \x12i\n\x14static_route_configs\x18\x02\x20\x03(\x0b27.envoy.admin.v2alp\
    ha.RoutesConfigDump.StaticRouteConfigR\x12staticRouteConfigs\x12l\n\x15d\
    ynamic_route_configs\x18\x03\x20\x03(\x0b28.envoy.admin.v2alpha.RoutesCo\
    nfigDump.DynamicRouteConfigR\x13dynamicRouteConfigs\x1a\x8b\x01\n\x11Sta\
    ticRouteConfig\x127\n\x0croute_config\x18\x01\x20\x01(\x0b2\x14.google.p\
    rotobuf.AnyR\x0brouteConfig\x12=\n\x0clast_updated\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x0blastUpdated\x1a\xaf\x01\n\x12DynamicR\
    outeConfig\x12!\n\x0cversion_info\x18\x01\x20\x01(\tR\x0bversionInfo\x12\
    7\n\x0croute_config\x18\x02\x20\x01(\x0b2\x14.google.protobuf.AnyR\x0bro\
    uteConfig\x12=\n\x0clast_updated\x18\x03\x20\x01(\x0b2\x1a.google.protob\
    uf.TimestampR\x0blastUpdated\"\xbb\x05\n\x16ScopedRoutesConfigDump\x12\
    \x83\x01\n\x1binline_scoped_route_configs\x18\x01\x20\x03(\x0b2D.envoy.a\
    dmin.v2alpha.ScopedRoutesConfigDump.InlineScopedRouteConfigsR\x18inlineS\
    copedRouteConfigs\x12\x86\x01\n\x1cdynamic_scoped_route_configs\x18\x02\
    \x20\x03(\x0b2E.envoy.admin.v2alpha.ScopedRoutesConfigDump.DynamicScoped\
    RouteConfigsR\x19dynamicScopedRouteConfigs\x1a\xb5\x01\n\x18InlineScoped\
    RouteConfigs\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12F\n\x14sco\
    ped_route_configs\x18\x02\x20\x03(\x0b2\x14.google.protobuf.AnyR\x12scop\
    edRouteConfigs\x12=\n\x0clast_updated\x18\x03\x20\x01(\x0b2\x1a.google.p\
    rotobuf.TimestampR\x0blastUpdated\x1a\xd9\x01\n\x19DynamicScopedRouteCon\
    figs\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12!\n\x0cversion_inf\
    o\x18\x02\x20\x01(\tR\x0bversionInfo\x12F\n\x14scoped_route_configs\x18\
    \x03\x20\x03(\x0b2\x14.google.protobuf.AnyR\x12scopedRouteConfigs\x12=\n\
    \x0clast_updated\x18\x04\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x0blastUpdated\"\x91\x05\n\x11SecretsConfigDump\x12Z\n\x0estatic_secret\
    s\x18\x01\x20\x03(\x0b23.envoy.admin.v2alpha.SecretsConfigDump.StaticSec\
    retR\rstaticSecrets\x12j\n\x16dynamic_active_secrets\x18\x02\x20\x03(\
    \x0b24.envoy.admin.v2alpha.SecretsConfigDump.DynamicSecretR\x14dynamicAc\
    tiveSecrets\x12l\n\x17dynamic_warming_secrets\x18\x03\x20\x03(\x0b24.env\
    oy.admin.v2alpha.SecretsConfigDump.DynamicSecretR\x15dynamicWarmingSecre\
    ts\x1a\xb3\x01\n\rDynamicSecret\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12!\n\x0cversion_info\x18\x02\x20\x01(\tR\x0bversionInfo\x12=\
    \n\x0clast_updated\x18\x03\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\
    \x0blastUpdated\x12,\n\x06secret\x18\x04\x20\x01(\x0b2\x14.google.protob\
    uf.AnyR\x06secret\x1a\x8f\x01\n\x0cStaticSecret\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12=\n\x0clast_updated\x18\x02\x20\x01(\x0b2\
    \x1a.google.protobuf.TimestampR\x0blastUpdated\x12,\n\x06secret\x18\x03\
    \x20\x01(\x0b2\x14.google.protobuf.AnyR\x06secretB>\n!io.envoyproxy.envo\
    y.admin.v2alphaB\x0fConfigDumpProtoP\x01\xba\x80\xc8\xd1\x06\x02\x10\x01\
    b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
