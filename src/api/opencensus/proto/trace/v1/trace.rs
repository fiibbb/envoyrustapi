// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `opencensus/proto/trace/v1/trace.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct Span {
    // message fields
    pub trace_id: ::std::vec::Vec<u8>,
    pub span_id: ::std::vec::Vec<u8>,
    pub tracestate: ::protobuf::SingularPtrField<Span_Tracestate>,
    pub parent_span_id: ::std::vec::Vec<u8>,
    pub name: ::protobuf::SingularPtrField<TruncatableString>,
    pub kind: Span_SpanKind,
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub attributes: ::protobuf::SingularPtrField<Span_Attributes>,
    pub stack_trace: ::protobuf::SingularPtrField<StackTrace>,
    pub time_events: ::protobuf::SingularPtrField<Span_TimeEvents>,
    pub links: ::protobuf::SingularPtrField<Span_Links>,
    pub status: ::protobuf::SingularPtrField<Status>,
    pub resource: ::protobuf::SingularPtrField<super::resource::Resource>,
    pub same_process_as_parent_span: ::protobuf::SingularPtrField<::protobuf::well_known_types::BoolValue>,
    pub child_span_count: ::protobuf::SingularPtrField<::protobuf::well_known_types::UInt32Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span {
    fn default() -> &'a Span {
        <Span as ::protobuf::Message>::default_instance()
    }
}

impl Span {
    pub fn new() -> Span {
        ::std::default::Default::default()
    }

    // bytes trace_id = 1;


    pub fn get_trace_id(&self) -> &[u8] {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.trace_id, ::std::vec::Vec::new())
    }

    // bytes span_id = 2;


    pub fn get_span_id(&self) -> &[u8] {
        &self.span_id
    }
    pub fn clear_span_id(&mut self) {
        self.span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_span_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_span_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.span_id
    }

    // Take field
    pub fn take_span_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.span_id, ::std::vec::Vec::new())
    }

    // .opencensus.proto.trace.v1.Span.Tracestate tracestate = 15;


    pub fn get_tracestate(&self) -> &Span_Tracestate {
        self.tracestate.as_ref().unwrap_or_else(|| <Span_Tracestate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tracestate(&mut self) {
        self.tracestate.clear();
    }

    pub fn has_tracestate(&self) -> bool {
        self.tracestate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracestate(&mut self, v: Span_Tracestate) {
        self.tracestate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracestate(&mut self) -> &mut Span_Tracestate {
        if self.tracestate.is_none() {
            self.tracestate.set_default();
        }
        self.tracestate.as_mut().unwrap()
    }

    // Take field
    pub fn take_tracestate(&mut self) -> Span_Tracestate {
        self.tracestate.take().unwrap_or_else(|| Span_Tracestate::new())
    }

    // bytes parent_span_id = 3;


    pub fn get_parent_span_id(&self) -> &[u8] {
        &self.parent_span_id
    }
    pub fn clear_parent_span_id(&mut self) {
        self.parent_span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_span_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.parent_span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_span_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.parent_span_id
    }

    // Take field
    pub fn take_parent_span_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.parent_span_id, ::std::vec::Vec::new())
    }

    // .opencensus.proto.trace.v1.TruncatableString name = 4;


    pub fn get_name(&self) -> &TruncatableString {
        self.name.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: TruncatableString) {
        self.name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut TruncatableString {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> TruncatableString {
        self.name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .opencensus.proto.trace.v1.Span.SpanKind kind = 14;


    pub fn get_kind(&self) -> Span_SpanKind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = Span_SpanKind::SPAN_KIND_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: Span_SpanKind) {
        self.kind = v;
    }

    // .google.protobuf.Timestamp start_time = 5;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 6;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .opencensus.proto.trace.v1.Span.Attributes attributes = 7;


    pub fn get_attributes(&self) -> &Span_Attributes {
        self.attributes.as_ref().unwrap_or_else(|| <Span_Attributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: Span_Attributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut Span_Attributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> Span_Attributes {
        self.attributes.take().unwrap_or_else(|| Span_Attributes::new())
    }

    // .opencensus.proto.trace.v1.StackTrace stack_trace = 8;


    pub fn get_stack_trace(&self) -> &StackTrace {
        self.stack_trace.as_ref().unwrap_or_else(|| <StackTrace as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stack_trace(&mut self) {
        self.stack_trace.clear();
    }

    pub fn has_stack_trace(&self) -> bool {
        self.stack_trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_trace(&mut self, v: StackTrace) {
        self.stack_trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stack_trace(&mut self) -> &mut StackTrace {
        if self.stack_trace.is_none() {
            self.stack_trace.set_default();
        }
        self.stack_trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_stack_trace(&mut self) -> StackTrace {
        self.stack_trace.take().unwrap_or_else(|| StackTrace::new())
    }

    // .opencensus.proto.trace.v1.Span.TimeEvents time_events = 9;


    pub fn get_time_events(&self) -> &Span_TimeEvents {
        self.time_events.as_ref().unwrap_or_else(|| <Span_TimeEvents as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time_events(&mut self) {
        self.time_events.clear();
    }

    pub fn has_time_events(&self) -> bool {
        self.time_events.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_events(&mut self, v: Span_TimeEvents) {
        self.time_events = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time_events(&mut self) -> &mut Span_TimeEvents {
        if self.time_events.is_none() {
            self.time_events.set_default();
        }
        self.time_events.as_mut().unwrap()
    }

    // Take field
    pub fn take_time_events(&mut self) -> Span_TimeEvents {
        self.time_events.take().unwrap_or_else(|| Span_TimeEvents::new())
    }

    // .opencensus.proto.trace.v1.Span.Links links = 10;


    pub fn get_links(&self) -> &Span_Links {
        self.links.as_ref().unwrap_or_else(|| <Span_Links as ::protobuf::Message>::default_instance())
    }
    pub fn clear_links(&mut self) {
        self.links.clear();
    }

    pub fn has_links(&self) -> bool {
        self.links.is_some()
    }

    // Param is passed by value, moved
    pub fn set_links(&mut self, v: Span_Links) {
        self.links = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_links(&mut self) -> &mut Span_Links {
        if self.links.is_none() {
            self.links.set_default();
        }
        self.links.as_mut().unwrap()
    }

    // Take field
    pub fn take_links(&mut self) -> Span_Links {
        self.links.take().unwrap_or_else(|| Span_Links::new())
    }

    // .opencensus.proto.trace.v1.Status status = 11;


    pub fn get_status(&self) -> &Status {
        self.status.as_ref().unwrap_or_else(|| <Status as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Status) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut Status {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> Status {
        self.status.take().unwrap_or_else(|| Status::new())
    }

    // .opencensus.proto.resource.v1.Resource resource = 16;


    pub fn get_resource(&self) -> &super::resource::Resource {
        self.resource.as_ref().unwrap_or_else(|| <super::resource::Resource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: super::resource::Resource) {
        self.resource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut super::resource::Resource {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> super::resource::Resource {
        self.resource.take().unwrap_or_else(|| super::resource::Resource::new())
    }

    // .google.protobuf.BoolValue same_process_as_parent_span = 12;


    pub fn get_same_process_as_parent_span(&self) -> &::protobuf::well_known_types::BoolValue {
        self.same_process_as_parent_span.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::BoolValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_same_process_as_parent_span(&mut self) {
        self.same_process_as_parent_span.clear();
    }

    pub fn has_same_process_as_parent_span(&self) -> bool {
        self.same_process_as_parent_span.is_some()
    }

    // Param is passed by value, moved
    pub fn set_same_process_as_parent_span(&mut self, v: ::protobuf::well_known_types::BoolValue) {
        self.same_process_as_parent_span = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_same_process_as_parent_span(&mut self) -> &mut ::protobuf::well_known_types::BoolValue {
        if self.same_process_as_parent_span.is_none() {
            self.same_process_as_parent_span.set_default();
        }
        self.same_process_as_parent_span.as_mut().unwrap()
    }

    // Take field
    pub fn take_same_process_as_parent_span(&mut self) -> ::protobuf::well_known_types::BoolValue {
        self.same_process_as_parent_span.take().unwrap_or_else(|| ::protobuf::well_known_types::BoolValue::new())
    }

    // .google.protobuf.UInt32Value child_span_count = 13;


    pub fn get_child_span_count(&self) -> &::protobuf::well_known_types::UInt32Value {
        self.child_span_count.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::UInt32Value as ::protobuf::Message>::default_instance())
    }
    pub fn clear_child_span_count(&mut self) {
        self.child_span_count.clear();
    }

    pub fn has_child_span_count(&self) -> bool {
        self.child_span_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_child_span_count(&mut self, v: ::protobuf::well_known_types::UInt32Value) {
        self.child_span_count = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_child_span_count(&mut self) -> &mut ::protobuf::well_known_types::UInt32Value {
        if self.child_span_count.is_none() {
            self.child_span_count.set_default();
        }
        self.child_span_count.as_mut().unwrap()
    }

    // Take field
    pub fn take_child_span_count(&mut self) -> ::protobuf::well_known_types::UInt32Value {
        self.child_span_count.take().unwrap_or_else(|| ::protobuf::well_known_types::UInt32Value::new())
    }
}

impl ::protobuf::Message for Span {
    fn is_initialized(&self) -> bool {
        for v in &self.tracestate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.stack_trace {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time_events {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.links {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.same_process_as_parent_span {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.child_span_count {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.trace_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.span_id)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tracestate)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.parent_span_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.name)?;
                },
                14 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 14, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stack_trace)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time_events)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.links)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.same_process_as_parent_span)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.child_span_count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.trace_id);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.span_id);
        }
        if let Some(ref v) = self.tracestate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.parent_span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.parent_span_id);
        }
        if let Some(ref v) = self.name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.kind != Span_SpanKind::SPAN_KIND_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(14, self.kind);
        }
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.stack_trace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.time_events.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.links.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resource.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.same_process_as_parent_span.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.child_span_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trace_id.is_empty() {
            os.write_bytes(1, &self.trace_id)?;
        }
        if !self.span_id.is_empty() {
            os.write_bytes(2, &self.span_id)?;
        }
        if let Some(ref v) = self.tracestate.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.parent_span_id.is_empty() {
            os.write_bytes(3, &self.parent_span_id)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.kind != Span_SpanKind::SPAN_KIND_UNSPECIFIED {
            os.write_enum(14, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.stack_trace.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.time_events.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.links.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.same_process_as_parent_span.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.child_span_count.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span {
        Span::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "trace_id",
                |m: &Span| { &m.trace_id },
                |m: &mut Span| { &mut m.trace_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "span_id",
                |m: &Span| { &m.span_id },
                |m: &mut Span| { &mut m.span_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Tracestate>>(
                "tracestate",
                |m: &Span| { &m.tracestate },
                |m: &mut Span| { &mut m.tracestate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "parent_span_id",
                |m: &Span| { &m.parent_span_id },
                |m: &mut Span| { &mut m.parent_span_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "name",
                |m: &Span| { &m.name },
                |m: &mut Span| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Span_SpanKind>>(
                "kind",
                |m: &Span| { &m.kind },
                |m: &mut Span| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &Span| { &m.start_time },
                |m: &mut Span| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &Span| { &m.end_time },
                |m: &mut Span| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Attributes>>(
                "attributes",
                |m: &Span| { &m.attributes },
                |m: &mut Span| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StackTrace>>(
                "stack_trace",
                |m: &Span| { &m.stack_trace },
                |m: &mut Span| { &mut m.stack_trace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_TimeEvents>>(
                "time_events",
                |m: &Span| { &m.time_events },
                |m: &mut Span| { &mut m.time_events },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Links>>(
                "links",
                |m: &Span| { &m.links },
                |m: &mut Span| { &mut m.links },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Status>>(
                "status",
                |m: &Span| { &m.status },
                |m: &mut Span| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::resource::Resource>>(
                "resource",
                |m: &Span| { &m.resource },
                |m: &mut Span| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::BoolValue>>(
                "same_process_as_parent_span",
                |m: &Span| { &m.same_process_as_parent_span },
                |m: &mut Span| { &mut m.same_process_as_parent_span },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::UInt32Value>>(
                "child_span_count",
                |m: &Span| { &m.child_span_count },
                |m: &mut Span| { &mut m.child_span_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span>(
                "Span",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span {
        static instance: ::protobuf::rt::LazyV2<Span> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span::new)
    }
}

impl ::protobuf::Clear for Span {
    fn clear(&mut self) {
        self.trace_id.clear();
        self.span_id.clear();
        self.tracestate.clear();
        self.parent_span_id.clear();
        self.name.clear();
        self.kind = Span_SpanKind::SPAN_KIND_UNSPECIFIED;
        self.start_time.clear();
        self.end_time.clear();
        self.attributes.clear();
        self.stack_trace.clear();
        self.time_events.clear();
        self.links.clear();
        self.status.clear();
        self.resource.clear();
        self.same_process_as_parent_span.clear();
        self.child_span_count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Tracestate {
    // message fields
    pub entries: ::protobuf::RepeatedField<Span_Tracestate_Entry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Tracestate {
    fn default() -> &'a Span_Tracestate {
        <Span_Tracestate as ::protobuf::Message>::default_instance()
    }
}

impl Span_Tracestate {
    pub fn new() -> Span_Tracestate {
        ::std::default::Default::default()
    }

    // repeated .opencensus.proto.trace.v1.Span.Tracestate.Entry entries = 1;


    pub fn get_entries(&self) -> &[Span_Tracestate_Entry] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<Span_Tracestate_Entry>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<Span_Tracestate_Entry> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<Span_Tracestate_Entry> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Span_Tracestate {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Tracestate {
        Span_Tracestate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Tracestate_Entry>>(
                "entries",
                |m: &Span_Tracestate| { &m.entries },
                |m: &mut Span_Tracestate| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Tracestate>(
                "Span.Tracestate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Tracestate {
        static instance: ::protobuf::rt::LazyV2<Span_Tracestate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Tracestate::new)
    }
}

impl ::protobuf::Clear for Span_Tracestate {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Tracestate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Tracestate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Tracestate_Entry {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Tracestate_Entry {
    fn default() -> &'a Span_Tracestate_Entry {
        <Span_Tracestate_Entry as ::protobuf::Message>::default_instance()
    }
}

impl Span_Tracestate_Entry {
    pub fn new() -> Span_Tracestate_Entry {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Span_Tracestate_Entry {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Tracestate_Entry {
        Span_Tracestate_Entry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Span_Tracestate_Entry| { &m.key },
                |m: &mut Span_Tracestate_Entry| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Span_Tracestate_Entry| { &m.value },
                |m: &mut Span_Tracestate_Entry| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Tracestate_Entry>(
                "Span.Tracestate.Entry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Tracestate_Entry {
        static instance: ::protobuf::rt::LazyV2<Span_Tracestate_Entry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Tracestate_Entry::new)
    }
}

impl ::protobuf::Clear for Span_Tracestate_Entry {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Tracestate_Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Tracestate_Entry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Attributes {
    // message fields
    pub attribute_map: ::std::collections::HashMap<::std::string::String, AttributeValue>,
    pub dropped_attributes_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Attributes {
    fn default() -> &'a Span_Attributes {
        <Span_Attributes as ::protobuf::Message>::default_instance()
    }
}

impl Span_Attributes {
    pub fn new() -> Span_Attributes {
        ::std::default::Default::default()
    }

    // repeated .opencensus.proto.trace.v1.Span.Attributes.AttributeMapEntry attribute_map = 1;


    pub fn get_attribute_map(&self) -> &::std::collections::HashMap<::std::string::String, AttributeValue> {
        &self.attribute_map
    }
    pub fn clear_attribute_map(&mut self) {
        self.attribute_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_attribute_map(&mut self, v: ::std::collections::HashMap<::std::string::String, AttributeValue>) {
        self.attribute_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attribute_map(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, AttributeValue> {
        &mut self.attribute_map
    }

    // Take field
    pub fn take_attribute_map(&mut self) -> ::std::collections::HashMap<::std::string::String, AttributeValue> {
        ::std::mem::replace(&mut self.attribute_map, ::std::collections::HashMap::new())
    }

    // int32 dropped_attributes_count = 2;


    pub fn get_dropped_attributes_count(&self) -> i32 {
        self.dropped_attributes_count
    }
    pub fn clear_dropped_attributes_count(&mut self) {
        self.dropped_attributes_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_attributes_count(&mut self, v: i32) {
        self.dropped_attributes_count = v;
    }
}

impl ::protobuf::Message for Span_Attributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(wire_type, is, &mut self.attribute_map)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_attributes_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(1, &self.attribute_map);
        if self.dropped_attributes_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_attributes_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(1, &self.attribute_map, os)?;
        if self.dropped_attributes_count != 0 {
            os.write_int32(2, self.dropped_attributes_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Attributes {
        Span_Attributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AttributeValue>>(
                "attribute_map",
                |m: &Span_Attributes| { &m.attribute_map },
                |m: &mut Span_Attributes| { &mut m.attribute_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dropped_attributes_count",
                |m: &Span_Attributes| { &m.dropped_attributes_count },
                |m: &mut Span_Attributes| { &mut m.dropped_attributes_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Attributes>(
                "Span.Attributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Attributes {
        static instance: ::protobuf::rt::LazyV2<Span_Attributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Attributes::new)
    }
}

impl ::protobuf::Clear for Span_Attributes {
    fn clear(&mut self) {
        self.attribute_map.clear();
        self.dropped_attributes_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Attributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Attributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvent {
    // message fields
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub value: ::std::option::Option<Span_TimeEvent_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvent {
    fn default() -> &'a Span_TimeEvent {
        <Span_TimeEvent as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Span_TimeEvent_oneof_value {
    annotation(Span_TimeEvent_Annotation),
    message_event(Span_TimeEvent_MessageEvent),
}

impl Span_TimeEvent {
    pub fn new() -> Span_TimeEvent {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp time = 1;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .opencensus.proto.trace.v1.Span.TimeEvent.Annotation annotation = 2;


    pub fn get_annotation(&self) -> &Span_TimeEvent_Annotation {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(ref v)) => v,
            _ => <Span_TimeEvent_Annotation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_annotation(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_annotation(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_annotation(&mut self, v: Span_TimeEvent_Annotation) {
        self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_annotation(&mut self) -> &mut Span_TimeEvent_Annotation {
        if let ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(Span_TimeEvent_Annotation::new()));
        }
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_annotation(&mut self) -> Span_TimeEvent_Annotation {
        if self.has_annotation() {
            match self.value.take() {
                ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(v)) => v,
                _ => panic!(),
            }
        } else {
            Span_TimeEvent_Annotation::new()
        }
    }

    // .opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent message_event = 3;


    pub fn get_message_event(&self) -> &Span_TimeEvent_MessageEvent {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(ref v)) => v,
            _ => <Span_TimeEvent_MessageEvent as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_message_event(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_message_event(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_message_event(&mut self, v: Span_TimeEvent_MessageEvent) {
        self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(v))
    }

    // Mutable pointer to the field.
    pub fn mut_message_event(&mut self) -> &mut Span_TimeEvent_MessageEvent {
        if let ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(Span_TimeEvent_MessageEvent::new()));
        }
        match self.value {
            ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_message_event(&mut self) -> Span_TimeEvent_MessageEvent {
        if self.has_message_event() {
            match self.value.take() {
                ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(v)) => v,
                _ => panic!(),
            }
        } else {
            Span_TimeEvent_MessageEvent::new()
        }
    }
}

impl ::protobuf::Message for Span_TimeEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Span_TimeEvent_oneof_value::annotation(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Span_TimeEvent_oneof_value::message_event(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::annotation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Span_TimeEvent_oneof_value::message_event(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Span_TimeEvent_oneof_value::annotation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Span_TimeEvent_oneof_value::message_event(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Span_TimeEvent_oneof_value::annotation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Span_TimeEvent_oneof_value::message_event(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvent {
        Span_TimeEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time",
                |m: &Span_TimeEvent| { &m.time },
                |m: &mut Span_TimeEvent| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Span_TimeEvent_Annotation>(
                "annotation",
                Span_TimeEvent::has_annotation,
                Span_TimeEvent::get_annotation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Span_TimeEvent_MessageEvent>(
                "message_event",
                Span_TimeEvent::has_message_event,
                Span_TimeEvent::get_message_event,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_TimeEvent>(
                "Span.TimeEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_TimeEvent {
        static instance: ::protobuf::rt::LazyV2<Span_TimeEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_TimeEvent::new)
    }
}

impl ::protobuf::Clear for Span_TimeEvent {
    fn clear(&mut self) {
        self.time.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvent_Annotation {
    // message fields
    pub description: ::protobuf::SingularPtrField<TruncatableString>,
    pub attributes: ::protobuf::SingularPtrField<Span_Attributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvent_Annotation {
    fn default() -> &'a Span_TimeEvent_Annotation {
        <Span_TimeEvent_Annotation as ::protobuf::Message>::default_instance()
    }
}

impl Span_TimeEvent_Annotation {
    pub fn new() -> Span_TimeEvent_Annotation {
        ::std::default::Default::default()
    }

    // .opencensus.proto.trace.v1.TruncatableString description = 1;


    pub fn get_description(&self) -> &TruncatableString {
        self.description.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: TruncatableString) {
        self.description = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut TruncatableString {
        if self.description.is_none() {
            self.description.set_default();
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> TruncatableString {
        self.description.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .opencensus.proto.trace.v1.Span.Attributes attributes = 2;


    pub fn get_attributes(&self) -> &Span_Attributes {
        self.attributes.as_ref().unwrap_or_else(|| <Span_Attributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: Span_Attributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut Span_Attributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> Span_Attributes {
        self.attributes.take().unwrap_or_else(|| Span_Attributes::new())
    }
}

impl ::protobuf::Message for Span_TimeEvent_Annotation {
    fn is_initialized(&self) -> bool {
        for v in &self.description {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.description)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.description.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.description.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvent_Annotation {
        Span_TimeEvent_Annotation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "description",
                |m: &Span_TimeEvent_Annotation| { &m.description },
                |m: &mut Span_TimeEvent_Annotation| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Attributes>>(
                "attributes",
                |m: &Span_TimeEvent_Annotation| { &m.attributes },
                |m: &mut Span_TimeEvent_Annotation| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_TimeEvent_Annotation>(
                "Span.TimeEvent.Annotation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_TimeEvent_Annotation {
        static instance: ::protobuf::rt::LazyV2<Span_TimeEvent_Annotation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_TimeEvent_Annotation::new)
    }
}

impl ::protobuf::Clear for Span_TimeEvent_Annotation {
    fn clear(&mut self) {
        self.description.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvent_Annotation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent_Annotation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvent_MessageEvent {
    // message fields
    pub field_type: Span_TimeEvent_MessageEvent_Type,
    pub id: u64,
    pub uncompressed_size: u64,
    pub compressed_size: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvent_MessageEvent {
    fn default() -> &'a Span_TimeEvent_MessageEvent {
        <Span_TimeEvent_MessageEvent as ::protobuf::Message>::default_instance()
    }
}

impl Span_TimeEvent_MessageEvent {
    pub fn new() -> Span_TimeEvent_MessageEvent {
        ::std::default::Default::default()
    }

    // .opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent.Type type = 1;


    pub fn get_field_type(&self) -> Span_TimeEvent_MessageEvent_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Span_TimeEvent_MessageEvent_Type) {
        self.field_type = v;
    }

    // uint64 id = 2;


    pub fn get_id(&self) -> u64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = v;
    }

    // uint64 uncompressed_size = 3;


    pub fn get_uncompressed_size(&self) -> u64 {
        self.uncompressed_size
    }
    pub fn clear_uncompressed_size(&mut self) {
        self.uncompressed_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_uncompressed_size(&mut self, v: u64) {
        self.uncompressed_size = v;
    }

    // uint64 compressed_size = 4;


    pub fn get_compressed_size(&self) -> u64 {
        self.compressed_size
    }
    pub fn clear_compressed_size(&mut self) {
        self.compressed_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_compressed_size(&mut self, v: u64) {
        self.compressed_size = v;
    }
}

impl ::protobuf::Message for Span_TimeEvent_MessageEvent {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.uncompressed_size = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.compressed_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.uncompressed_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.uncompressed_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compressed_size != 0 {
            my_size += ::protobuf::rt::value_size(4, self.compressed_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if self.id != 0 {
            os.write_uint64(2, self.id)?;
        }
        if self.uncompressed_size != 0 {
            os.write_uint64(3, self.uncompressed_size)?;
        }
        if self.compressed_size != 0 {
            os.write_uint64(4, self.compressed_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvent_MessageEvent {
        Span_TimeEvent_MessageEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Span_TimeEvent_MessageEvent_Type>>(
                "type",
                |m: &Span_TimeEvent_MessageEvent| { &m.field_type },
                |m: &mut Span_TimeEvent_MessageEvent| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "id",
                |m: &Span_TimeEvent_MessageEvent| { &m.id },
                |m: &mut Span_TimeEvent_MessageEvent| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "uncompressed_size",
                |m: &Span_TimeEvent_MessageEvent| { &m.uncompressed_size },
                |m: &mut Span_TimeEvent_MessageEvent| { &mut m.uncompressed_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "compressed_size",
                |m: &Span_TimeEvent_MessageEvent| { &m.compressed_size },
                |m: &mut Span_TimeEvent_MessageEvent| { &mut m.compressed_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_TimeEvent_MessageEvent>(
                "Span.TimeEvent.MessageEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_TimeEvent_MessageEvent {
        static instance: ::protobuf::rt::LazyV2<Span_TimeEvent_MessageEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_TimeEvent_MessageEvent::new)
    }
}

impl ::protobuf::Clear for Span_TimeEvent_MessageEvent {
    fn clear(&mut self) {
        self.field_type = Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED;
        self.id = 0;
        self.uncompressed_size = 0;
        self.compressed_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvent_MessageEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent_MessageEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Span_TimeEvent_MessageEvent_Type {
    TYPE_UNSPECIFIED = 0,
    SENT = 1,
    RECEIVED = 2,
}

impl ::protobuf::ProtobufEnum for Span_TimeEvent_MessageEvent_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Span_TimeEvent_MessageEvent_Type> {
        match value {
            0 => ::std::option::Option::Some(Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Span_TimeEvent_MessageEvent_Type::SENT),
            2 => ::std::option::Option::Some(Span_TimeEvent_MessageEvent_Type::RECEIVED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Span_TimeEvent_MessageEvent_Type] = &[
            Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED,
            Span_TimeEvent_MessageEvent_Type::SENT,
            Span_TimeEvent_MessageEvent_Type::RECEIVED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Span_TimeEvent_MessageEvent_Type>("Span.TimeEvent.MessageEvent.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Span_TimeEvent_MessageEvent_Type {
}

impl ::std::default::Default for Span_TimeEvent_MessageEvent_Type {
    fn default() -> Self {
        Span_TimeEvent_MessageEvent_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvent_MessageEvent_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_TimeEvents {
    // message fields
    pub time_event: ::protobuf::RepeatedField<Span_TimeEvent>,
    pub dropped_annotations_count: i32,
    pub dropped_message_events_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_TimeEvents {
    fn default() -> &'a Span_TimeEvents {
        <Span_TimeEvents as ::protobuf::Message>::default_instance()
    }
}

impl Span_TimeEvents {
    pub fn new() -> Span_TimeEvents {
        ::std::default::Default::default()
    }

    // repeated .opencensus.proto.trace.v1.Span.TimeEvent time_event = 1;


    pub fn get_time_event(&self) -> &[Span_TimeEvent] {
        &self.time_event
    }
    pub fn clear_time_event(&mut self) {
        self.time_event.clear();
    }

    // Param is passed by value, moved
    pub fn set_time_event(&mut self, v: ::protobuf::RepeatedField<Span_TimeEvent>) {
        self.time_event = v;
    }

    // Mutable pointer to the field.
    pub fn mut_time_event(&mut self) -> &mut ::protobuf::RepeatedField<Span_TimeEvent> {
        &mut self.time_event
    }

    // Take field
    pub fn take_time_event(&mut self) -> ::protobuf::RepeatedField<Span_TimeEvent> {
        ::std::mem::replace(&mut self.time_event, ::protobuf::RepeatedField::new())
    }

    // int32 dropped_annotations_count = 2;


    pub fn get_dropped_annotations_count(&self) -> i32 {
        self.dropped_annotations_count
    }
    pub fn clear_dropped_annotations_count(&mut self) {
        self.dropped_annotations_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_annotations_count(&mut self, v: i32) {
        self.dropped_annotations_count = v;
    }

    // int32 dropped_message_events_count = 3;


    pub fn get_dropped_message_events_count(&self) -> i32 {
        self.dropped_message_events_count
    }
    pub fn clear_dropped_message_events_count(&mut self) {
        self.dropped_message_events_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_message_events_count(&mut self, v: i32) {
        self.dropped_message_events_count = v;
    }
}

impl ::protobuf::Message for Span_TimeEvents {
    fn is_initialized(&self) -> bool {
        for v in &self.time_event {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.time_event)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_annotations_count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_message_events_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.time_event {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_annotations_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_annotations_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dropped_message_events_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.dropped_message_events_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.time_event {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_annotations_count != 0 {
            os.write_int32(2, self.dropped_annotations_count)?;
        }
        if self.dropped_message_events_count != 0 {
            os.write_int32(3, self.dropped_message_events_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_TimeEvents {
        Span_TimeEvents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_TimeEvent>>(
                "time_event",
                |m: &Span_TimeEvents| { &m.time_event },
                |m: &mut Span_TimeEvents| { &mut m.time_event },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dropped_annotations_count",
                |m: &Span_TimeEvents| { &m.dropped_annotations_count },
                |m: &mut Span_TimeEvents| { &mut m.dropped_annotations_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dropped_message_events_count",
                |m: &Span_TimeEvents| { &m.dropped_message_events_count },
                |m: &mut Span_TimeEvents| { &mut m.dropped_message_events_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_TimeEvents>(
                "Span.TimeEvents",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_TimeEvents {
        static instance: ::protobuf::rt::LazyV2<Span_TimeEvents> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_TimeEvents::new)
    }
}

impl ::protobuf::Clear for Span_TimeEvents {
    fn clear(&mut self) {
        self.time_event.clear();
        self.dropped_annotations_count = 0;
        self.dropped_message_events_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_TimeEvents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_TimeEvents {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Link {
    // message fields
    pub trace_id: ::std::vec::Vec<u8>,
    pub span_id: ::std::vec::Vec<u8>,
    pub field_type: Span_Link_Type,
    pub attributes: ::protobuf::SingularPtrField<Span_Attributes>,
    pub tracestate: ::protobuf::SingularPtrField<Span_Tracestate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Link {
    fn default() -> &'a Span_Link {
        <Span_Link as ::protobuf::Message>::default_instance()
    }
}

impl Span_Link {
    pub fn new() -> Span_Link {
        ::std::default::Default::default()
    }

    // bytes trace_id = 1;


    pub fn get_trace_id(&self) -> &[u8] {
        &self.trace_id
    }
    pub fn clear_trace_id(&mut self) {
        self.trace_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trace_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.trace_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.trace_id
    }

    // Take field
    pub fn take_trace_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.trace_id, ::std::vec::Vec::new())
    }

    // bytes span_id = 2;


    pub fn get_span_id(&self) -> &[u8] {
        &self.span_id
    }
    pub fn clear_span_id(&mut self) {
        self.span_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_span_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.span_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_span_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.span_id
    }

    // Take field
    pub fn take_span_id(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.span_id, ::std::vec::Vec::new())
    }

    // .opencensus.proto.trace.v1.Span.Link.Type type = 3;


    pub fn get_field_type(&self) -> Span_Link_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Span_Link_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Span_Link_Type) {
        self.field_type = v;
    }

    // .opencensus.proto.trace.v1.Span.Attributes attributes = 4;


    pub fn get_attributes(&self) -> &Span_Attributes {
        self.attributes.as_ref().unwrap_or_else(|| <Span_Attributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: Span_Attributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut Span_Attributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> Span_Attributes {
        self.attributes.take().unwrap_or_else(|| Span_Attributes::new())
    }

    // .opencensus.proto.trace.v1.Span.Tracestate tracestate = 5;


    pub fn get_tracestate(&self) -> &Span_Tracestate {
        self.tracestate.as_ref().unwrap_or_else(|| <Span_Tracestate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tracestate(&mut self) {
        self.tracestate.clear();
    }

    pub fn has_tracestate(&self) -> bool {
        self.tracestate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tracestate(&mut self, v: Span_Tracestate) {
        self.tracestate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tracestate(&mut self) -> &mut Span_Tracestate {
        if self.tracestate.is_none() {
            self.tracestate.set_default();
        }
        self.tracestate.as_mut().unwrap()
    }

    // Take field
    pub fn take_tracestate(&mut self) -> Span_Tracestate {
        self.tracestate.take().unwrap_or_else(|| Span_Tracestate::new())
    }
}

impl ::protobuf::Message for Span_Link {
    fn is_initialized(&self) -> bool {
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tracestate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.trace_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.span_id)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tracestate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.trace_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.trace_id);
        }
        if !self.span_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.span_id);
        }
        if self.field_type != Span_Link_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.field_type);
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tracestate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.trace_id.is_empty() {
            os.write_bytes(1, &self.trace_id)?;
        }
        if !self.span_id.is_empty() {
            os.write_bytes(2, &self.span_id)?;
        }
        if self.field_type != Span_Link_Type::TYPE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tracestate.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Link {
        Span_Link::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "trace_id",
                |m: &Span_Link| { &m.trace_id },
                |m: &mut Span_Link| { &mut m.trace_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "span_id",
                |m: &Span_Link| { &m.span_id },
                |m: &mut Span_Link| { &mut m.span_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Span_Link_Type>>(
                "type",
                |m: &Span_Link| { &m.field_type },
                |m: &mut Span_Link| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Attributes>>(
                "attributes",
                |m: &Span_Link| { &m.attributes },
                |m: &mut Span_Link| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Tracestate>>(
                "tracestate",
                |m: &Span_Link| { &m.tracestate },
                |m: &mut Span_Link| { &mut m.tracestate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Link>(
                "Span.Link",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Link {
        static instance: ::protobuf::rt::LazyV2<Span_Link> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Link::new)
    }
}

impl ::protobuf::Clear for Span_Link {
    fn clear(&mut self) {
        self.trace_id.clear();
        self.span_id.clear();
        self.field_type = Span_Link_Type::TYPE_UNSPECIFIED;
        self.attributes.clear();
        self.tracestate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Link {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Link {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Span_Link_Type {
    TYPE_UNSPECIFIED = 0,
    CHILD_LINKED_SPAN = 1,
    PARENT_LINKED_SPAN = 2,
}

impl ::protobuf::ProtobufEnum for Span_Link_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Span_Link_Type> {
        match value {
            0 => ::std::option::Option::Some(Span_Link_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Span_Link_Type::CHILD_LINKED_SPAN),
            2 => ::std::option::Option::Some(Span_Link_Type::PARENT_LINKED_SPAN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Span_Link_Type] = &[
            Span_Link_Type::TYPE_UNSPECIFIED,
            Span_Link_Type::CHILD_LINKED_SPAN,
            Span_Link_Type::PARENT_LINKED_SPAN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Span_Link_Type>("Span.Link.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Span_Link_Type {
}

impl ::std::default::Default for Span_Link_Type {
    fn default() -> Self {
        Span_Link_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Link_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Span_Links {
    // message fields
    pub link: ::protobuf::RepeatedField<Span_Link>,
    pub dropped_links_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Span_Links {
    fn default() -> &'a Span_Links {
        <Span_Links as ::protobuf::Message>::default_instance()
    }
}

impl Span_Links {
    pub fn new() -> Span_Links {
        ::std::default::Default::default()
    }

    // repeated .opencensus.proto.trace.v1.Span.Link link = 1;


    pub fn get_link(&self) -> &[Span_Link] {
        &self.link
    }
    pub fn clear_link(&mut self) {
        self.link.clear();
    }

    // Param is passed by value, moved
    pub fn set_link(&mut self, v: ::protobuf::RepeatedField<Span_Link>) {
        self.link = v;
    }

    // Mutable pointer to the field.
    pub fn mut_link(&mut self) -> &mut ::protobuf::RepeatedField<Span_Link> {
        &mut self.link
    }

    // Take field
    pub fn take_link(&mut self) -> ::protobuf::RepeatedField<Span_Link> {
        ::std::mem::replace(&mut self.link, ::protobuf::RepeatedField::new())
    }

    // int32 dropped_links_count = 2;


    pub fn get_dropped_links_count(&self) -> i32 {
        self.dropped_links_count
    }
    pub fn clear_dropped_links_count(&mut self) {
        self.dropped_links_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_links_count(&mut self, v: i32) {
        self.dropped_links_count = v;
    }
}

impl ::protobuf::Message for Span_Links {
    fn is_initialized(&self) -> bool {
        for v in &self.link {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.link)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_links_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.link {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_links_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_links_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.link {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_links_count != 0 {
            os.write_int32(2, self.dropped_links_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Span_Links {
        Span_Links::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Span_Link>>(
                "link",
                |m: &Span_Links| { &m.link },
                |m: &mut Span_Links| { &mut m.link },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dropped_links_count",
                |m: &Span_Links| { &m.dropped_links_count },
                |m: &mut Span_Links| { &mut m.dropped_links_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Span_Links>(
                "Span.Links",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Span_Links {
        static instance: ::protobuf::rt::LazyV2<Span_Links> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Span_Links::new)
    }
}

impl ::protobuf::Clear for Span_Links {
    fn clear(&mut self) {
        self.link.clear();
        self.dropped_links_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Span_Links {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_Links {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Span_SpanKind {
    SPAN_KIND_UNSPECIFIED = 0,
    SERVER = 1,
    CLIENT = 2,
}

impl ::protobuf::ProtobufEnum for Span_SpanKind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Span_SpanKind> {
        match value {
            0 => ::std::option::Option::Some(Span_SpanKind::SPAN_KIND_UNSPECIFIED),
            1 => ::std::option::Option::Some(Span_SpanKind::SERVER),
            2 => ::std::option::Option::Some(Span_SpanKind::CLIENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Span_SpanKind] = &[
            Span_SpanKind::SPAN_KIND_UNSPECIFIED,
            Span_SpanKind::SERVER,
            Span_SpanKind::CLIENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Span_SpanKind>("Span.SpanKind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Span_SpanKind {
}

impl ::std::default::Default for Span_SpanKind {
    fn default() -> Self {
        Span_SpanKind::SPAN_KIND_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Span_SpanKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub code: i32,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // int32 code = 1;


    pub fn get_code(&self) -> i32 {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = 0;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != 0 {
            my_size += ::protobuf::rt::value_size(1, self.code, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != 0 {
            os.write_int32(1, self.code)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "code",
                |m: &Status| { &m.code },
                |m: &mut Status| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Status| { &m.message },
                |m: &mut Status| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Status>(
                "Status",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Status {
        static instance: ::protobuf::rt::LazyV2<Status> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Status::new)
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.code = 0;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttributeValue {
    // message oneof groups
    pub value: ::std::option::Option<AttributeValue_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttributeValue {
    fn default() -> &'a AttributeValue {
        <AttributeValue as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum AttributeValue_oneof_value {
    string_value(TruncatableString),
    int_value(i64),
    bool_value(bool),
    double_value(f64),
}

impl AttributeValue {
    pub fn new() -> AttributeValue {
        ::std::default::Default::default()
    }

    // .opencensus.proto.trace.v1.TruncatableString string_value = 1;


    pub fn get_string_value(&self) -> &TruncatableString {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::string_value(ref v)) => v,
            _ => <TruncatableString as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_string_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::string_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: TruncatableString) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::string_value(v))
    }

    // Mutable pointer to the field.
    pub fn mut_string_value(&mut self) -> &mut TruncatableString {
        if let ::std::option::Option::Some(AttributeValue_oneof_value::string_value(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(AttributeValue_oneof_value::string_value(TruncatableString::new()));
        }
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::string_value(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_string_value(&mut self) -> TruncatableString {
        if self.has_string_value() {
            match self.value.take() {
                ::std::option::Option::Some(AttributeValue_oneof_value::string_value(v)) => v,
                _ => panic!(),
            }
        } else {
            TruncatableString::new()
        }
    }

    // int64 int_value = 2;


    pub fn get_int_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::int_value(v))
    }

    // bool bool_value = 3;


    pub fn get_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(v)) => v,
            _ => false,
        }
    }
    pub fn clear_bool_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_bool_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bool_value(&mut self, v: bool) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(v))
    }

    // double double_value = 4;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(AttributeValue_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(AttributeValue_oneof_value::double_value(v))
    }
}

impl ::protobuf::Message for AttributeValue {
    fn is_initialized(&self) -> bool {
        if let Some(AttributeValue_oneof_value::string_value(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::string_value(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::int_value(is.read_int64()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::bool_value(is.read_bool()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(AttributeValue_oneof_value::double_value(is.read_double()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &AttributeValue_oneof_value::string_value(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &AttributeValue_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
                },
                &AttributeValue_oneof_value::bool_value(v) => {
                    my_size += 2;
                },
                &AttributeValue_oneof_value::double_value(v) => {
                    my_size += 9;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &AttributeValue_oneof_value::string_value(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &AttributeValue_oneof_value::int_value(v) => {
                    os.write_int64(2, v)?;
                },
                &AttributeValue_oneof_value::bool_value(v) => {
                    os.write_bool(3, v)?;
                },
                &AttributeValue_oneof_value::double_value(v) => {
                    os.write_double(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttributeValue {
        AttributeValue::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TruncatableString>(
                "string_value",
                AttributeValue::has_string_value,
                AttributeValue::get_string_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "int_value",
                AttributeValue::has_int_value,
                AttributeValue::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "bool_value",
                AttributeValue::has_bool_value,
                AttributeValue::get_bool_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                AttributeValue::has_double_value,
                AttributeValue::get_double_value,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttributeValue>(
                "AttributeValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttributeValue {
        static instance: ::protobuf::rt::LazyV2<AttributeValue> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttributeValue::new)
    }
}

impl ::protobuf::Clear for AttributeValue {
    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttributeValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttributeValue {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StackTrace {
    // message fields
    pub stack_frames: ::protobuf::SingularPtrField<StackTrace_StackFrames>,
    pub stack_trace_hash_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StackTrace {
    fn default() -> &'a StackTrace {
        <StackTrace as ::protobuf::Message>::default_instance()
    }
}

impl StackTrace {
    pub fn new() -> StackTrace {
        ::std::default::Default::default()
    }

    // .opencensus.proto.trace.v1.StackTrace.StackFrames stack_frames = 1;


    pub fn get_stack_frames(&self) -> &StackTrace_StackFrames {
        self.stack_frames.as_ref().unwrap_or_else(|| <StackTrace_StackFrames as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stack_frames(&mut self) {
        self.stack_frames.clear();
    }

    pub fn has_stack_frames(&self) -> bool {
        self.stack_frames.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stack_frames(&mut self, v: StackTrace_StackFrames) {
        self.stack_frames = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stack_frames(&mut self) -> &mut StackTrace_StackFrames {
        if self.stack_frames.is_none() {
            self.stack_frames.set_default();
        }
        self.stack_frames.as_mut().unwrap()
    }

    // Take field
    pub fn take_stack_frames(&mut self) -> StackTrace_StackFrames {
        self.stack_frames.take().unwrap_or_else(|| StackTrace_StackFrames::new())
    }

    // uint64 stack_trace_hash_id = 2;


    pub fn get_stack_trace_hash_id(&self) -> u64 {
        self.stack_trace_hash_id
    }
    pub fn clear_stack_trace_hash_id(&mut self) {
        self.stack_trace_hash_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_stack_trace_hash_id(&mut self, v: u64) {
        self.stack_trace_hash_id = v;
    }
}

impl ::protobuf::Message for StackTrace {
    fn is_initialized(&self) -> bool {
        for v in &self.stack_frames {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stack_frames)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.stack_trace_hash_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stack_frames.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.stack_trace_hash_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.stack_trace_hash_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stack_frames.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.stack_trace_hash_id != 0 {
            os.write_uint64(2, self.stack_trace_hash_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StackTrace {
        StackTrace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StackTrace_StackFrames>>(
                "stack_frames",
                |m: &StackTrace| { &m.stack_frames },
                |m: &mut StackTrace| { &mut m.stack_frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "stack_trace_hash_id",
                |m: &StackTrace| { &m.stack_trace_hash_id },
                |m: &mut StackTrace| { &mut m.stack_trace_hash_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StackTrace>(
                "StackTrace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StackTrace {
        static instance: ::protobuf::rt::LazyV2<StackTrace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StackTrace::new)
    }
}

impl ::protobuf::Clear for StackTrace {
    fn clear(&mut self) {
        self.stack_frames.clear();
        self.stack_trace_hash_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StackTrace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTrace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StackTrace_StackFrame {
    // message fields
    pub function_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub original_function_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub file_name: ::protobuf::SingularPtrField<TruncatableString>,
    pub line_number: i64,
    pub column_number: i64,
    pub load_module: ::protobuf::SingularPtrField<Module>,
    pub source_version: ::protobuf::SingularPtrField<TruncatableString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StackTrace_StackFrame {
    fn default() -> &'a StackTrace_StackFrame {
        <StackTrace_StackFrame as ::protobuf::Message>::default_instance()
    }
}

impl StackTrace_StackFrame {
    pub fn new() -> StackTrace_StackFrame {
        ::std::default::Default::default()
    }

    // .opencensus.proto.trace.v1.TruncatableString function_name = 1;


    pub fn get_function_name(&self) -> &TruncatableString {
        self.function_name.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function_name(&mut self) {
        self.function_name.clear();
    }

    pub fn has_function_name(&self) -> bool {
        self.function_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_name(&mut self, v: TruncatableString) {
        self.function_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_name(&mut self) -> &mut TruncatableString {
        if self.function_name.is_none() {
            self.function_name.set_default();
        }
        self.function_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_name(&mut self) -> TruncatableString {
        self.function_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .opencensus.proto.trace.v1.TruncatableString original_function_name = 2;


    pub fn get_original_function_name(&self) -> &TruncatableString {
        self.original_function_name.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_original_function_name(&mut self) {
        self.original_function_name.clear();
    }

    pub fn has_original_function_name(&self) -> bool {
        self.original_function_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_function_name(&mut self, v: TruncatableString) {
        self.original_function_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_function_name(&mut self) -> &mut TruncatableString {
        if self.original_function_name.is_none() {
            self.original_function_name.set_default();
        }
        self.original_function_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_function_name(&mut self) -> TruncatableString {
        self.original_function_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .opencensus.proto.trace.v1.TruncatableString file_name = 3;


    pub fn get_file_name(&self) -> &TruncatableString {
        self.file_name.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: TruncatableString) {
        self.file_name = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut TruncatableString {
        if self.file_name.is_none() {
            self.file_name.set_default();
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> TruncatableString {
        self.file_name.take().unwrap_or_else(|| TruncatableString::new())
    }

    // int64 line_number = 4;


    pub fn get_line_number(&self) -> i64 {
        self.line_number
    }
    pub fn clear_line_number(&mut self) {
        self.line_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_number(&mut self, v: i64) {
        self.line_number = v;
    }

    // int64 column_number = 5;


    pub fn get_column_number(&self) -> i64 {
        self.column_number
    }
    pub fn clear_column_number(&mut self) {
        self.column_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_column_number(&mut self, v: i64) {
        self.column_number = v;
    }

    // .opencensus.proto.trace.v1.Module load_module = 6;


    pub fn get_load_module(&self) -> &Module {
        self.load_module.as_ref().unwrap_or_else(|| <Module as ::protobuf::Message>::default_instance())
    }
    pub fn clear_load_module(&mut self) {
        self.load_module.clear();
    }

    pub fn has_load_module(&self) -> bool {
        self.load_module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_module(&mut self, v: Module) {
        self.load_module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_load_module(&mut self) -> &mut Module {
        if self.load_module.is_none() {
            self.load_module.set_default();
        }
        self.load_module.as_mut().unwrap()
    }

    // Take field
    pub fn take_load_module(&mut self) -> Module {
        self.load_module.take().unwrap_or_else(|| Module::new())
    }

    // .opencensus.proto.trace.v1.TruncatableString source_version = 7;


    pub fn get_source_version(&self) -> &TruncatableString {
        self.source_version.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source_version(&mut self) {
        self.source_version.clear();
    }

    pub fn has_source_version(&self) -> bool {
        self.source_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_version(&mut self, v: TruncatableString) {
        self.source_version = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_version(&mut self) -> &mut TruncatableString {
        if self.source_version.is_none() {
            self.source_version.set_default();
        }
        self.source_version.as_mut().unwrap()
    }

    // Take field
    pub fn take_source_version(&mut self) -> TruncatableString {
        self.source_version.take().unwrap_or_else(|| TruncatableString::new())
    }
}

impl ::protobuf::Message for StackTrace_StackFrame {
    fn is_initialized(&self) -> bool {
        for v in &self.function_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.original_function_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.file_name {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.load_module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_function_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.file_name)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.line_number = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.column_number = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.load_module)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.function_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.original_function_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.line_number != 0 {
            my_size += ::protobuf::rt::value_size(4, self.line_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.column_number != 0 {
            my_size += ::protobuf::rt::value_size(5, self.column_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.load_module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.source_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.function_name.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.original_function_name.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.file_name.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.line_number != 0 {
            os.write_int64(4, self.line_number)?;
        }
        if self.column_number != 0 {
            os.write_int64(5, self.column_number)?;
        }
        if let Some(ref v) = self.load_module.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.source_version.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StackTrace_StackFrame {
        StackTrace_StackFrame::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "function_name",
                |m: &StackTrace_StackFrame| { &m.function_name },
                |m: &mut StackTrace_StackFrame| { &mut m.function_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "original_function_name",
                |m: &StackTrace_StackFrame| { &m.original_function_name },
                |m: &mut StackTrace_StackFrame| { &mut m.original_function_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "file_name",
                |m: &StackTrace_StackFrame| { &m.file_name },
                |m: &mut StackTrace_StackFrame| { &mut m.file_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "line_number",
                |m: &StackTrace_StackFrame| { &m.line_number },
                |m: &mut StackTrace_StackFrame| { &mut m.line_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "column_number",
                |m: &StackTrace_StackFrame| { &m.column_number },
                |m: &mut StackTrace_StackFrame| { &mut m.column_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Module>>(
                "load_module",
                |m: &StackTrace_StackFrame| { &m.load_module },
                |m: &mut StackTrace_StackFrame| { &mut m.load_module },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "source_version",
                |m: &StackTrace_StackFrame| { &m.source_version },
                |m: &mut StackTrace_StackFrame| { &mut m.source_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StackTrace_StackFrame>(
                "StackTrace.StackFrame",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StackTrace_StackFrame {
        static instance: ::protobuf::rt::LazyV2<StackTrace_StackFrame> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StackTrace_StackFrame::new)
    }
}

impl ::protobuf::Clear for StackTrace_StackFrame {
    fn clear(&mut self) {
        self.function_name.clear();
        self.original_function_name.clear();
        self.file_name.clear();
        self.line_number = 0;
        self.column_number = 0;
        self.load_module.clear();
        self.source_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StackTrace_StackFrame {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTrace_StackFrame {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StackTrace_StackFrames {
    // message fields
    pub frame: ::protobuf::RepeatedField<StackTrace_StackFrame>,
    pub dropped_frames_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StackTrace_StackFrames {
    fn default() -> &'a StackTrace_StackFrames {
        <StackTrace_StackFrames as ::protobuf::Message>::default_instance()
    }
}

impl StackTrace_StackFrames {
    pub fn new() -> StackTrace_StackFrames {
        ::std::default::Default::default()
    }

    // repeated .opencensus.proto.trace.v1.StackTrace.StackFrame frame = 1;


    pub fn get_frame(&self) -> &[StackTrace_StackFrame] {
        &self.frame
    }
    pub fn clear_frame(&mut self) {
        self.frame.clear();
    }

    // Param is passed by value, moved
    pub fn set_frame(&mut self, v: ::protobuf::RepeatedField<StackTrace_StackFrame>) {
        self.frame = v;
    }

    // Mutable pointer to the field.
    pub fn mut_frame(&mut self) -> &mut ::protobuf::RepeatedField<StackTrace_StackFrame> {
        &mut self.frame
    }

    // Take field
    pub fn take_frame(&mut self) -> ::protobuf::RepeatedField<StackTrace_StackFrame> {
        ::std::mem::replace(&mut self.frame, ::protobuf::RepeatedField::new())
    }

    // int32 dropped_frames_count = 2;


    pub fn get_dropped_frames_count(&self) -> i32 {
        self.dropped_frames_count
    }
    pub fn clear_dropped_frames_count(&mut self) {
        self.dropped_frames_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_dropped_frames_count(&mut self, v: i32) {
        self.dropped_frames_count = v;
    }
}

impl ::protobuf::Message for StackTrace_StackFrames {
    fn is_initialized(&self) -> bool {
        for v in &self.frame {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.frame)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dropped_frames_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.frame {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.dropped_frames_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.dropped_frames_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.frame {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.dropped_frames_count != 0 {
            os.write_int32(2, self.dropped_frames_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StackTrace_StackFrames {
        StackTrace_StackFrames::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StackTrace_StackFrame>>(
                "frame",
                |m: &StackTrace_StackFrames| { &m.frame },
                |m: &mut StackTrace_StackFrames| { &mut m.frame },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dropped_frames_count",
                |m: &StackTrace_StackFrames| { &m.dropped_frames_count },
                |m: &mut StackTrace_StackFrames| { &mut m.dropped_frames_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StackTrace_StackFrames>(
                "StackTrace.StackFrames",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StackTrace_StackFrames {
        static instance: ::protobuf::rt::LazyV2<StackTrace_StackFrames> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StackTrace_StackFrames::new)
    }
}

impl ::protobuf::Clear for StackTrace_StackFrames {
    fn clear(&mut self) {
        self.frame.clear();
        self.dropped_frames_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StackTrace_StackFrames {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTrace_StackFrames {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Module {
    // message fields
    pub module: ::protobuf::SingularPtrField<TruncatableString>,
    pub build_id: ::protobuf::SingularPtrField<TruncatableString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Module {
    fn default() -> &'a Module {
        <Module as ::protobuf::Message>::default_instance()
    }
}

impl Module {
    pub fn new() -> Module {
        ::std::default::Default::default()
    }

    // .opencensus.proto.trace.v1.TruncatableString module = 1;


    pub fn get_module(&self) -> &TruncatableString {
        self.module.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_module(&mut self) {
        self.module.clear();
    }

    pub fn has_module(&self) -> bool {
        self.module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_module(&mut self, v: TruncatableString) {
        self.module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module(&mut self) -> &mut TruncatableString {
        if self.module.is_none() {
            self.module.set_default();
        }
        self.module.as_mut().unwrap()
    }

    // Take field
    pub fn take_module(&mut self) -> TruncatableString {
        self.module.take().unwrap_or_else(|| TruncatableString::new())
    }

    // .opencensus.proto.trace.v1.TruncatableString build_id = 2;


    pub fn get_build_id(&self) -> &TruncatableString {
        self.build_id.as_ref().unwrap_or_else(|| <TruncatableString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_build_id(&mut self) {
        self.build_id.clear();
    }

    pub fn has_build_id(&self) -> bool {
        self.build_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_id(&mut self, v: TruncatableString) {
        self.build_id = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_build_id(&mut self) -> &mut TruncatableString {
        if self.build_id.is_none() {
            self.build_id.set_default();
        }
        self.build_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_build_id(&mut self) -> TruncatableString {
        self.build_id.take().unwrap_or_else(|| TruncatableString::new())
    }
}

impl ::protobuf::Message for Module {
    fn is_initialized(&self) -> bool {
        for v in &self.module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.build_id {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.module)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.build_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.build_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.module.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.build_id.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Module {
        Module::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "module",
                |m: &Module| { &m.module },
                |m: &mut Module| { &mut m.module },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TruncatableString>>(
                "build_id",
                |m: &Module| { &m.build_id },
                |m: &mut Module| { &mut m.build_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Module>(
                "Module",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Module {
        static instance: ::protobuf::rt::LazyV2<Module> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Module::new)
    }
}

impl ::protobuf::Clear for Module {
    fn clear(&mut self) {
        self.module.clear();
        self.build_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Module {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Module {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TruncatableString {
    // message fields
    pub value: ::std::string::String,
    pub truncated_byte_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TruncatableString {
    fn default() -> &'a TruncatableString {
        <TruncatableString as ::protobuf::Message>::default_instance()
    }
}

impl TruncatableString {
    pub fn new() -> TruncatableString {
        ::std::default::Default::default()
    }

    // string value = 1;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // int32 truncated_byte_count = 2;


    pub fn get_truncated_byte_count(&self) -> i32 {
        self.truncated_byte_count
    }
    pub fn clear_truncated_byte_count(&mut self) {
        self.truncated_byte_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_truncated_byte_count(&mut self, v: i32) {
        self.truncated_byte_count = v;
    }
}

impl ::protobuf::Message for TruncatableString {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.truncated_byte_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.value);
        }
        if self.truncated_byte_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.truncated_byte_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.value.is_empty() {
            os.write_string(1, &self.value)?;
        }
        if self.truncated_byte_count != 0 {
            os.write_int32(2, self.truncated_byte_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TruncatableString {
        TruncatableString::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &TruncatableString| { &m.value },
                |m: &mut TruncatableString| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "truncated_byte_count",
                |m: &TruncatableString| { &m.truncated_byte_count },
                |m: &mut TruncatableString| { &mut m.truncated_byte_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TruncatableString>(
                "TruncatableString",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TruncatableString {
        static instance: ::protobuf::rt::LazyV2<TruncatableString> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TruncatableString::new)
    }
}

impl ::protobuf::Clear for TruncatableString {
    fn clear(&mut self) {
        self.value.clear();
        self.truncated_byte_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TruncatableString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TruncatableString {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%opencensus/proto/trace/v1/trace.proto\x12\x19opencensus.proto.trace.v\
    1\x1a+opencensus/proto/resource/v1/resource.proto\x1a\x1fgoogle/protobuf\
    /timestamp.proto\x1a\x1egoogle/protobuf/wrappers.proto\"\x91\x16\n\x04Sp\
    an\x12\x19\n\x08trace_id\x18\x01\x20\x01(\x0cR\x07traceId\x12\x17\n\x07s\
    pan_id\x18\x02\x20\x01(\x0cR\x06spanId\x12J\n\ntracestate\x18\x0f\x20\
    \x01(\x0b2*.opencensus.proto.trace.v1.Span.TracestateR\ntracestate\x12$\
    \n\x0eparent_span_id\x18\x03\x20\x01(\x0cR\x0cparentSpanId\x12@\n\x04nam\
    e\x18\x04\x20\x01(\x0b2,.opencensus.proto.trace.v1.TruncatableStringR\
    \x04name\x12<\n\x04kind\x18\x0e\x20\x01(\x0e2(.opencensus.proto.trace.v1\
    .Span.SpanKindR\x04kind\x129\n\nstart_time\x18\x05\x20\x01(\x0b2\x1a.goo\
    gle.protobuf.TimestampR\tstartTime\x125\n\x08end_time\x18\x06\x20\x01(\
    \x0b2\x1a.google.protobuf.TimestampR\x07endTime\x12J\n\nattributes\x18\
    \x07\x20\x01(\x0b2*.opencensus.proto.trace.v1.Span.AttributesR\nattribut\
    es\x12F\n\x0bstack_trace\x18\x08\x20\x01(\x0b2%.opencensus.proto.trace.v\
    1.StackTraceR\nstackTrace\x12K\n\x0btime_events\x18\t\x20\x01(\x0b2*.ope\
    ncensus.proto.trace.v1.Span.TimeEventsR\ntimeEvents\x12;\n\x05links\x18\
    \n\x20\x01(\x0b2%.opencensus.proto.trace.v1.Span.LinksR\x05links\x129\n\
    \x06status\x18\x0b\x20\x01(\x0b2!.opencensus.proto.trace.v1.StatusR\x06s\
    tatus\x12B\n\x08resource\x18\x10\x20\x01(\x0b2&.opencensus.proto.resourc\
    e.v1.ResourceR\x08resource\x12X\n\x1bsame_process_as_parent_span\x18\x0c\
    \x20\x01(\x0b2\x1a.google.protobuf.BoolValueR\x17sameProcessAsParentSpan\
    \x12F\n\x10child_span_count\x18\r\x20\x01(\x0b2\x1c.google.protobuf.UInt\
    32ValueR\x0echildSpanCount\x1a\x89\x01\n\nTracestate\x12J\n\x07entries\
    \x18\x01\x20\x03(\x0b20.opencensus.proto.trace.v1.Span.Tracestate.EntryR\
    \x07entries\x1a/\n\x05Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x1a\x95\x02\n\nAttribut\
    es\x12a\n\rattribute_map\x18\x01\x20\x03(\x0b2<.opencensus.proto.trace.v\
    1.Span.Attributes.AttributeMapEntryR\x0cattributeMap\x128\n\x18dropped_a\
    ttributes_count\x18\x02\x20\x01(\x05R\x16droppedAttributesCount\x1aj\n\
    \x11AttributeMapEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12?\n\
    \x05value\x18\x02\x20\x01(\x0b2).opencensus.proto.trace.v1.AttributeValu\
    eR\x05value:\x028\x01\x1a\xa4\x05\n\tTimeEvent\x12.\n\x04time\x18\x01\
    \x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x04time\x12V\n\nannotation\
    \x18\x02\x20\x01(\x0b24.opencensus.proto.trace.v1.Span.TimeEvent.Annotat\
    ionH\0R\nannotation\x12]\n\rmessage_event\x18\x03\x20\x01(\x0b26.opencen\
    sus.proto.trace.v1.Span.TimeEvent.MessageEventH\0R\x0cmessageEvent\x1a\
    \xa8\x01\n\nAnnotation\x12N\n\x0bdescription\x18\x01\x20\x01(\x0b2,.open\
    census.proto.trace.v1.TruncatableStringR\x0bdescription\x12J\n\nattribut\
    es\x18\x02\x20\x01(\x0b2*.opencensus.proto.trace.v1.Span.AttributesR\nat\
    tributes\x1a\xfb\x01\n\x0cMessageEvent\x12O\n\x04type\x18\x01\x20\x01(\
    \x0e2;.opencensus.proto.trace.v1.Span.TimeEvent.MessageEvent.TypeR\x04ty\
    pe\x12\x0e\n\x02id\x18\x02\x20\x01(\x04R\x02id\x12+\n\x11uncompressed_si\
    ze\x18\x03\x20\x01(\x04R\x10uncompressedSize\x12'\n\x0fcompressed_size\
    \x18\x04\x20\x01(\x04R\x0ecompressedSize\"4\n\x04Type\x12\x14\n\x10TYPE_\
    UNSPECIFIED\x10\0\x12\x08\n\x04SENT\x10\x01\x12\x0c\n\x08RECEIVED\x10\
    \x02B\x07\n\x05value\x1a\xd3\x01\n\nTimeEvents\x12H\n\ntime_event\x18\
    \x01\x20\x03(\x0b2).opencensus.proto.trace.v1.Span.TimeEventR\ttimeEvent\
    \x12:\n\x19dropped_annotations_count\x18\x02\x20\x01(\x05R\x17droppedAnn\
    otationsCount\x12?\n\x1cdropped_message_events_count\x18\x03\x20\x01(\
    \x05R\x19droppedMessageEventsCount\x1a\xde\x02\n\x04Link\x12\x19\n\x08tr\
    ace_id\x18\x01\x20\x01(\x0cR\x07traceId\x12\x17\n\x07span_id\x18\x02\x20\
    \x01(\x0cR\x06spanId\x12=\n\x04type\x18\x03\x20\x01(\x0e2).opencensus.pr\
    oto.trace.v1.Span.Link.TypeR\x04type\x12J\n\nattributes\x18\x04\x20\x01(\
    \x0b2*.opencensus.proto.trace.v1.Span.AttributesR\nattributes\x12J\n\ntr\
    acestate\x18\x05\x20\x01(\x0b2*.opencensus.proto.trace.v1.Span.Tracestat\
    eR\ntracestate\"K\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\x10\0\x12\x15\
    \n\x11CHILD_LINKED_SPAN\x10\x01\x12\x16\n\x12PARENT_LINKED_SPAN\x10\x02\
    \x1aq\n\x05Links\x128\n\x04link\x18\x01\x20\x03(\x0b2$.opencensus.proto.\
    trace.v1.Span.LinkR\x04link\x12.\n\x13dropped_links_count\x18\x02\x20\
    \x01(\x05R\x11droppedLinksCount\"=\n\x08SpanKind\x12\x19\n\x15SPAN_KIND_\
    UNSPECIFIED\x10\0\x12\n\n\x06SERVER\x10\x01\x12\n\n\x06CLIENT\x10\x02\"6\
    \n\x06Status\x12\x12\n\x04code\x18\x01\x20\x01(\x05R\x04code\x12\x18\n\
    \x07message\x18\x02\x20\x01(\tR\x07message\"\xd1\x01\n\x0eAttributeValue\
    \x12Q\n\x0cstring_value\x18\x01\x20\x01(\x0b2,.opencensus.proto.trace.v1\
    .TruncatableStringH\0R\x0bstringValue\x12\x1d\n\tint_value\x18\x02\x20\
    \x01(\x03H\0R\x08intValue\x12\x1f\n\nbool_value\x18\x03\x20\x01(\x08H\0R\
    \tboolValue\x12#\n\x0cdouble_value\x18\x04\x20\x01(\x01H\0R\x0bdoubleVal\
    ueB\x07\n\x05value\"\x8b\x06\n\nStackTrace\x12T\n\x0cstack_frames\x18\
    \x01\x20\x01(\x0b21.opencensus.proto.trace.v1.StackTrace.StackFramesR\
    \x0bstackFrames\x12-\n\x13stack_trace_hash_id\x18\x02\x20\x01(\x04R\x10s\
    tackTraceHashId\x1a\xed\x03\n\nStackFrame\x12Q\n\rfunction_name\x18\x01\
    \x20\x01(\x0b2,.opencensus.proto.trace.v1.TruncatableStringR\x0cfunction\
    Name\x12b\n\x16original_function_name\x18\x02\x20\x01(\x0b2,.opencensus.\
    proto.trace.v1.TruncatableStringR\x14originalFunctionName\x12I\n\tfile_n\
    ame\x18\x03\x20\x01(\x0b2,.opencensus.proto.trace.v1.TruncatableStringR\
    \x08fileName\x12\x1f\n\x0bline_number\x18\x04\x20\x01(\x03R\nlineNumber\
    \x12#\n\rcolumn_number\x18\x05\x20\x01(\x03R\x0ccolumnNumber\x12B\n\x0bl\
    oad_module\x18\x06\x20\x01(\x0b2!.opencensus.proto.trace.v1.ModuleR\nloa\
    dModule\x12S\n\x0esource_version\x18\x07\x20\x01(\x0b2,.opencensus.proto\
    .trace.v1.TruncatableStringR\rsourceVersion\x1a\x87\x01\n\x0bStackFrames\
    \x12F\n\x05frame\x18\x01\x20\x03(\x0b20.opencensus.proto.trace.v1.StackT\
    race.StackFrameR\x05frame\x120\n\x14dropped_frames_count\x18\x02\x20\x01\
    (\x05R\x12droppedFramesCount\"\x97\x01\n\x06Module\x12D\n\x06module\x18\
    \x01\x20\x01(\x0b2,.opencensus.proto.trace.v1.TruncatableStringR\x06modu\
    le\x12G\n\x08build_id\x18\x02\x20\x01(\x0b2,.opencensus.proto.trace.v1.T\
    runcatableStringR\x07buildId\"[\n\x11TruncatableString\x12\x14\n\x05valu\
    e\x18\x01\x20\x01(\tR\x05value\x120\n\x14truncated_byte_count\x18\x02\
    \x20\x01(\x05R\x12truncatedByteCountB\x8c\x01\n\x1cio.opencensus.proto.t\
    race.v1B\nTraceProtoP\x01ZBgithub.com/census-instrumentation/opencensus-\
    proto/gen-go/trace/v1\xea\x02\x19OpenCensus.Proto.Trace.V1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
