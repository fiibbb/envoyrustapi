// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `opencensus/proto/stats/v1/stats.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct Tag {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tag {
    fn default() -> &'a Tag {
        <Tag as ::protobuf::Message>::default_instance()
    }
}

impl Tag {
    pub fn new() -> Tag {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Tag {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tag {
        Tag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Tag| { &m.key },
                |m: &mut Tag| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Tag| { &m.value },
                |m: &mut Tag| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tag>(
                "Tag",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tag {
        static instance: ::protobuf::rt::LazyV2<Tag> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tag::new)
    }
}

impl ::protobuf::Clear for Tag {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Measure {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub unit: ::std::string::String,
    pub field_type: Measure_Type,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Measure {
    fn default() -> &'a Measure {
        <Measure as ::protobuf::Message>::default_instance()
    }
}

impl Measure {
    pub fn new() -> Measure {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // string unit = 3;


    pub fn get_unit(&self) -> &str {
        &self.unit
    }
    pub fn clear_unit(&mut self) {
        self.unit.clear();
    }

    // Param is passed by value, moved
    pub fn set_unit(&mut self, v: ::std::string::String) {
        self.unit = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unit(&mut self) -> &mut ::std::string::String {
        &mut self.unit
    }

    // Take field
    pub fn take_unit(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.unit, ::std::string::String::new())
    }

    // .opencensus.proto.stats.v1.Measure.Type type = 4;


    pub fn get_field_type(&self) -> Measure_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = Measure_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: Measure_Type) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for Measure {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.unit)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.unit);
        }
        if self.field_type != Measure_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if !self.unit.is_empty() {
            os.write_string(3, &self.unit)?;
        }
        if self.field_type != Measure_Type::TYPE_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Measure {
        Measure::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Measure| { &m.name },
                |m: &mut Measure| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Measure| { &m.description },
                |m: &mut Measure| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "unit",
                |m: &Measure| { &m.unit },
                |m: &mut Measure| { &mut m.unit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Measure_Type>>(
                "type",
                |m: &Measure| { &m.field_type },
                |m: &mut Measure| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Measure>(
                "Measure",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Measure {
        static instance: ::protobuf::rt::LazyV2<Measure> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Measure::new)
    }
}

impl ::protobuf::Clear for Measure {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.unit.clear();
        self.field_type = Measure_Type::TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Measure {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Measure {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Measure_Type {
    TYPE_UNSPECIFIED = 0,
    INT64 = 1,
    DOUBLE = 2,
}

impl ::protobuf::ProtobufEnum for Measure_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Measure_Type> {
        match value {
            0 => ::std::option::Option::Some(Measure_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Measure_Type::INT64),
            2 => ::std::option::Option::Some(Measure_Type::DOUBLE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Measure_Type] = &[
            Measure_Type::TYPE_UNSPECIFIED,
            Measure_Type::INT64,
            Measure_Type::DOUBLE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Measure_Type>("Measure.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Measure_Type {
}

impl ::std::default::Default for Measure_Type {
    fn default() -> Self {
        Measure_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Measure_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct View {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub measure: ::protobuf::SingularPtrField<Measure>,
    pub columns: ::protobuf::RepeatedField<::std::string::String>,
    // message oneof groups
    pub aggregation: ::std::option::Option<View_oneof_aggregation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a View {
    fn default() -> &'a View {
        <View as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum View_oneof_aggregation {
    count_aggregation(CountAggregation),
    sum_aggregation(SumAggregation),
    last_value_aggregation(LastValueAggregation),
    distribution_aggregation(DistributionAggregation),
}

impl View {
    pub fn new() -> View {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // .opencensus.proto.stats.v1.Measure measure = 3;


    pub fn get_measure(&self) -> &Measure {
        self.measure.as_ref().unwrap_or_else(|| <Measure as ::protobuf::Message>::default_instance())
    }
    pub fn clear_measure(&mut self) {
        self.measure.clear();
    }

    pub fn has_measure(&self) -> bool {
        self.measure.is_some()
    }

    // Param is passed by value, moved
    pub fn set_measure(&mut self, v: Measure) {
        self.measure = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_measure(&mut self) -> &mut Measure {
        if self.measure.is_none() {
            self.measure.set_default();
        }
        self.measure.as_mut().unwrap()
    }

    // Take field
    pub fn take_measure(&mut self) -> Measure {
        self.measure.take().unwrap_or_else(|| Measure::new())
    }

    // repeated string columns = 4;


    pub fn get_columns(&self) -> &[::std::string::String] {
        &self.columns
    }
    pub fn clear_columns(&mut self) {
        self.columns.clear();
    }

    // Param is passed by value, moved
    pub fn set_columns(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.columns = v;
    }

    // Mutable pointer to the field.
    pub fn mut_columns(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.columns
    }

    // Take field
    pub fn take_columns(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.columns, ::protobuf::RepeatedField::new())
    }

    // .opencensus.proto.stats.v1.CountAggregation count_aggregation = 5;


    pub fn get_count_aggregation(&self) -> &CountAggregation {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(ref v)) => v,
            _ => <CountAggregation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_count_aggregation(&mut self) {
        self.aggregation = ::std::option::Option::None;
    }

    pub fn has_count_aggregation(&self) -> bool {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_count_aggregation(&mut self, v: CountAggregation) {
        self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_count_aggregation(&mut self) -> &mut CountAggregation {
        if let ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(_)) = self.aggregation {
        } else {
            self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(CountAggregation::new()));
        }
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_count_aggregation(&mut self) -> CountAggregation {
        if self.has_count_aggregation() {
            match self.aggregation.take() {
                ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(v)) => v,
                _ => panic!(),
            }
        } else {
            CountAggregation::new()
        }
    }

    // .opencensus.proto.stats.v1.SumAggregation sum_aggregation = 6;


    pub fn get_sum_aggregation(&self) -> &SumAggregation {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(ref v)) => v,
            _ => <SumAggregation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sum_aggregation(&mut self) {
        self.aggregation = ::std::option::Option::None;
    }

    pub fn has_sum_aggregation(&self) -> bool {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sum_aggregation(&mut self, v: SumAggregation) {
        self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sum_aggregation(&mut self) -> &mut SumAggregation {
        if let ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(_)) = self.aggregation {
        } else {
            self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(SumAggregation::new()));
        }
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sum_aggregation(&mut self) -> SumAggregation {
        if self.has_sum_aggregation() {
            match self.aggregation.take() {
                ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(v)) => v,
                _ => panic!(),
            }
        } else {
            SumAggregation::new()
        }
    }

    // .opencensus.proto.stats.v1.LastValueAggregation last_value_aggregation = 7;


    pub fn get_last_value_aggregation(&self) -> &LastValueAggregation {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(ref v)) => v,
            _ => <LastValueAggregation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_last_value_aggregation(&mut self) {
        self.aggregation = ::std::option::Option::None;
    }

    pub fn has_last_value_aggregation(&self) -> bool {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_last_value_aggregation(&mut self, v: LastValueAggregation) {
        self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_last_value_aggregation(&mut self) -> &mut LastValueAggregation {
        if let ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(_)) = self.aggregation {
        } else {
            self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(LastValueAggregation::new()));
        }
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_last_value_aggregation(&mut self) -> LastValueAggregation {
        if self.has_last_value_aggregation() {
            match self.aggregation.take() {
                ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(v)) => v,
                _ => panic!(),
            }
        } else {
            LastValueAggregation::new()
        }
    }

    // .opencensus.proto.stats.v1.DistributionAggregation distribution_aggregation = 8;


    pub fn get_distribution_aggregation(&self) -> &DistributionAggregation {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(ref v)) => v,
            _ => <DistributionAggregation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_distribution_aggregation(&mut self) {
        self.aggregation = ::std::option::Option::None;
    }

    pub fn has_distribution_aggregation(&self) -> bool {
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_distribution_aggregation(&mut self, v: DistributionAggregation) {
        self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_distribution_aggregation(&mut self) -> &mut DistributionAggregation {
        if let ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(_)) = self.aggregation {
        } else {
            self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(DistributionAggregation::new()));
        }
        match self.aggregation {
            ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_distribution_aggregation(&mut self) -> DistributionAggregation {
        if self.has_distribution_aggregation() {
            match self.aggregation.take() {
                ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(v)) => v,
                _ => panic!(),
            }
        } else {
            DistributionAggregation::new()
        }
    }
}

impl ::protobuf::Message for View {
    fn is_initialized(&self) -> bool {
        for v in &self.measure {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(View_oneof_aggregation::count_aggregation(ref v)) = self.aggregation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(View_oneof_aggregation::sum_aggregation(ref v)) = self.aggregation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(View_oneof_aggregation::last_value_aggregation(ref v)) = self.aggregation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(View_oneof_aggregation::distribution_aggregation(ref v)) = self.aggregation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.measure)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.columns)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::count_aggregation(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::sum_aggregation(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::last_value_aggregation(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.aggregation = ::std::option::Option::Some(View_oneof_aggregation::distribution_aggregation(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if let Some(ref v) = self.measure.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.columns {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let ::std::option::Option::Some(ref v) = self.aggregation {
            match v {
                &View_oneof_aggregation::count_aggregation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &View_oneof_aggregation::sum_aggregation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &View_oneof_aggregation::last_value_aggregation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &View_oneof_aggregation::distribution_aggregation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if let Some(ref v) = self.measure.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.columns {
            os.write_string(4, &v)?;
        };
        if let ::std::option::Option::Some(ref v) = self.aggregation {
            match v {
                &View_oneof_aggregation::count_aggregation(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &View_oneof_aggregation::sum_aggregation(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &View_oneof_aggregation::last_value_aggregation(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &View_oneof_aggregation::distribution_aggregation(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> View {
        View::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &View| { &m.name },
                |m: &mut View| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &View| { &m.description },
                |m: &mut View| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Measure>>(
                "measure",
                |m: &View| { &m.measure },
                |m: &mut View| { &mut m.measure },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columns",
                |m: &View| { &m.columns },
                |m: &mut View| { &mut m.columns },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CountAggregation>(
                "count_aggregation",
                View::has_count_aggregation,
                View::get_count_aggregation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SumAggregation>(
                "sum_aggregation",
                View::has_sum_aggregation,
                View::get_sum_aggregation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LastValueAggregation>(
                "last_value_aggregation",
                View::has_last_value_aggregation,
                View::get_last_value_aggregation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DistributionAggregation>(
                "distribution_aggregation",
                View::has_distribution_aggregation,
                View::get_distribution_aggregation,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<View>(
                "View",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static View {
        static instance: ::protobuf::rt::LazyV2<View> = ::protobuf::rt::LazyV2::INIT;
        instance.get(View::new)
    }
}

impl ::protobuf::Clear for View {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.measure.clear();
        self.columns.clear();
        self.aggregation = ::std::option::Option::None;
        self.aggregation = ::std::option::Option::None;
        self.aggregation = ::std::option::Option::None;
        self.aggregation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for View {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for View {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CountAggregation {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CountAggregation {
    fn default() -> &'a CountAggregation {
        <CountAggregation as ::protobuf::Message>::default_instance()
    }
}

impl CountAggregation {
    pub fn new() -> CountAggregation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CountAggregation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CountAggregation {
        CountAggregation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CountAggregation>(
                "CountAggregation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CountAggregation {
        static instance: ::protobuf::rt::LazyV2<CountAggregation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CountAggregation::new)
    }
}

impl ::protobuf::Clear for CountAggregation {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CountAggregation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CountAggregation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SumAggregation {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SumAggregation {
    fn default() -> &'a SumAggregation {
        <SumAggregation as ::protobuf::Message>::default_instance()
    }
}

impl SumAggregation {
    pub fn new() -> SumAggregation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SumAggregation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SumAggregation {
        SumAggregation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SumAggregation>(
                "SumAggregation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SumAggregation {
        static instance: ::protobuf::rt::LazyV2<SumAggregation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SumAggregation::new)
    }
}

impl ::protobuf::Clear for SumAggregation {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SumAggregation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SumAggregation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LastValueAggregation {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LastValueAggregation {
    fn default() -> &'a LastValueAggregation {
        <LastValueAggregation as ::protobuf::Message>::default_instance()
    }
}

impl LastValueAggregation {
    pub fn new() -> LastValueAggregation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for LastValueAggregation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LastValueAggregation {
        LastValueAggregation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LastValueAggregation>(
                "LastValueAggregation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LastValueAggregation {
        static instance: ::protobuf::rt::LazyV2<LastValueAggregation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LastValueAggregation::new)
    }
}

impl ::protobuf::Clear for LastValueAggregation {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LastValueAggregation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LastValueAggregation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DistributionAggregation {
    // message fields
    pub bucket_bounds: ::std::vec::Vec<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DistributionAggregation {
    fn default() -> &'a DistributionAggregation {
        <DistributionAggregation as ::protobuf::Message>::default_instance()
    }
}

impl DistributionAggregation {
    pub fn new() -> DistributionAggregation {
        ::std::default::Default::default()
    }

    // repeated double bucket_bounds = 1;


    pub fn get_bucket_bounds(&self) -> &[f64] {
        &self.bucket_bounds
    }
    pub fn clear_bucket_bounds(&mut self) {
        self.bucket_bounds.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket_bounds(&mut self, v: ::std::vec::Vec<f64>) {
        self.bucket_bounds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bucket_bounds(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.bucket_bounds
    }

    // Take field
    pub fn take_bucket_bounds(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.bucket_bounds, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DistributionAggregation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.bucket_bounds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 9 * self.bucket_bounds.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.bucket_bounds {
            os.write_double(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DistributionAggregation {
        DistributionAggregation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bucket_bounds",
                |m: &DistributionAggregation| { &m.bucket_bounds },
                |m: &mut DistributionAggregation| { &mut m.bucket_bounds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DistributionAggregation>(
                "DistributionAggregation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DistributionAggregation {
        static instance: ::protobuf::rt::LazyV2<DistributionAggregation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DistributionAggregation::new)
    }
}

impl ::protobuf::Clear for DistributionAggregation {
    fn clear(&mut self) {
        self.bucket_bounds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DistributionAggregation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DistributionAggregation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Measurement {
    // message fields
    pub tags: ::protobuf::RepeatedField<Tag>,
    pub measure_name: ::std::string::String,
    pub time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // message oneof groups
    pub value: ::std::option::Option<Measurement_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Measurement {
    fn default() -> &'a Measurement {
        <Measurement as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Measurement_oneof_value {
    double_value(f64),
    int_value(i64),
}

impl Measurement {
    pub fn new() -> Measurement {
        ::std::default::Default::default()
    }

    // repeated .opencensus.proto.stats.v1.Tag tags = 1;


    pub fn get_tags(&self) -> &[Tag] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<Tag>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<Tag> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<Tag> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // string measure_name = 2;


    pub fn get_measure_name(&self) -> &str {
        &self.measure_name
    }
    pub fn clear_measure_name(&mut self) {
        self.measure_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_measure_name(&mut self, v: ::std::string::String) {
        self.measure_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_measure_name(&mut self) -> &mut ::std::string::String {
        &mut self.measure_name
    }

    // Take field
    pub fn take_measure_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.measure_name, ::std::string::String::new())
    }

    // double double_value = 3;


    pub fn get_double_value(&self) -> f64 {
        match self.value {
            ::std::option::Option::Some(Measurement_oneof_value::double_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_double_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Measurement_oneof_value::double_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.value = ::std::option::Option::Some(Measurement_oneof_value::double_value(v))
    }

    // int64 int_value = 4;


    pub fn get_int_value(&self) -> i64 {
        match self.value {
            ::std::option::Option::Some(Measurement_oneof_value::int_value(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_int_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Measurement_oneof_value::int_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: i64) {
        self.value = ::std::option::Option::Some(Measurement_oneof_value::int_value(v))
    }

    // .google.protobuf.Timestamp time = 5;


    pub fn get_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for Measurement {
    fn is_initialized(&self) -> bool {
        for v in &self.tags {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tags)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.measure_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Measurement_oneof_value::double_value(is.read_double()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Measurement_oneof_value::int_value(is.read_int64()?));
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tags {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.measure_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.measure_name);
        }
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Measurement_oneof_value::double_value(v) => {
                    my_size += 9;
                },
                &Measurement_oneof_value::int_value(v) => {
                    my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tags {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.measure_name.is_empty() {
            os.write_string(2, &self.measure_name)?;
        }
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Measurement_oneof_value::double_value(v) => {
                    os.write_double(3, v)?;
                },
                &Measurement_oneof_value::int_value(v) => {
                    os.write_int64(4, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Measurement {
        Measurement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tag>>(
                "tags",
                |m: &Measurement| { &m.tags },
                |m: &mut Measurement| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "measure_name",
                |m: &Measurement| { &m.measure_name },
                |m: &mut Measurement| { &mut m.measure_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f64_accessor::<_>(
                "double_value",
                Measurement::has_double_value,
                Measurement::get_double_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_i64_accessor::<_>(
                "int_value",
                Measurement::has_int_value,
                Measurement::get_int_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "time",
                |m: &Measurement| { &m.time },
                |m: &mut Measurement| { &mut m.time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Measurement>(
                "Measurement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Measurement {
        static instance: ::protobuf::rt::LazyV2<Measurement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Measurement::new)
    }
}

impl ::protobuf::Clear for Measurement {
    fn clear(&mut self) {
        self.tags.clear();
        self.measure_name.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Measurement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Measurement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%opencensus/proto/stats/v1/stats.proto\x12\x19opencensus.proto.stats.v\
    1\x1a\x1fgoogle/protobuf/timestamp.proto\"-\n\x03Tag\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue\"\xc5\x01\n\x07Measure\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12\x12\n\
    \x04unit\x18\x03\x20\x01(\tR\x04unit\x12;\n\x04type\x18\x04\x20\x01(\x0e\
    2'.opencensus.proto.stats.v1.Measure.TypeR\x04type\"3\n\x04Type\x12\x14\
    \n\x10TYPE_UNSPECIFIED\x10\0\x12\t\n\x05INT64\x10\x01\x12\n\n\x06DOUBLE\
    \x10\x02\"\xaf\x04\n\x04View\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04na\
    me\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\x12<\n\
    \x07measure\x18\x03\x20\x01(\x0b2\".opencensus.proto.stats.v1.MeasureR\
    \x07measure\x12\x18\n\x07columns\x18\x04\x20\x03(\tR\x07columns\x12Z\n\
    \x11count_aggregation\x18\x05\x20\x01(\x0b2+.opencensus.proto.stats.v1.C\
    ountAggregationH\0R\x10countAggregation\x12T\n\x0fsum_aggregation\x18\
    \x06\x20\x01(\x0b2).opencensus.proto.stats.v1.SumAggregationH\0R\x0esumA\
    ggregation\x12g\n\x16last_value_aggregation\x18\x07\x20\x01(\x0b2/.openc\
    ensus.proto.stats.v1.LastValueAggregationH\0R\x14lastValueAggregation\
    \x12o\n\x18distribution_aggregation\x18\x08\x20\x01(\x0b22.opencensus.pr\
    oto.stats.v1.DistributionAggregationH\0R\x17distributionAggregationB\r\n\
    \x0baggregation\"\x12\n\x10CountAggregation\"\x10\n\x0eSumAggregation\"\
    \x16\n\x14LastValueAggregation\">\n\x17DistributionAggregation\x12#\n\rb\
    ucket_bounds\x18\x01\x20\x03(\x01R\x0cbucketBounds\"\xe1\x01\n\x0bMeasur\
    ement\x122\n\x04tags\x18\x01\x20\x03(\x0b2\x1e.opencensus.proto.stats.v1\
    .TagR\x04tags\x12!\n\x0cmeasure_name\x18\x02\x20\x01(\tR\x0bmeasureName\
    \x12#\n\x0cdouble_value\x18\x03\x20\x01(\x01H\0R\x0bdoubleValue\x12\x1d\
    \n\tint_value\x18\x04\x20\x01(\x03H\0R\x08intValue\x12.\n\x04time\x18\
    \x05\x20\x01(\x0b2\x1a.google.protobuf.TimestampR\x04timeB\x07\n\x05valu\
    eB\x8c\x01\n\x1cio.opencensus.proto.stats.v1B\nStatsProtoP\x01ZBgithub.c\
    om/census-instrumentation/opencensus-proto/gen-go/stats/v1\xea\x02\x19Op\
    enCensus.Proto.Stats.V1b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
