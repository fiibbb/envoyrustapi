// This file is generated by rust-protobuf 2.18.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `envoy/service/ext_proc/v3alpha/external_processor.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_18_1;

#[derive(PartialEq,Clone,Default)]
pub struct ProcessingRequest {
    // message fields
    pub async_mode: bool,
    // message oneof groups
    pub request: ::std::option::Option<ProcessingRequest_oneof_request>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProcessingRequest {
    fn default() -> &'a ProcessingRequest {
        <ProcessingRequest as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessingRequest_oneof_request {
    request_headers(HttpHeaders),
    response_headers(HttpHeaders),
    request_body(HttpBody),
    response_body(HttpBody),
    request_trailers(HttpTrailers),
    response_trailers(HttpTrailers),
}

impl ProcessingRequest {
    pub fn new() -> ProcessingRequest {
        ::std::default::Default::default()
    }

    // bool async_mode = 1;


    pub fn get_async_mode(&self) -> bool {
        self.async_mode
    }
    pub fn clear_async_mode(&mut self) {
        self.async_mode = false;
    }

    // Param is passed by value, moved
    pub fn set_async_mode(&mut self, v: bool) {
        self.async_mode = v;
    }

    // .envoy.service.ext_proc.v3alpha.HttpHeaders request_headers = 2;


    pub fn get_request_headers(&self) -> &HttpHeaders {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(ref v)) => v,
            _ => <HttpHeaders as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_headers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_headers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_headers(&mut self, v: HttpHeaders) {
        self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers(&mut self) -> &mut HttpHeaders {
        if let ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(HttpHeaders::new()));
        }
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_headers(&mut self) -> HttpHeaders {
        if self.has_request_headers() {
            match self.request.take() {
                ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpHeaders::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.HttpHeaders response_headers = 3;


    pub fn get_response_headers(&self) -> &HttpHeaders {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(ref v)) => v,
            _ => <HttpHeaders as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_headers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_response_headers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_headers(&mut self, v: HttpHeaders) {
        self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers(&mut self) -> &mut HttpHeaders {
        if let ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(HttpHeaders::new()));
        }
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_headers(&mut self) -> HttpHeaders {
        if self.has_response_headers() {
            match self.request.take() {
                ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpHeaders::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.HttpBody request_body = 4;


    pub fn get_request_body(&self) -> &HttpBody {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(ref v)) => v,
            _ => <HttpBody as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_body(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_body(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_body(&mut self, v: HttpBody) {
        self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_body(&mut self) -> &mut HttpBody {
        if let ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(HttpBody::new()));
        }
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_body(&mut self) -> HttpBody {
        if self.has_request_body() {
            match self.request.take() {
                ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpBody::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.HttpBody response_body = 5;


    pub fn get_response_body(&self) -> &HttpBody {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(ref v)) => v,
            _ => <HttpBody as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_body(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_response_body(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_body(&mut self, v: HttpBody) {
        self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_body(&mut self) -> &mut HttpBody {
        if let ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(HttpBody::new()));
        }
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_body(&mut self) -> HttpBody {
        if self.has_response_body() {
            match self.request.take() {
                ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpBody::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.HttpTrailers request_trailers = 6;


    pub fn get_request_trailers(&self) -> &HttpTrailers {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(ref v)) => v,
            _ => <HttpTrailers as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_trailers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_request_trailers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_trailers(&mut self, v: HttpTrailers) {
        self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_trailers(&mut self) -> &mut HttpTrailers {
        if let ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(HttpTrailers::new()));
        }
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_trailers(&mut self) -> HttpTrailers {
        if self.has_request_trailers() {
            match self.request.take() {
                ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpTrailers::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.HttpTrailers response_trailers = 7;


    pub fn get_response_trailers(&self) -> &HttpTrailers {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(ref v)) => v,
            _ => <HttpTrailers as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_trailers(&mut self) {
        self.request = ::std::option::Option::None;
    }

    pub fn has_response_trailers(&self) -> bool {
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_trailers(&mut self, v: HttpTrailers) {
        self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_trailers(&mut self) -> &mut HttpTrailers {
        if let ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(_)) = self.request {
        } else {
            self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(HttpTrailers::new()));
        }
        match self.request {
            ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_trailers(&mut self) -> HttpTrailers {
        if self.has_response_trailers() {
            match self.request.take() {
                ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(v)) => v,
                _ => panic!(),
            }
        } else {
            HttpTrailers::new()
        }
    }
}

impl ::protobuf::Message for ProcessingRequest {
    fn is_initialized(&self) -> bool {
        if let Some(ProcessingRequest_oneof_request::request_headers(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingRequest_oneof_request::response_headers(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingRequest_oneof_request::request_body(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingRequest_oneof_request::response_body(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingRequest_oneof_request::request_trailers(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingRequest_oneof_request::response_trailers(ref v)) = self.request {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.async_mode = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_headers(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_headers(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_body(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_body(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::request_trailers(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.request = ::std::option::Option::Some(ProcessingRequest_oneof_request::response_trailers(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.async_mode != false {
            my_size += 2;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &ProcessingRequest_oneof_request::request_headers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingRequest_oneof_request::response_headers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingRequest_oneof_request::request_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingRequest_oneof_request::response_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingRequest_oneof_request::request_trailers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingRequest_oneof_request::response_trailers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.async_mode != false {
            os.write_bool(1, self.async_mode)?;
        }
        if let ::std::option::Option::Some(ref v) = self.request {
            match v {
                &ProcessingRequest_oneof_request::request_headers(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingRequest_oneof_request::response_headers(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingRequest_oneof_request::request_body(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingRequest_oneof_request::response_body(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingRequest_oneof_request::request_trailers(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingRequest_oneof_request::response_trailers(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcessingRequest {
        ProcessingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "async_mode",
                |m: &ProcessingRequest| { &m.async_mode },
                |m: &mut ProcessingRequest| { &mut m.async_mode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpHeaders>(
                "request_headers",
                ProcessingRequest::has_request_headers,
                ProcessingRequest::get_request_headers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpHeaders>(
                "response_headers",
                ProcessingRequest::has_response_headers,
                ProcessingRequest::get_response_headers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpBody>(
                "request_body",
                ProcessingRequest::has_request_body,
                ProcessingRequest::get_request_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpBody>(
                "response_body",
                ProcessingRequest::has_response_body,
                ProcessingRequest::get_response_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpTrailers>(
                "request_trailers",
                ProcessingRequest::has_request_trailers,
                ProcessingRequest::get_request_trailers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HttpTrailers>(
                "response_trailers",
                ProcessingRequest::has_response_trailers,
                ProcessingRequest::get_response_trailers,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProcessingRequest>(
                "ProcessingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProcessingRequest {
        static instance: ::protobuf::rt::LazyV2<ProcessingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProcessingRequest::new)
    }
}

impl ::protobuf::Clear for ProcessingRequest {
    fn clear(&mut self) {
        self.async_mode = false;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.request = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcessingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProcessingResponse {
    // message fields
    pub dynamic_metadata: ::protobuf::SingularPtrField<::protobuf::well_known_types::Struct>,
    pub mode_override: ::protobuf::SingularPtrField<super::processing_mode::ProcessingMode>,
    // message oneof groups
    pub response: ::std::option::Option<ProcessingResponse_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProcessingResponse {
    fn default() -> &'a ProcessingResponse {
        <ProcessingResponse as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum ProcessingResponse_oneof_response {
    request_headers(HeadersResponse),
    response_headers(HeadersResponse),
    request_body(BodyResponse),
    response_body(BodyResponse),
    request_trailers(TrailersResponse),
    response_trailers(TrailersResponse),
    immediate_response(ImmediateResponse),
}

impl ProcessingResponse {
    pub fn new() -> ProcessingResponse {
        ::std::default::Default::default()
    }

    // .envoy.service.ext_proc.v3alpha.HeadersResponse request_headers = 1;


    pub fn get_request_headers(&self) -> &HeadersResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(ref v)) => v,
            _ => <HeadersResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_headers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_request_headers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_headers(&mut self, v: HeadersResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_headers(&mut self) -> &mut HeadersResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(HeadersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_headers(&mut self) -> HeadersResponse {
        if self.has_request_headers() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(v)) => v,
                _ => panic!(),
            }
        } else {
            HeadersResponse::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.HeadersResponse response_headers = 2;


    pub fn get_response_headers(&self) -> &HeadersResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(ref v)) => v,
            _ => <HeadersResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_headers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_headers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_headers(&mut self, v: HeadersResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_headers(&mut self) -> &mut HeadersResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(HeadersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_headers(&mut self) -> HeadersResponse {
        if self.has_response_headers() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(v)) => v,
                _ => panic!(),
            }
        } else {
            HeadersResponse::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.BodyResponse request_body = 3;


    pub fn get_request_body(&self) -> &BodyResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(ref v)) => v,
            _ => <BodyResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_body(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_request_body(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_body(&mut self, v: BodyResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_body(&mut self) -> &mut BodyResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(BodyResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_body(&mut self) -> BodyResponse {
        if self.has_request_body() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(v)) => v,
                _ => panic!(),
            }
        } else {
            BodyResponse::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.BodyResponse response_body = 4;


    pub fn get_response_body(&self) -> &BodyResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(ref v)) => v,
            _ => <BodyResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_body(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_body(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_body(&mut self, v: BodyResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_body(&mut self) -> &mut BodyResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(BodyResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_body(&mut self) -> BodyResponse {
        if self.has_response_body() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(v)) => v,
                _ => panic!(),
            }
        } else {
            BodyResponse::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.TrailersResponse request_trailers = 5;


    pub fn get_request_trailers(&self) -> &TrailersResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(ref v)) => v,
            _ => <TrailersResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_request_trailers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_request_trailers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_request_trailers(&mut self, v: TrailersResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_request_trailers(&mut self) -> &mut TrailersResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(TrailersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_request_trailers(&mut self) -> TrailersResponse {
        if self.has_request_trailers() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(v)) => v,
                _ => panic!(),
            }
        } else {
            TrailersResponse::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.TrailersResponse response_trailers = 6;


    pub fn get_response_trailers(&self) -> &TrailersResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(ref v)) => v,
            _ => <TrailersResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_response_trailers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response_trailers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_response_trailers(&mut self, v: TrailersResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_response_trailers(&mut self) -> &mut TrailersResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(TrailersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_response_trailers(&mut self) -> TrailersResponse {
        if self.has_response_trailers() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(v)) => v,
                _ => panic!(),
            }
        } else {
            TrailersResponse::new()
        }
    }

    // .envoy.service.ext_proc.v3alpha.ImmediateResponse immediate_response = 7;


    pub fn get_immediate_response(&self) -> &ImmediateResponse {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(ref v)) => v,
            _ => <ImmediateResponse as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_immediate_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_immediate_response(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_immediate_response(&mut self, v: ImmediateResponse) {
        self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(v))
    }

    // Mutable pointer to the field.
    pub fn mut_immediate_response(&mut self) -> &mut ImmediateResponse {
        if let ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(ImmediateResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_immediate_response(&mut self) -> ImmediateResponse {
        if self.has_immediate_response() {
            match self.response.take() {
                ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(v)) => v,
                _ => panic!(),
            }
        } else {
            ImmediateResponse::new()
        }
    }

    // .google.protobuf.Struct dynamic_metadata = 8;


    pub fn get_dynamic_metadata(&self) -> &::protobuf::well_known_types::Struct {
        self.dynamic_metadata.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Struct as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dynamic_metadata(&mut self) {
        self.dynamic_metadata.clear();
    }

    pub fn has_dynamic_metadata(&self) -> bool {
        self.dynamic_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_metadata(&mut self, v: ::protobuf::well_known_types::Struct) {
        self.dynamic_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_metadata(&mut self) -> &mut ::protobuf::well_known_types::Struct {
        if self.dynamic_metadata.is_none() {
            self.dynamic_metadata.set_default();
        }
        self.dynamic_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_metadata(&mut self) -> ::protobuf::well_known_types::Struct {
        self.dynamic_metadata.take().unwrap_or_else(|| ::protobuf::well_known_types::Struct::new())
    }

    // .envoy.extensions.filters.http.ext_proc.v3alpha.ProcessingMode mode_override = 9;


    pub fn get_mode_override(&self) -> &super::processing_mode::ProcessingMode {
        self.mode_override.as_ref().unwrap_or_else(|| <super::processing_mode::ProcessingMode as ::protobuf::Message>::default_instance())
    }
    pub fn clear_mode_override(&mut self) {
        self.mode_override.clear();
    }

    pub fn has_mode_override(&self) -> bool {
        self.mode_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_override(&mut self, v: super::processing_mode::ProcessingMode) {
        self.mode_override = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mode_override(&mut self) -> &mut super::processing_mode::ProcessingMode {
        if self.mode_override.is_none() {
            self.mode_override.set_default();
        }
        self.mode_override.as_mut().unwrap()
    }

    // Take field
    pub fn take_mode_override(&mut self) -> super::processing_mode::ProcessingMode {
        self.mode_override.take().unwrap_or_else(|| super::processing_mode::ProcessingMode::new())
    }
}

impl ::protobuf::Message for ProcessingResponse {
    fn is_initialized(&self) -> bool {
        if let Some(ProcessingResponse_oneof_response::request_headers(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingResponse_oneof_response::response_headers(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingResponse_oneof_response::request_body(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingResponse_oneof_response::response_body(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingResponse_oneof_response::request_trailers(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingResponse_oneof_response::response_trailers(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(ProcessingResponse_oneof_response::immediate_response(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.dynamic_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mode_override {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_headers(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_headers(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_body(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_body(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::request_trailers(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::response_trailers(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(ProcessingResponse_oneof_response::immediate_response(is.read_message()?));
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_metadata)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mode_override)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.dynamic_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mode_override.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &ProcessingResponse_oneof_response::request_headers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingResponse_oneof_response::response_headers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingResponse_oneof_response::request_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingResponse_oneof_response::response_body(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingResponse_oneof_response::request_trailers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingResponse_oneof_response::response_trailers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &ProcessingResponse_oneof_response::immediate_response(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.dynamic_metadata.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mode_override.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &ProcessingResponse_oneof_response::request_headers(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingResponse_oneof_response::response_headers(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingResponse_oneof_response::request_body(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingResponse_oneof_response::response_body(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingResponse_oneof_response::request_trailers(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingResponse_oneof_response::response_trailers(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &ProcessingResponse_oneof_response::immediate_response(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProcessingResponse {
        ProcessingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HeadersResponse>(
                "request_headers",
                ProcessingResponse::has_request_headers,
                ProcessingResponse::get_request_headers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HeadersResponse>(
                "response_headers",
                ProcessingResponse::has_response_headers,
                ProcessingResponse::get_response_headers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BodyResponse>(
                "request_body",
                ProcessingResponse::has_request_body,
                ProcessingResponse::get_request_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BodyResponse>(
                "response_body",
                ProcessingResponse::has_response_body,
                ProcessingResponse::get_response_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrailersResponse>(
                "request_trailers",
                ProcessingResponse::has_request_trailers,
                ProcessingResponse::get_request_trailers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, TrailersResponse>(
                "response_trailers",
                ProcessingResponse::has_response_trailers,
                ProcessingResponse::get_response_trailers,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ImmediateResponse>(
                "immediate_response",
                ProcessingResponse::has_immediate_response,
                ProcessingResponse::get_immediate_response,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "dynamic_metadata",
                |m: &ProcessingResponse| { &m.dynamic_metadata },
                |m: &mut ProcessingResponse| { &mut m.dynamic_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::processing_mode::ProcessingMode>>(
                "mode_override",
                |m: &ProcessingResponse| { &m.mode_override },
                |m: &mut ProcessingResponse| { &mut m.mode_override },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProcessingResponse>(
                "ProcessingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProcessingResponse {
        static instance: ::protobuf::rt::LazyV2<ProcessingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProcessingResponse::new)
    }
}

impl ::protobuf::Clear for ProcessingResponse {
    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.dynamic_metadata.clear();
        self.mode_override.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProcessingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProcessingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpHeaders {
    // message fields
    pub headers: ::protobuf::SingularPtrField<super::base::HeaderMap>,
    pub attributes: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>,
    pub end_of_stream: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpHeaders {
    fn default() -> &'a HttpHeaders {
        <HttpHeaders as ::protobuf::Message>::default_instance()
    }
}

impl HttpHeaders {
    pub fn new() -> HttpHeaders {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.HeaderMap headers = 1;


    pub fn get_headers(&self) -> &super::base::HeaderMap {
        self.headers.as_ref().unwrap_or_else(|| <super::base::HeaderMap as ::protobuf::Message>::default_instance())
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    pub fn has_headers(&self) -> bool {
        self.headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: super::base::HeaderMap) {
        self.headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headers(&mut self) -> &mut super::base::HeaderMap {
        if self.headers.is_none() {
            self.headers.set_default();
        }
        self.headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_headers(&mut self) -> super::base::HeaderMap {
        self.headers.take().unwrap_or_else(|| super::base::HeaderMap::new())
    }

    // repeated .envoy.service.ext_proc.v3alpha.HttpHeaders.AttributesEntry attributes = 2;


    pub fn get_attributes(&self) -> &::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &self.attributes
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct>) {
        self.attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        &mut self.attributes
    }

    // Take field
    pub fn take_attributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::protobuf::well_known_types::Struct> {
        ::std::mem::replace(&mut self.attributes, ::std::collections::HashMap::new())
    }

    // bool end_of_stream = 3;


    pub fn get_end_of_stream(&self) -> bool {
        self.end_of_stream
    }
    pub fn clear_end_of_stream(&mut self) {
        self.end_of_stream = false;
    }

    // Param is passed by value, moved
    pub fn set_end_of_stream(&mut self, v: bool) {
        self.end_of_stream = v;
    }
}

impl ::protobuf::Message for HttpHeaders {
    fn is_initialized(&self) -> bool {
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headers)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(wire_type, is, &mut self.attributes)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_of_stream = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(2, &self.attributes);
        if self.end_of_stream != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.headers.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(2, &self.attributes, os)?;
        if self.end_of_stream != false {
            os.write_bool(3, self.end_of_stream)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpHeaders {
        HttpHeaders::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderMap>>(
                "headers",
                |m: &HttpHeaders| { &m.headers },
                |m: &mut HttpHeaders| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Struct>>(
                "attributes",
                |m: &HttpHeaders| { &m.attributes },
                |m: &mut HttpHeaders| { &mut m.attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "end_of_stream",
                |m: &HttpHeaders| { &m.end_of_stream },
                |m: &mut HttpHeaders| { &mut m.end_of_stream },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpHeaders>(
                "HttpHeaders",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpHeaders {
        static instance: ::protobuf::rt::LazyV2<HttpHeaders> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpHeaders::new)
    }
}

impl ::protobuf::Clear for HttpHeaders {
    fn clear(&mut self) {
        self.headers.clear();
        self.attributes.clear();
        self.end_of_stream = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpHeaders {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpHeaders {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpBody {
    // message fields
    pub body: ::std::vec::Vec<u8>,
    pub end_of_stream: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpBody {
    fn default() -> &'a HttpBody {
        <HttpBody as ::protobuf::Message>::default_instance()
    }
}

impl HttpBody {
    pub fn new() -> HttpBody {
        ::std::default::Default::default()
    }

    // bytes body = 1;


    pub fn get_body(&self) -> &[u8] {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.body, ::std::vec::Vec::new())
    }

    // bool end_of_stream = 2;


    pub fn get_end_of_stream(&self) -> bool {
        self.end_of_stream
    }
    pub fn clear_end_of_stream(&mut self) {
        self.end_of_stream = false;
    }

    // Param is passed by value, moved
    pub fn set_end_of_stream(&mut self, v: bool) {
        self.end_of_stream = v;
    }
}

impl ::protobuf::Message for HttpBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.body)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.end_of_stream = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.body);
        }
        if self.end_of_stream != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.body.is_empty() {
            os.write_bytes(1, &self.body)?;
        }
        if self.end_of_stream != false {
            os.write_bool(2, self.end_of_stream)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpBody {
        HttpBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "body",
                |m: &HttpBody| { &m.body },
                |m: &mut HttpBody| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "end_of_stream",
                |m: &HttpBody| { &m.end_of_stream },
                |m: &mut HttpBody| { &mut m.end_of_stream },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpBody>(
                "HttpBody",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpBody {
        static instance: ::protobuf::rt::LazyV2<HttpBody> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpBody::new)
    }
}

impl ::protobuf::Clear for HttpBody {
    fn clear(&mut self) {
        self.body.clear();
        self.end_of_stream = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpBody {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpTrailers {
    // message fields
    pub trailers: ::protobuf::SingularPtrField<super::base::HeaderMap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpTrailers {
    fn default() -> &'a HttpTrailers {
        <HttpTrailers as ::protobuf::Message>::default_instance()
    }
}

impl HttpTrailers {
    pub fn new() -> HttpTrailers {
        ::std::default::Default::default()
    }

    // .envoy.config.core.v3.HeaderMap trailers = 1;


    pub fn get_trailers(&self) -> &super::base::HeaderMap {
        self.trailers.as_ref().unwrap_or_else(|| <super::base::HeaderMap as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trailers(&mut self) {
        self.trailers.clear();
    }

    pub fn has_trailers(&self) -> bool {
        self.trailers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailers(&mut self, v: super::base::HeaderMap) {
        self.trailers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trailers(&mut self) -> &mut super::base::HeaderMap {
        if self.trailers.is_none() {
            self.trailers.set_default();
        }
        self.trailers.as_mut().unwrap()
    }

    // Take field
    pub fn take_trailers(&mut self) -> super::base::HeaderMap {
        self.trailers.take().unwrap_or_else(|| super::base::HeaderMap::new())
    }
}

impl ::protobuf::Message for HttpTrailers {
    fn is_initialized(&self) -> bool {
        for v in &self.trailers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trailers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.trailers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.trailers.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpTrailers {
        HttpTrailers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderMap>>(
                "trailers",
                |m: &HttpTrailers| { &m.trailers },
                |m: &mut HttpTrailers| { &mut m.trailers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpTrailers>(
                "HttpTrailers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpTrailers {
        static instance: ::protobuf::rt::LazyV2<HttpTrailers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpTrailers::new)
    }
}

impl ::protobuf::Clear for HttpTrailers {
    fn clear(&mut self) {
        self.trailers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpTrailers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpTrailers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeadersResponse {
    // message fields
    pub response: ::protobuf::SingularPtrField<CommonResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeadersResponse {
    fn default() -> &'a HeadersResponse {
        <HeadersResponse as ::protobuf::Message>::default_instance()
    }
}

impl HeadersResponse {
    pub fn new() -> HeadersResponse {
        ::std::default::Default::default()
    }

    // .envoy.service.ext_proc.v3alpha.CommonResponse response = 1;


    pub fn get_response(&self) -> &CommonResponse {
        self.response.as_ref().unwrap_or_else(|| <CommonResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CommonResponse) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut CommonResponse {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> CommonResponse {
        self.response.take().unwrap_or_else(|| CommonResponse::new())
    }
}

impl ::protobuf::Message for HeadersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeadersResponse {
        HeadersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonResponse>>(
                "response",
                |m: &HeadersResponse| { &m.response },
                |m: &mut HeadersResponse| { &mut m.response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeadersResponse>(
                "HeadersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeadersResponse {
        static instance: ::protobuf::rt::LazyV2<HeadersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeadersResponse::new)
    }
}

impl ::protobuf::Clear for HeadersResponse {
    fn clear(&mut self) {
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeadersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeadersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TrailersResponse {
    // message fields
    pub header_mutation: ::protobuf::SingularPtrField<HeaderMutation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TrailersResponse {
    fn default() -> &'a TrailersResponse {
        <TrailersResponse as ::protobuf::Message>::default_instance()
    }
}

impl TrailersResponse {
    pub fn new() -> TrailersResponse {
        ::std::default::Default::default()
    }

    // .envoy.service.ext_proc.v3alpha.HeaderMutation header_mutation = 1;


    pub fn get_header_mutation(&self) -> &HeaderMutation {
        self.header_mutation.as_ref().unwrap_or_else(|| <HeaderMutation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header_mutation(&mut self) {
        self.header_mutation.clear();
    }

    pub fn has_header_mutation(&self) -> bool {
        self.header_mutation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_mutation(&mut self, v: HeaderMutation) {
        self.header_mutation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_mutation(&mut self) -> &mut HeaderMutation {
        if self.header_mutation.is_none() {
            self.header_mutation.set_default();
        }
        self.header_mutation.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_mutation(&mut self) -> HeaderMutation {
        self.header_mutation.take().unwrap_or_else(|| HeaderMutation::new())
    }
}

impl ::protobuf::Message for TrailersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header_mutation {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_mutation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header_mutation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header_mutation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TrailersResponse {
        TrailersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMutation>>(
                "header_mutation",
                |m: &TrailersResponse| { &m.header_mutation },
                |m: &mut TrailersResponse| { &mut m.header_mutation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TrailersResponse>(
                "TrailersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TrailersResponse {
        static instance: ::protobuf::rt::LazyV2<TrailersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TrailersResponse::new)
    }
}

impl ::protobuf::Clear for TrailersResponse {
    fn clear(&mut self) {
        self.header_mutation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TrailersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TrailersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BodyResponse {
    // message fields
    pub response: ::protobuf::SingularPtrField<CommonResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BodyResponse {
    fn default() -> &'a BodyResponse {
        <BodyResponse as ::protobuf::Message>::default_instance()
    }
}

impl BodyResponse {
    pub fn new() -> BodyResponse {
        ::std::default::Default::default()
    }

    // .envoy.service.ext_proc.v3alpha.CommonResponse response = 1;


    pub fn get_response(&self) -> &CommonResponse {
        self.response.as_ref().unwrap_or_else(|| <CommonResponse as ::protobuf::Message>::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: CommonResponse) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut CommonResponse {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> CommonResponse {
        self.response.take().unwrap_or_else(|| CommonResponse::new())
    }
}

impl ::protobuf::Message for BodyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BodyResponse {
        BodyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonResponse>>(
                "response",
                |m: &BodyResponse| { &m.response },
                |m: &mut BodyResponse| { &mut m.response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BodyResponse>(
                "BodyResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BodyResponse {
        static instance: ::protobuf::rt::LazyV2<BodyResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BodyResponse::new)
    }
}

impl ::protobuf::Clear for BodyResponse {
    fn clear(&mut self) {
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BodyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonResponse {
    // message fields
    pub status: CommonResponse_ResponseStatus,
    pub header_mutation: ::protobuf::SingularPtrField<HeaderMutation>,
    pub body_mutation: ::protobuf::SingularPtrField<BodyMutation>,
    pub trailers: ::protobuf::SingularPtrField<super::base::HeaderMap>,
    pub clear_route_cache: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonResponse {
    fn default() -> &'a CommonResponse {
        <CommonResponse as ::protobuf::Message>::default_instance()
    }
}

impl CommonResponse {
    pub fn new() -> CommonResponse {
        ::std::default::Default::default()
    }

    // .envoy.service.ext_proc.v3alpha.CommonResponse.ResponseStatus status = 1;


    pub fn get_status(&self) -> CommonResponse_ResponseStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = CommonResponse_ResponseStatus::CONTINUE;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: CommonResponse_ResponseStatus) {
        self.status = v;
    }

    // .envoy.service.ext_proc.v3alpha.HeaderMutation header_mutation = 2;


    pub fn get_header_mutation(&self) -> &HeaderMutation {
        self.header_mutation.as_ref().unwrap_or_else(|| <HeaderMutation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_header_mutation(&mut self) {
        self.header_mutation.clear();
    }

    pub fn has_header_mutation(&self) -> bool {
        self.header_mutation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header_mutation(&mut self, v: HeaderMutation) {
        self.header_mutation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header_mutation(&mut self) -> &mut HeaderMutation {
        if self.header_mutation.is_none() {
            self.header_mutation.set_default();
        }
        self.header_mutation.as_mut().unwrap()
    }

    // Take field
    pub fn take_header_mutation(&mut self) -> HeaderMutation {
        self.header_mutation.take().unwrap_or_else(|| HeaderMutation::new())
    }

    // .envoy.service.ext_proc.v3alpha.BodyMutation body_mutation = 3;


    pub fn get_body_mutation(&self) -> &BodyMutation {
        self.body_mutation.as_ref().unwrap_or_else(|| <BodyMutation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_body_mutation(&mut self) {
        self.body_mutation.clear();
    }

    pub fn has_body_mutation(&self) -> bool {
        self.body_mutation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body_mutation(&mut self, v: BodyMutation) {
        self.body_mutation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body_mutation(&mut self) -> &mut BodyMutation {
        if self.body_mutation.is_none() {
            self.body_mutation.set_default();
        }
        self.body_mutation.as_mut().unwrap()
    }

    // Take field
    pub fn take_body_mutation(&mut self) -> BodyMutation {
        self.body_mutation.take().unwrap_or_else(|| BodyMutation::new())
    }

    // .envoy.config.core.v3.HeaderMap trailers = 4;


    pub fn get_trailers(&self) -> &super::base::HeaderMap {
        self.trailers.as_ref().unwrap_or_else(|| <super::base::HeaderMap as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trailers(&mut self) {
        self.trailers.clear();
    }

    pub fn has_trailers(&self) -> bool {
        self.trailers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trailers(&mut self, v: super::base::HeaderMap) {
        self.trailers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trailers(&mut self) -> &mut super::base::HeaderMap {
        if self.trailers.is_none() {
            self.trailers.set_default();
        }
        self.trailers.as_mut().unwrap()
    }

    // Take field
    pub fn take_trailers(&mut self) -> super::base::HeaderMap {
        self.trailers.take().unwrap_or_else(|| super::base::HeaderMap::new())
    }

    // bool clear_route_cache = 5;


    pub fn get_clear_route_cache(&self) -> bool {
        self.clear_route_cache
    }
    pub fn clear_clear_route_cache(&mut self) {
        self.clear_route_cache = false;
    }

    // Param is passed by value, moved
    pub fn set_clear_route_cache(&mut self, v: bool) {
        self.clear_route_cache = v;
    }
}

impl ::protobuf::Message for CommonResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header_mutation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.body_mutation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.trailers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header_mutation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.body_mutation)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trailers)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clear_route_cache = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != CommonResponse_ResponseStatus::CONTINUE {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        if let Some(ref v) = self.header_mutation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.body_mutation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.trailers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.clear_route_cache != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != CommonResponse_ResponseStatus::CONTINUE {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if let Some(ref v) = self.header_mutation.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.body_mutation.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.trailers.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.clear_route_cache != false {
            os.write_bool(5, self.clear_route_cache)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonResponse {
        CommonResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CommonResponse_ResponseStatus>>(
                "status",
                |m: &CommonResponse| { &m.status },
                |m: &mut CommonResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMutation>>(
                "header_mutation",
                |m: &CommonResponse| { &m.header_mutation },
                |m: &mut CommonResponse| { &mut m.header_mutation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BodyMutation>>(
                "body_mutation",
                |m: &CommonResponse| { &m.body_mutation },
                |m: &mut CommonResponse| { &mut m.body_mutation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderMap>>(
                "trailers",
                |m: &CommonResponse| { &m.trailers },
                |m: &mut CommonResponse| { &mut m.trailers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clear_route_cache",
                |m: &CommonResponse| { &m.clear_route_cache },
                |m: &mut CommonResponse| { &mut m.clear_route_cache },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonResponse>(
                "CommonResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommonResponse {
        static instance: ::protobuf::rt::LazyV2<CommonResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonResponse::new)
    }
}

impl ::protobuf::Clear for CommonResponse {
    fn clear(&mut self) {
        self.status = CommonResponse_ResponseStatus::CONTINUE;
        self.header_mutation.clear();
        self.body_mutation.clear();
        self.trailers.clear();
        self.clear_route_cache = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CommonResponse_ResponseStatus {
    CONTINUE = 0,
    CONTINUE_AND_REPLACE = 1,
}

impl ::protobuf::ProtobufEnum for CommonResponse_ResponseStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CommonResponse_ResponseStatus> {
        match value {
            0 => ::std::option::Option::Some(CommonResponse_ResponseStatus::CONTINUE),
            1 => ::std::option::Option::Some(CommonResponse_ResponseStatus::CONTINUE_AND_REPLACE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CommonResponse_ResponseStatus] = &[
            CommonResponse_ResponseStatus::CONTINUE,
            CommonResponse_ResponseStatus::CONTINUE_AND_REPLACE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<CommonResponse_ResponseStatus>("CommonResponse.ResponseStatus", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for CommonResponse_ResponseStatus {
}

impl ::std::default::Default for CommonResponse_ResponseStatus {
    fn default() -> Self {
        CommonResponse_ResponseStatus::CONTINUE
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonResponse_ResponseStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImmediateResponse {
    // message fields
    pub status: ::protobuf::SingularPtrField<super::http_status::HttpStatus>,
    pub headers: ::protobuf::SingularPtrField<HeaderMutation>,
    pub body: ::std::string::String,
    pub grpc_status: ::protobuf::SingularPtrField<GrpcStatus>,
    pub details: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImmediateResponse {
    fn default() -> &'a ImmediateResponse {
        <ImmediateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ImmediateResponse {
    pub fn new() -> ImmediateResponse {
        ::std::default::Default::default()
    }

    // .envoy.type.v3.HttpStatus status = 1;


    pub fn get_status(&self) -> &super::http_status::HttpStatus {
        self.status.as_ref().unwrap_or_else(|| <super::http_status::HttpStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::http_status::HttpStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut super::http_status::HttpStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> super::http_status::HttpStatus {
        self.status.take().unwrap_or_else(|| super::http_status::HttpStatus::new())
    }

    // .envoy.service.ext_proc.v3alpha.HeaderMutation headers = 2;


    pub fn get_headers(&self) -> &HeaderMutation {
        self.headers.as_ref().unwrap_or_else(|| <HeaderMutation as ::protobuf::Message>::default_instance())
    }
    pub fn clear_headers(&mut self) {
        self.headers.clear();
    }

    pub fn has_headers(&self) -> bool {
        self.headers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headers(&mut self, v: HeaderMutation) {
        self.headers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headers(&mut self) -> &mut HeaderMutation {
        if self.headers.is_none() {
            self.headers.set_default();
        }
        self.headers.as_mut().unwrap()
    }

    // Take field
    pub fn take_headers(&mut self) -> HeaderMutation {
        self.headers.take().unwrap_or_else(|| HeaderMutation::new())
    }

    // string body = 3;


    pub fn get_body(&self) -> &str {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.body, ::std::string::String::new())
    }

    // .envoy.service.ext_proc.v3alpha.GrpcStatus grpc_status = 4;


    pub fn get_grpc_status(&self) -> &GrpcStatus {
        self.grpc_status.as_ref().unwrap_or_else(|| <GrpcStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_grpc_status(&mut self) {
        self.grpc_status.clear();
    }

    pub fn has_grpc_status(&self) -> bool {
        self.grpc_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_grpc_status(&mut self, v: GrpcStatus) {
        self.grpc_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_grpc_status(&mut self) -> &mut GrpcStatus {
        if self.grpc_status.is_none() {
            self.grpc_status.set_default();
        }
        self.grpc_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_grpc_status(&mut self) -> GrpcStatus {
        self.grpc_status.take().unwrap_or_else(|| GrpcStatus::new())
    }

    // string details = 5;


    pub fn get_details(&self) -> &str {
        &self.details
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: ::std::string::String) {
        self.details = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut ::std::string::String {
        &mut self.details
    }

    // Take field
    pub fn take_details(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.details, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ImmediateResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.headers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.grpc_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.headers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.body)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.grpc_status)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.details)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.headers.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.body);
        }
        if let Some(ref v) = self.grpc_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.details.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.headers.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.body.is_empty() {
            os.write_string(3, &self.body)?;
        }
        if let Some(ref v) = self.grpc_status.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.details.is_empty() {
            os.write_string(5, &self.details)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImmediateResponse {
        ImmediateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::http_status::HttpStatus>>(
                "status",
                |m: &ImmediateResponse| { &m.status },
                |m: &mut ImmediateResponse| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeaderMutation>>(
                "headers",
                |m: &ImmediateResponse| { &m.headers },
                |m: &mut ImmediateResponse| { &mut m.headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "body",
                |m: &ImmediateResponse| { &m.body },
                |m: &mut ImmediateResponse| { &mut m.body },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GrpcStatus>>(
                "grpc_status",
                |m: &ImmediateResponse| { &m.grpc_status },
                |m: &mut ImmediateResponse| { &mut m.grpc_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "details",
                |m: &ImmediateResponse| { &m.details },
                |m: &mut ImmediateResponse| { &mut m.details },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImmediateResponse>(
                "ImmediateResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImmediateResponse {
        static instance: ::protobuf::rt::LazyV2<ImmediateResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImmediateResponse::new)
    }
}

impl ::protobuf::Clear for ImmediateResponse {
    fn clear(&mut self) {
        self.status.clear();
        self.headers.clear();
        self.body.clear();
        self.grpc_status.clear();
        self.details.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImmediateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImmediateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GrpcStatus {
    // message fields
    pub status: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GrpcStatus {
    fn default() -> &'a GrpcStatus {
        <GrpcStatus as ::protobuf::Message>::default_instance()
    }
}

impl GrpcStatus {
    pub fn new() -> GrpcStatus {
        ::std::default::Default::default()
    }

    // uint32 status = 1;


    pub fn get_status(&self) -> u32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = v;
    }
}

impl ::protobuf::Message for GrpcStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.status = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_uint32(1, self.status)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GrpcStatus {
        GrpcStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "status",
                |m: &GrpcStatus| { &m.status },
                |m: &mut GrpcStatus| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GrpcStatus>(
                "GrpcStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GrpcStatus {
        static instance: ::protobuf::rt::LazyV2<GrpcStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GrpcStatus::new)
    }
}

impl ::protobuf::Clear for GrpcStatus {
    fn clear(&mut self) {
        self.status = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GrpcStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrpcStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeaderMutation {
    // message fields
    pub set_headers: ::protobuf::RepeatedField<super::base::HeaderValueOption>,
    pub remove_headers: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeaderMutation {
    fn default() -> &'a HeaderMutation {
        <HeaderMutation as ::protobuf::Message>::default_instance()
    }
}

impl HeaderMutation {
    pub fn new() -> HeaderMutation {
        ::std::default::Default::default()
    }

    // repeated .envoy.config.core.v3.HeaderValueOption set_headers = 1;


    pub fn get_set_headers(&self) -> &[super::base::HeaderValueOption] {
        &self.set_headers
    }
    pub fn clear_set_headers(&mut self) {
        self.set_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_set_headers(&mut self, v: ::protobuf::RepeatedField<super::base::HeaderValueOption>) {
        self.set_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_set_headers(&mut self) -> &mut ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        &mut self.set_headers
    }

    // Take field
    pub fn take_set_headers(&mut self) -> ::protobuf::RepeatedField<super::base::HeaderValueOption> {
        ::std::mem::replace(&mut self.set_headers, ::protobuf::RepeatedField::new())
    }

    // repeated string remove_headers = 2;


    pub fn get_remove_headers(&self) -> &[::std::string::String] {
        &self.remove_headers
    }
    pub fn clear_remove_headers(&mut self) {
        self.remove_headers.clear();
    }

    // Param is passed by value, moved
    pub fn set_remove_headers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.remove_headers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_remove_headers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.remove_headers
    }

    // Take field
    pub fn take_remove_headers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.remove_headers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HeaderMutation {
    fn is_initialized(&self) -> bool {
        for v in &self.set_headers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.set_headers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.remove_headers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.set_headers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.remove_headers {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.set_headers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.remove_headers {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeaderMutation {
        HeaderMutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::base::HeaderValueOption>>(
                "set_headers",
                |m: &HeaderMutation| { &m.set_headers },
                |m: &mut HeaderMutation| { &mut m.set_headers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "remove_headers",
                |m: &HeaderMutation| { &m.remove_headers },
                |m: &mut HeaderMutation| { &mut m.remove_headers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeaderMutation>(
                "HeaderMutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeaderMutation {
        static instance: ::protobuf::rt::LazyV2<HeaderMutation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeaderMutation::new)
    }
}

impl ::protobuf::Clear for HeaderMutation {
    fn clear(&mut self) {
        self.set_headers.clear();
        self.remove_headers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeaderMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeaderMutation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BodyMutation {
    // message oneof groups
    pub mutation: ::std::option::Option<BodyMutation_oneof_mutation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BodyMutation {
    fn default() -> &'a BodyMutation {
        <BodyMutation as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum BodyMutation_oneof_mutation {
    body(::std::vec::Vec<u8>),
    clear_body(bool),
}

impl BodyMutation {
    pub fn new() -> BodyMutation {
        ::std::default::Default::default()
    }

    // bytes body = 1;


    pub fn get_body(&self) -> &[u8] {
        match self.mutation {
            ::std::option::Option::Some(BodyMutation_oneof_mutation::body(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_body(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_body(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(BodyMutation_oneof_mutation::body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.mutation = ::std::option::Option::Some(BodyMutation_oneof_mutation::body(v))
    }

    // Mutable pointer to the field.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(BodyMutation_oneof_mutation::body(_)) = self.mutation {
        } else {
            self.mutation = ::std::option::Option::Some(BodyMutation_oneof_mutation::body(::std::vec::Vec::new()));
        }
        match self.mutation {
            ::std::option::Option::Some(BodyMutation_oneof_mutation::body(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_body() {
            match self.mutation.take() {
                ::std::option::Option::Some(BodyMutation_oneof_mutation::body(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // bool clear_body = 2;


    pub fn get_clear_body(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(BodyMutation_oneof_mutation::clear_body(v)) => v,
            _ => false,
        }
    }
    pub fn clear_clear_body(&mut self) {
        self.mutation = ::std::option::Option::None;
    }

    pub fn has_clear_body(&self) -> bool {
        match self.mutation {
            ::std::option::Option::Some(BodyMutation_oneof_mutation::clear_body(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_clear_body(&mut self, v: bool) {
        self.mutation = ::std::option::Option::Some(BodyMutation_oneof_mutation::clear_body(v))
    }
}

impl ::protobuf::Message for BodyMutation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(BodyMutation_oneof_mutation::body(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.mutation = ::std::option::Option::Some(BodyMutation_oneof_mutation::clear_body(is.read_bool()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &BodyMutation_oneof_mutation::body(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &BodyMutation_oneof_mutation::clear_body(v) => {
                    my_size += 2;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.mutation {
            match v {
                &BodyMutation_oneof_mutation::body(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &BodyMutation_oneof_mutation::clear_body(v) => {
                    os.write_bool(2, v)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BodyMutation {
        BodyMutation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "body",
                BodyMutation::has_body,
                BodyMutation::get_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bool_accessor::<_>(
                "clear_body",
                BodyMutation::has_clear_body,
                BodyMutation::get_clear_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BodyMutation>(
                "BodyMutation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BodyMutation {
        static instance: ::protobuf::rt::LazyV2<BodyMutation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BodyMutation::new)
    }
}

impl ::protobuf::Clear for BodyMutation {
    fn clear(&mut self) {
        self.mutation = ::std::option::Option::None;
        self.mutation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BodyMutation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BodyMutation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n7envoy/service/ext_proc/v3alpha/external_processor.proto\x12\x1eenvoy.\
    service.ext_proc.v3alpha\x1a\x1fenvoy/config/core/v3/base.proto\x1aDenvo\
    y/extensions/filters/http/ext_proc/v3alpha/processing_mode.proto\x1a\x1f\
    envoy/type/v3/http_status.proto\x1a\x1egoogle/protobuf/duration.proto\
    \x1a\x1cgoogle/protobuf/struct.proto\x1a\x1dudpa/annotations/status.prot\
    o\x1a\x17validate/validate.proto\"\xcc\x04\n\x11ProcessingRequest\x12\
    \x1d\n\nasync_mode\x18\x01\x20\x01(\x08R\tasyncMode\x12V\n\x0frequest_he\
    aders\x18\x02\x20\x01(\x0b2+.envoy.service.ext_proc.v3alpha.HttpHeadersH\
    \0R\x0erequestHeaders\x12X\n\x10response_headers\x18\x03\x20\x01(\x0b2+.\
    envoy.service.ext_proc.v3alpha.HttpHeadersH\0R\x0fresponseHeaders\x12M\n\
    \x0crequest_body\x18\x04\x20\x01(\x0b2(.envoy.service.ext_proc.v3alpha.H\
    ttpBodyH\0R\x0brequestBody\x12O\n\rresponse_body\x18\x05\x20\x01(\x0b2(.\
    envoy.service.ext_proc.v3alpha.HttpBodyH\0R\x0cresponseBody\x12Y\n\x10re\
    quest_trailers\x18\x06\x20\x01(\x0b2,.envoy.service.ext_proc.v3alpha.Htt\
    pTrailersH\0R\x0frequestTrailers\x12[\n\x11response_trailers\x18\x07\x20\
    \x01(\x0b2,.envoy.service.ext_proc.v3alpha.HttpTrailersH\0R\x10responseT\
    railersB\x0e\n\x07request\x12\x03\xf8B\x01\"\xd4\x06\n\x12ProcessingResp\
    onse\x12Z\n\x0frequest_headers\x18\x01\x20\x01(\x0b2/.envoy.service.ext_\
    proc.v3alpha.HeadersResponseH\0R\x0erequestHeaders\x12\\\n\x10response_h\
    eaders\x18\x02\x20\x01(\x0b2/.envoy.service.ext_proc.v3alpha.HeadersResp\
    onseH\0R\x0fresponseHeaders\x12Q\n\x0crequest_body\x18\x03\x20\x01(\x0b2\
    ,.envoy.service.ext_proc.v3alpha.BodyResponseH\0R\x0brequestBody\x12S\n\
    \rresponse_body\x18\x04\x20\x01(\x0b2,.envoy.service.ext_proc.v3alpha.Bo\
    dyResponseH\0R\x0cresponseBody\x12]\n\x10request_trailers\x18\x05\x20\
    \x01(\x0b20.envoy.service.ext_proc.v3alpha.TrailersResponseH\0R\x0freque\
    stTrailers\x12_\n\x11response_trailers\x18\x06\x20\x01(\x0b20.envoy.serv\
    ice.ext_proc.v3alpha.TrailersResponseH\0R\x10responseTrailers\x12b\n\x12\
    immediate_response\x18\x07\x20\x01(\x0b21.envoy.service.ext_proc.v3alpha\
    .ImmediateResponseH\0R\x11immediateResponse\x12B\n\x10dynamic_metadata\
    \x18\x08\x20\x01(\x0b2\x17.google.protobuf.StructR\x0fdynamicMetadata\
    \x12c\n\rmode_override\x18\t\x20\x01(\x0b2>.envoy.extensions.filters.htt\
    p.ext_proc.v3alpha.ProcessingModeR\x0cmodeOverrideB\x0f\n\x08response\
    \x12\x03\xf8B\x01\"\xa1\x02\n\x0bHttpHeaders\x129\n\x07headers\x18\x01\
    \x20\x01(\x0b2\x1f.envoy.config.core.v3.HeaderMapR\x07headers\x12[\n\nat\
    tributes\x18\x02\x20\x03(\x0b2;.envoy.service.ext_proc.v3alpha.HttpHeade\
    rs.AttributesEntryR\nattributes\x12\"\n\rend_of_stream\x18\x03\x20\x01(\
    \x08R\x0bendOfStream\x1aV\n\x0fAttributesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12-\n\x05value\x18\x02\x20\x01(\x0b2\x17.google.pro\
    tobuf.StructR\x05value:\x028\x01\"B\n\x08HttpBody\x12\x12\n\x04body\x18\
    \x01\x20\x01(\x0cR\x04body\x12\"\n\rend_of_stream\x18\x02\x20\x01(\x08R\
    \x0bendOfStream\"K\n\x0cHttpTrailers\x12;\n\x08trailers\x18\x01\x20\x01(\
    \x0b2\x1f.envoy.config.core.v3.HeaderMapR\x08trailers\"]\n\x0fHeadersRes\
    ponse\x12J\n\x08response\x18\x01\x20\x01(\x0b2..envoy.service.ext_proc.v\
    3alpha.CommonResponseR\x08response\"k\n\x10TrailersResponse\x12W\n\x0fhe\
    ader_mutation\x18\x01\x20\x01(\x0b2..envoy.service.ext_proc.v3alpha.Head\
    erMutationR\x0eheaderMutation\"Z\n\x0cBodyResponse\x12J\n\x08response\
    \x18\x01\x20\x01(\x0b2..envoy.service.ext_proc.v3alpha.CommonResponseR\
    \x08response\"\xc0\x03\n\x0eCommonResponse\x12_\n\x06status\x18\x01\x20\
    \x01(\x0e2=.envoy.service.ext_proc.v3alpha.CommonResponse.ResponseStatus\
    R\x06statusB\x08\xfaB\x05\x82\x01\x02\x10\x01\x12W\n\x0fheader_mutation\
    \x18\x02\x20\x01(\x0b2..envoy.service.ext_proc.v3alpha.HeaderMutationR\
    \x0eheaderMutation\x12Q\n\rbody_mutation\x18\x03\x20\x01(\x0b2,.envoy.se\
    rvice.ext_proc.v3alpha.BodyMutationR\x0cbodyMutation\x12;\n\x08trailers\
    \x18\x04\x20\x01(\x0b2\x1f.envoy.config.core.v3.HeaderMapR\x08trailers\
    \x12*\n\x11clear_route_cache\x18\x05\x20\x01(\x08R\x0fclearRouteCache\"8\
    \n\x0eResponseStatus\x12\x0c\n\x08CONTINUE\x10\0\x12\x18\n\x14CONTINUE_A\
    ND_REPLACE\x10\x01\"\x95\x02\n\x11ImmediateResponse\x12;\n\x06status\x18\
    \x01\x20\x01(\x0b2\x19.envoy.type.v3.HttpStatusR\x06statusB\x08\xfaB\x05\
    \x8a\x01\x02\x10\x01\x12H\n\x07headers\x18\x02\x20\x01(\x0b2..envoy.serv\
    ice.ext_proc.v3alpha.HeaderMutationR\x07headers\x12\x12\n\x04body\x18\
    \x03\x20\x01(\tR\x04body\x12K\n\x0bgrpc_status\x18\x04\x20\x01(\x0b2*.en\
    voy.service.ext_proc.v3alpha.GrpcStatusR\ngrpcStatus\x12\x18\n\x07detail\
    s\x18\x05\x20\x01(\tR\x07details\"$\n\nGrpcStatus\x12\x16\n\x06status\
    \x18\x01\x20\x01(\rR\x06status\"\x81\x01\n\x0eHeaderMutation\x12H\n\x0bs\
    et_headers\x18\x01\x20\x03(\x0b2'.envoy.config.core.v3.HeaderValueOption\
    R\nsetHeaders\x12%\n\x0eremove_headers\x18\x02\x20\x03(\tR\rremoveHeader\
    s\"Q\n\x0cBodyMutation\x12\x14\n\x04body\x18\x01\x20\x01(\x0cH\0R\x04bod\
    y\x12\x1f\n\nclear_body\x18\x02\x20\x01(\x08H\0R\tclearBodyB\n\n\x08muta\
    tion2\x8b\x01\n\x11ExternalProcessor\x12v\n\x07Process\x121.envoy.servic\
    e.ext_proc.v3alpha.ProcessingRequest\x1a2.envoy.service.ext_proc.v3alpha\
    .ProcessingResponse\"\0(\x010\x01B[\n,io.envoyproxy.envoy.service.ext_pr\
    oc.v3alphaB\x16ExternalProcessorProtoP\x01\x88\x01\x01\xba\x80\xc8\xd1\
    \x06\x02\x08\x01\xba\x80\xc8\xd1\x06\x02\x10\x02b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
